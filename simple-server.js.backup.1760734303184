const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const rateLimit = require('express-rate-limit');
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const XLSX = require('xlsx');

// Importar configuraci√≥n
require('dotenv').config();
const config = require('./config/database');
const { generateSignedUrl } = require('./config/s3.config');

// Importar modelos
const User = require('./shared/models/User');
const Account = require('./shared/models/Account');
const Group = require('./shared/models/Group');
const Event = require('./shared/models/Event');
const EventAuthorization = require('./shared/models/EventAuthorization');
const Role = require('./shared/models/Role');
const Shared = require('./shared/models/Shared');
const Grupo = require('./shared/models/Grupo');
const Asistencia = require('./shared/models/Asistencia');
const Activity = require('./shared/models/Activity');
const ActivityFavorite = require('./shared/models/ActivityFavorite');
const Student = require('./shared/models/Student');
const Notification = require('./shared/models/Notification');
const Device = require('./shared/models/Device');
const Pickup = require('./shared/models/Pickup');
const RequestedShared = require('./shared/models/RequestedShared');
const PasswordReset = require('./shared/models/PasswordReset');
const ActiveAssociation = require('./shared/models/ActiveAssociation');
const StudentAction = require('./shared/models/StudentAction');
const StudentActionLog = require('./shared/models/StudentActionLog');
const { sendPasswordResetEmail, sendWelcomeEmail, sendInstitutionWelcomeEmail, sendFamilyInvitationEmail, sendNotificationEmail, generateRandomPassword, sendEmailAsync } = require('./config/email.config');
const emailService = require('./services/emailService');

// Importar middleware de autenticaci√≥n REAL con Cognito
const { authenticateToken, requireRole, requireAdmin, requireSuperAdmin } = require('./middleware/cognitoRealAuth');

// Importar middleware global para instituci√≥n de Cognito
const { getCognitoUserInstitution, verifyAccountAccess, getAccountFilter, getAccountFilterMultiple, verifyDivisionAccess } = require('./middleware/cognitoInstitution');

// Importar servicio de Cognito
const cognitoService = require('./services/cognitoService');

// Funci√≥n helper para obtener la asociaci√≥n activa del usuario
async function getActiveAssociationForUser(userId) {
  try {
    const activeAssociation = await ActiveAssociation.getActiveAssociation(userId);
    
    if (!activeAssociation) {
      console.log(`‚ö†Ô∏è [ACTIVE ASSOCIATION] No hay asociaci√≥n activa para usuario ${userId}`);
      return null;
    }

    // Populate los campos necesarios
    const populatedAssociation = await ActiveAssociation.findById(activeAssociation._id)
      .populate('account')
      .populate('role')
      .populate('division')
      .populate('student');

    return populatedAssociation;
  } catch (error) {
    console.error('‚ùå [ACTIVE ASSOCIATION] Error obteniendo asociaci√≥n activa:', error);
    return null;
  }
}

// Funci√≥n helper para crear asociaciones seg√∫n el rol
async function createAssociationByRole(userId, accountId, roleName, divisionId = null, studentId = null, createdBy) {
  try {
    // Obtener el rol
    const role = await Role.findOne({ nombre: roleName });
    if (!role) {
      throw new Error(`Rol '${roleName}' no encontrado`);
    }

    // Crear la asociaci√≥n base
    const associationData = {
      user: userId,
      account: accountId,
      role: role._id,
      status: 'active',
      createdBy: createdBy
    };

    // Agregar campos seg√∫n el rol
    switch (roleName) {
      case 'adminaccount':
        // Admin: solo instituci√≥n
        break;
      
      case 'coordinador':
        // Coordinador: instituci√≥n + grupo
        if (divisionId) {
          associationData.division = divisionId;
        }
        break;
      
      case 'familyadmin':
        // FamilyAdmin: instituci√≥n + grupo + alumno
        if (divisionId) {
          associationData.division = divisionId;
        }
        if (studentId) {
          associationData.student = studentId;
        }
        break;
      
      default:
        // Para otros roles, incluir grupo si se proporciona
        if (divisionId) {
          associationData.division = divisionId;
        }
        if (studentId) {
          associationData.student = studentId;
        }
    }

    const association = new Shared(associationData);
    await association.save();
    
    console.log(`‚úÖ Asociaci√≥n creada para rol '${roleName}':`, {
      user: userId,
      account: accountId,
      division: divisionId || 'no aplica',
      student: studentId || 'no aplica'
    });

    // Verificar si el usuario ya tiene una asociaci√≥n activa
    const existingActiveAssociation = await ActiveAssociation.getActiveAssociation(userId);
    
    if (!existingActiveAssociation) {
      // Si no tiene asociaci√≥n activa, establecer esta como activa autom√°ticamente
      try {
        await ActiveAssociation.setActiveAssociation(userId, association._id);
        console.log(`üéØ [AUTO-ACTIVE] Asociaci√≥n autom√°ticamente establecida como activa para usuario ${userId}`);
      } catch (error) {
        console.error('‚ùå [AUTO-ACTIVE] Error estableciendo asociaci√≥n activa autom√°ticamente:', error);
        // No lanzar error, solo loggear - la asociaci√≥n se cre√≥ correctamente
      }
    } else {
      console.log(`‚ÑπÔ∏è [AUTO-ACTIVE] Usuario ${userId} ya tiene una asociaci√≥n activa, no se cambia autom√°ticamente`);
    }

    return association;
  } catch (error) {
    console.error(`‚ùå Error creando asociaci√≥n para rol '${roleName}':`, error);
    throw error;
  }
}

// Importar rutas de upload
const uploadRoutes = require('./routes/upload');

// Importar rutas de documentos
const documentRoutes = require('./routes/documents');

// Configurar multer para subida de archivos
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    const uploadDir = path.join(__dirname, 'uploads');
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

// Configuraci√≥n de multer para im√°genes y videos
const upload = multer({ 
  storage: storage,
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB max
  },
  fileFilter: function (req, file, cb) {
    if (file.mimetype.startsWith('image/') || file.mimetype.startsWith('video/')) {
      cb(null, true);
    } else {
      cb(new Error('Solo se permiten archivos de imagen o video'));
    }
  }
});

// Configuraci√≥n de multer-s3 para subida directa a S3
const multerS3 = require('multer-s3');
const { s3 } = require('./config/s3.config');

const uploadToS3 = multer({
  storage: multerS3({
    s3: s3,
    bucket: process.env.AWS_S3_BUCKET_NAME || 'kiki-bucket-app',
    contentType: multerS3.AUTO_CONTENT_TYPE,
    key: function (req, file, cb) {
      const userId = req.user._id;
      const fileName = `avatars/${userId}/${Date.now()}-${file.originalname}`;
      cb(null, fileName);
    }
  }),
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB max
  },
  fileFilter: function (req, file, cb) {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Solo se permiten archivos de imagen'));
    }
  }
});

// Configuraci√≥n espec√≠fica para avatares de estudiantes
const uploadStudentAvatarToS3 = multer({
  storage: multerS3({
    s3: s3,
    bucket: process.env.AWS_S3_BUCKET_NAME || 'kiki-bucket-app',
    contentType: multerS3.AUTO_CONTENT_TYPE,
    key: function (req, file, cb) {
      const studentId = req.params.studentId;
      const fileName = `students/${studentId}/${Date.now()}-${file.originalname}`;
      cb(null, fileName);
    }
  }),
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB max
  },
  fileFilter: function (req, file, cb) {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Solo se permiten archivos de imagen'));
    }
  }
});

// Configuraci√≥n de multer para archivos Excel
const uploadExcel = multer({ 
  storage: storage,
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB max
  },
  fileFilter: function (req, file, cb) {
    // Permitir archivos Excel
    if (file.mimetype === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' || // .xlsx
        file.mimetype === 'application/vnd.ms-excel' || // .xls
        file.originalname.endsWith('.xlsx') ||
        file.originalname.endsWith('.xls')) {
      cb(null, true);
    } else {
      cb(new Error('Solo se permiten archivos Excel (.xlsx, .xls)'));
    }
  }
});

const app = express();

// Middleware de seguridad
app.use(helmet());

// CORS - Configurado para permitir conexiones desde apps m√≥viles
app.use(cors({
  origin: function (origin, callback) {
    // Permitir requests sin origin (como apps m√≥viles)
    if (!origin) return callback(null, true);
    
    // Permitir localhost, IPs locales y dominios de producci√≥n
    const allowedOrigins = [
      'http://localhost:3000',
      'http://localhost:5173',
      'http://localhost:5174',
      'http://localhost:8080',
      'http://localhost:8081',
      'http://127.0.0.1:3000',
      'http://127.0.0.1:5173',
      'http://127.0.0.1:5174',
      'http://127.0.0.1:8080',
      'http://127.0.0.1:8081',
      'https://backoffice.kiki.com.ar',
      'http://backoffice.kiki.com.ar',
      process.env.FRONTEND_URL
    ].filter(Boolean);
    
    if (allowedOrigins.includes(origin) || process.env.NODE_ENV === 'development') {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
}));

// Rate limiting general
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 200, // l√≠mite de 200 requests por IP por ventana
  message: {
    success: false,
    message: 'Demasiadas solicitudes, intenta de nuevo m√°s tarde'
  }
});
app.use(limiter);

// Logging
app.use(morgan('combined'));

// Middleware personalizado para logging detallado
app.use((req, res, next) => {
  console.log(`\nüîç [${new Date().toISOString()}] ${req.method} ${req.path}`);
  console.log(`üì¶ Body:`, JSON.stringify(req.body, null, 2));
  console.log(`üîë Headers:`, {
    'authorization': req.headers.authorization ? 'Bearer ***' : 'No auth',
    'content-type': req.headers['content-type'],
    'user-agent': req.headers['user-agent'],
    'origin': req.headers['origin'] || 'No origin'
  });
  console.log(`üìã Query:`, req.query);
  console.log(`üÜî Params:`, req.params);
  console.log(`---`);
  next();
});

// Body parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Endpoint de prueba para acciones (antes del middleware de redirecci√≥n)
app.get('/api/test-actions', (req, res) => {
  console.log('üéØ [TEST] Endpoint de prueba llamado');
  res.json({
    success: true,
    message: 'Endpoint de prueba funcionando',
    data: []
  });
});

app.post('/api/test-actions', (req, res) => {
  console.log('üéØ [TEST POST] Endpoint de prueba POST llamado');
  res.json({
    success: true,
    message: 'Endpoint de prueba POST funcionando',
    data: []
  });
});

// Endpoint de prueba simple
app.get('/test-simple', (req, res) => {
  console.log('üéØ [SIMPLE TEST] Endpoint simple llamado');
  res.json({
    success: true,
    message: 'Endpoint simple funcionando'
  });
});

// Endpoint temporal para listar divisiones
app.get('/api/debug/divisions', async (req, res) => {
  try {
    const divisions = await Group.find({}).select('_id nombre account').lean();
    console.log('üîç [DEBUG] Divisiones encontradas:', divisions.length);
    res.json({
      success: true,
      message: 'Divisiones encontradas',
      data: divisions
    });
  } catch (error) {
    console.error('‚ùå [DEBUG] Error al obtener divisiones:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener divisiones'
    });
  }
});

// Endpoint temporal para verificar una divisi√≥n espec√≠fica
app.get('/api/debug/division/:id', async (req, res) => {
  try {
    const { id } = req.params;
    console.log('üîç [DEBUG] Buscando divisi√≥n:', id);
    const division = await Group.findById(id).lean();
    console.log('üîç [DEBUG] Divisi√≥n encontrada:', division);
    res.json({
      success: true,
      message: 'Divisi√≥n encontrada',
      data: division
    });
  } catch (error) {
    console.error('‚ùå [DEBUG] Error al obtener divisi√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener divisi√≥n'
    });
  }
});

// Endpoint temporal para probar student-actions sin autenticaci√≥n
app.get('/api/debug/student-actions/division/:divisionId', async (req, res) => {
  try {
    const { divisionId } = req.params;
    console.log('üîç [DEBUG] Obteniendo acciones para divisi√≥n:', divisionId);
    
    const actions = await StudentAction.find({ division: divisionId }).lean();
    console.log('üîç [DEBUG] Acciones encontradas:', actions.length);
    
    res.json({
      success: true,
      message: 'Acciones encontradas',
      data: actions
    });
  } catch (error) {
    console.error('‚ùå [DEBUG] Error al obtener acciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener acciones'
    });
  }
});

// Endpoint temporal para probar student-actions sin autenticaci√≥n (sin prefijo /api)
app.get('/debug/student-actions/division/:divisionId', async (req, res) => {
  try {
    const { divisionId } = req.params;
    console.log('üîç [DEBUG] Obteniendo acciones para divisi√≥n:', divisionId);
    
    const actions = await StudentAction.find({ division: divisionId }).lean();
    console.log('üîç [DEBUG] Acciones encontradas:', actions.length);
    
    res.json({
      success: true,
      message: 'Acciones encontradas',
      data: actions
    });
  } catch (error) {
    console.error('‚ùå [DEBUG] Error al obtener acciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener acciones'
    });
  }
});

// Endpoint temporal para crear acciones sin autenticaci√≥n
app.post('/api/debug/student-actions', async (req, res) => {
  try {
    const { nombre, descripcion, division, color, orden } = req.body;
    console.log('üîç [DEBUG] Creando acci√≥n:', { nombre, descripcion, division, color, orden });
    
    // Verificar que la divisi√≥n existe
    const divisionExists = await Group.findById(division);
    if (!divisionExists) {
      console.log('‚ùå [DEBUG] Divisi√≥n no encontrada:', division);
      return res.status(404).json({
        success: false,
        message: 'La divisi√≥n especificada no existe'
      });
    }
    
    // Crear la acci√≥n
    const nuevaAccion = new StudentAction({
      nombre,
      descripcion,
      division,
      account: divisionExists.account,
      color: color || '#3B82F6',
      orden: orden || 0,
      creadoPor: new mongoose.Types.ObjectId() // ID temporal
    });
    
    await nuevaAccion.save();
    console.log('‚úÖ [DEBUG] Acci√≥n creada:', nuevaAccion._id);
    
    res.status(201).json({
      success: true,
      message: 'Acci√≥n creada exitosamente',
      data: nuevaAccion
    });
  } catch (error) {
    console.error('‚ùå [DEBUG] Error al crear acci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error al crear la acci√≥n'
    });
  }
});

// Endpoint temporal para actualizar acciones sin autenticaci√≥n
app.put('/api/debug/student-actions/:actionId', async (req, res) => {
  try {
    const { actionId } = req.params;
    const updateData = req.body;
    console.log('üîç [DEBUG] Actualizando acci√≥n:', actionId, updateData);
    
    const action = await StudentAction.findByIdAndUpdate(
      actionId,
      updateData,
      { new: true }
    );
    
    if (!action) {
      return res.status(404).json({
        success: false,
        message: 'Acci√≥n no encontrada'
      });
    }
    
    console.log('‚úÖ [DEBUG] Acci√≥n actualizada:', action._id);
    
    res.json({
      success: true,
      message: 'Acci√≥n actualizada exitosamente',
      data: action
    });
  } catch (error) {
    console.error('‚ùå [DEBUG] Error al actualizar acci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error al actualizar la acci√≥n'
    });
  }
});

// Endpoint temporal para eliminar acciones sin autenticaci√≥n
app.delete('/api/debug/student-actions/:actionId', async (req, res) => {
  try {
    const { actionId } = req.params;
    console.log('üîç [DEBUG] Eliminando acci√≥n:', actionId);
    
    const action = await StudentAction.findByIdAndDelete(actionId);
    
    if (!action) {
      return res.status(404).json({
        success: false,
        message: 'Acci√≥n no encontrada'
      });
    }
    
    console.log('‚úÖ [DEBUG] Acci√≥n eliminada:', actionId);
    
    res.json({
      success: true,
      message: 'Acci√≥n eliminada exitosamente'
    });
  } catch (error) {
    console.error('‚ùå [DEBUG] Error al eliminar acci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error al eliminar la acci√≥n'
    });
  }
});

// Endpoint temporal para eliminar acciones sin autenticaci√≥n (sin prefijo /api)
app.delete('/debug/student-actions/:actionId', async (req, res) => {
  try {
    const { actionId } = req.params;
    console.log('üîç [DEBUG] Eliminando acci√≥n:', actionId);
    
    const action = await StudentAction.findByIdAndDelete(actionId);
    
    if (!action) {
      return res.status(404).json({
        success: false,
        message: 'Acci√≥n no encontrada'
      });
    }
    
    console.log('‚úÖ [DEBUG] Acci√≥n eliminada:', actionId);
    
    res.json({
      success: true,
      message: 'Acci√≥n eliminada exitosamente'
    });
  } catch (error) {
    console.error('‚ùå [DEBUG] Error al eliminar acci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error al eliminar la acci√≥n'
    });
  }
});

// Middleware para redirigir rutas con /api duplicado
app.use((req, res, next) => {
  if (req.path.startsWith('/api/') && 
      !req.path.startsWith('/api/student-actions') &&
      !req.path.startsWith('/api/test-actions') &&
      !req.path.startsWith('/api/debug') &&
      !req.path.startsWith('/api/documents')) {
    // Remover el /api duplicado del inicio, excepto para student-actions, test-actions, debug, documents y coordinators
    const newPath = req.path.replace(/^\/api/, '');
    console.log(`üîÑ [REDIRECT] Redirigiendo ${req.method} ${req.path} -> ${newPath}`);
    req.url = newPath;
    req.path = newPath;
  }
  next();
});

// Servir archivos est√°ticos
app.use('/uploads', express.static('uploads'));

// Conectar a MongoDB
console.log('üîó MongoDB URI:', config.MONGODB_URI)
mongoose.connect(config.MONGODB_URI)
  .then(() => {
    console.log('‚úÖ Conectado a MongoDB');
    console.log('üìä Base de datos:', mongoose.connection.name);
    console.log('üìä Estado de conexi√≥n:', mongoose.connection.readyState);
  })
  .catch(err => console.error('‚ùå Error conectando a MongoDB:', err));

// Middleware de autenticaci√≥n
// Middleware de autenticaci√≥n h√≠brido importado desde cognitoAuth.js

// Health check
app.get('/health', (req, res) => {
  res.json({
    success: true,
    message: 'API de Kiki est√° funcionando correctamente',
    timestamp: new Date().toISOString(),
    version: '1.0.0',
    services: ['users', 'accounts', 'groups', 'events', 'roles']
  });
});

// Health check en la ra√≠z
app.get('/', (req, res) => {
  res.json({
    success: true,
    message: 'API de Kiki est√° funcionando correctamente',
    timestamp: new Date().toISOString(),
    version: '1.0.0',
    services: ['users', 'accounts', 'groups', 'events', 'roles']
  });
});


// Documentaci√≥n de la API
app.get('/api', (req, res) => {
  res.json({
    success: true,
    message: 'API de Kiki',
    version: '1.0.0',
    endpoints: {
      auth: {
        login: 'POST /api/users/login',
        register: 'POST /api/users/register',
        profile: 'GET /api/users/profile'
      },
      users: {
        list: 'GET /api/users',
        getById: 'GET /api/users/:id',
        update: 'PUT /api/users/:id',
        updateStatus: 'PUT /api/users/:id/status'
      },
      accounts: {
        list: 'GET /api/accounts',
        create: 'POST /api/accounts',
        getById: 'GET /api/accounts/:id',
        update: 'PUT /api/accounts/:id',
        delete: 'DELETE /api/accounts/:id',
        stats: 'GET /api/accounts/stats'
      },
      groups: {
        list: 'GET /api/groups',
        create: 'POST /api/groups',
        getById: 'GET /api/groups/:id',
        update: 'PUT /api/groups/:id',
        delete: 'DELETE /api/groups/:id',
        addUser: 'POST /api/groups/:id/users',
        removeUser: 'DELETE /api/groups/:id/users/:userId'
      },
      events: {
        list: 'GET /api/events',
        create: 'POST /api/events',
        getById: 'GET /api/events/:id',
        update: 'PUT /api/events/:id',
        delete: 'DELETE /api/events/:id',
        addParticipant: 'POST /api/events/:id/participants',
        removeParticipant: 'DELETE /api/events/:id/participants/:userId'
      },
      roles: {
        list: 'GET /api/roles',
        getById: 'GET /api/roles/:id',
        hierarchy: 'GET /api/roles/hierarchy'
      }
    }
  });
});

// ===== RUTAS DE AUTENTICACI√ìN =====

// Endpoint de prueba para debuggear
app.post('/debug/test', async (req, res) => {
  try {
    console.log('üîç [DEBUG] Endpoint de prueba funcionando');
    res.json({ success: true, message: 'Debug endpoint funcionando' });
  } catch (error) {
    console.error('‚ùå [DEBUG] Error en endpoint de prueba:', error);
    res.status(500).json({ success: false, message: 'Error en debug', error: error.message });
  }
});

// Login
app.post('/users/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    console.log('üîç Login attempt:', email);

    if (!email || !password) {
      return res.status(400).json({
        success: false,
        message: 'Email y contrase√±a son requeridos'
      });
    }

    // Buscar usuario en la base de datos
    const user = await User.findOne({ email }).populate('role');
    
    if (!user) {
      console.log('‚ùå Usuario no encontrado:', email);
      return res.status(401).json({
        success: false,
        message: 'Credenciales inv√°lidas'
      });
    }

    console.log('‚úÖ Usuario encontrado:', user.email);
    console.log('üìä Status:', user.status);
    console.log('üé≠ Rol:', user.role?.nombre);
    console.log('üîë isFirstLogin:', user.isFirstLogin);

    // Verificar si el usuario est√° activo
    if (user.status !== 'approved') {
      return res.status(401).json({
        success: false,
        message: 'Usuario no aprobado o inactivo'
      });
    }

    // TODOS LOS USUARIOS DEBEN AUTENTICARSE CON COGNITO
    // console.log('üîÑ TODOS los usuarios deben autenticarse con Cognito...');
    
    // Redirigir a Cognito para autenticaci√≥n (COMENTADO)
    // return res.status(200).json({
      success: true,
      message: 'Usuario debe autenticarse con Cognito - usar endpoint /auth/cognito-login',
      redirectToCognito: true,
      email: email
    });

  } catch (error) {
    console.error('‚ùå Error en login:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Cambiar contrase√±a
app.post('/users/change-password', /* authenticateToken, */ async (req, res) => {
  try {
    const { currentPassword, newPassword, isFirstLogin } = req.body;
    const userId = req.user.userId;

    console.log('üîë [CHANGE PASSWORD] Usuario:', userId);
    console.log('üîë [CHANGE PASSWORD] Es primer login:', isFirstLogin);
    console.log('üîë [CHANGE PASSWORD] Usuario autenticado - no se requiere contrase√±a actual');

    if (!newPassword) {
      return res.status(400).json({
        success: false,
        message: 'La nueva contrase√±a es requerida'
      });
    }

    // Validar requisitos de contrase√±a
    const passwordValidation = {
      minLength: newPassword.length >= 8,
      hasUpperCase: /[A-Z]/.test(newPassword),
      hasLowerCase: /[a-z]/.test(newPassword),
      hasNumbers: /\d/.test(newPassword),
      hasSpecialChar: /[!@#$%^&*(),.?":{}|<>]/.test(newPassword)
    };

    const isValidPassword = Object.values(passwordValidation).every(requirement => requirement);
    
    if (!isValidPassword) {
      return res.status(400).json({
        success: false,
        message: 'La nueva contrase√±a no cumple con los requisitos de seguridad'
      });
    }

    // Buscar usuario
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    // Ya no verificamos contrase√±a actual - el usuario ya est√° autenticado

    // Actualizar contrase√±a
    user.password = newPassword;
    user.isFirstLogin = false; // Marcar que ya no es primer login
    await user.save();

    console.log('‚úÖ [CHANGE PASSWORD] Contrase√±a actualizada exitosamente para usuario:', userId);

    res.json({
      success: true,
      message: 'Contrase√±a actualizada exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [CHANGE PASSWORD] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Crear usuario desde backoffice - DESACTIVADO
app.post('/users', /* authenticateToken, */ async (req, res) => {
  try {
    console.log('üë§ [CREATE USER] Intento de creaci√≥n de usuario desde backoffice - DESACTIVADO');
    
    return res.status(403).json({
      success: false,
      message: 'La creaci√≥n de usuarios desde el backoffice est√° desactivada. Los usuarios se crean mediante carga de Excel o desde la app m√≥vil.'
    });
    
    // C√≥digo desactivado - Los usuarios se crean por Excel o app m√≥vil
    /*
    const { name, email, role, status, avatar } = req.body;
    const { userId } = req.user;

    if (!name || !email || !role) {
      return res.status(400).json({
        success: false,
        message: 'Nombre, email y rol son requeridos'
      });
    }

    // Verificar que el usuario que crea es admin
    const currentUser = await User.findById(userId).populate('role');
    if (!currentUser || !['superadmin', 'adminaccount'].includes(currentUser.role?.nombre)) {
      return res.status(403).json({
        success: false,
        message: 'Solo administradores pueden crear usuarios'
      });
    }

    // Verificar que el email no exista
    const existingUser = await User.findOne({ email: email.toLowerCase() });
    if (existingUser) {
      return res.status(400).json({
        success: false,
        message: 'Ya existe un usuario con este email'
      });
    }

    // Buscar el rol
    const roleDoc = await Role.findOne({ nombre: role });
    if (!roleDoc) {
      return res.status(400).json({
        success: false,
        message: 'Rol no v√°lido'
      });
    }

    // Generar contrase√±a aleatoria
    const generateRandomPassword = () => {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      let password = '';
      for (let i = 0; i < 8; i++) {
        password += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return password;
    };

    const randomPassword = generateRandomPassword();
    console.log('üîë [CREATE USER] Contrase√±a generada para:', email);

    // Crear el usuario
    const newUser = new User({
      name: name,
      email: email.toLowerCase(),
      password: randomPassword,
      role: roleDoc._id,
      status: status === 'active' ? 'approved' : 'pending',
      activo: status === 'active',
      isFirstLogin: true // Marcar como primer login
    });

    await newUser.save();
    console.log('‚úÖ [CREATE USER] Usuario creado exitosamente:', newUser._id);

    // Enviar email de bienvenida con la contrase√±a (as√≠ncrono)
    sendEmailAsync(sendWelcomeEmail, null, newUser.email, newUser.name);
    console.log('üìß [CREATE USER] Email de bienvenida programado para env√≠o as√≠ncrono a:', email);

    // Populate para la respuesta
    const populatedUser = await User.findById(newUser._id)
      .populate('role', 'nombre descripcion nivel');

    res.status(201).json({
      success: true,
      message: 'Usuario creado exitosamente. Se enviar√° un email con la contrase√±a.',
      data: {
        user: {
          _id: populatedUser._id,
          name: populatedUser.name,
          email: populatedUser.email,
          role: populatedUser.role,
          status: populatedUser.status,
          activo: populatedUser.activo,
          createdAt: populatedUser.createdAt,
          updatedAt: populatedUser.updatedAt
        },
        password: randomPassword // Temporalmente incluir la contrase√±a en la respuesta para testing
      }
    });
    */
    
  } catch (error) {
    console.error('‚ùå [CREATE USER] Error interno:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Registro - DESACTIVADO
app.post('/users/register', async (req, res) => {
  try {
    console.log('üë§ [REGISTER] Intento de registro general - DESACTIVADO');
    
    return res.status(403).json({
      success: false,
      message: 'El registro general est√° desactivado. Los usuarios se crean mediante carga de Excel o desde la app m√≥vil.'
    });
    
    // C√≥digo desactivado - Los usuarios se crean por Excel o app m√≥vil
    /*
    const { email, password, nombre } = req.body;

    if (!email || !password || !nombre) {
      return res.status(400).json({
        success: false,
        message: 'Email, contrase√±a y nombre son requeridos'
      });
    }

    // Simular registro exitoso para pruebas
    res.status(201).json({
      success: true,
      message: 'Usuario registrado exitosamente',
      data: {
        token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.test',
        user: {
          _id: '64f8a1b2c3d4e5f6a7b8c9d0',
          email: email,
          nombre: nombre,
          role: {
            _id: '64f8a1b2c3d4e5f6a7b8c9d1',
            nombre: 'familyviewer',
            descripcion: 'Visualizador de familia',
            nivel: 5
          },
          activo: true,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        }
      }
    });
    */
    
  } catch (error) {
    console.error('Error en registro:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Verificar token
app.get('/auth/verify', /* authenticateToken, */ async (req, res) => {
  try {
    // Buscar el usuario completo para obtener el avatar
    const user = await User.findById(req.user._id);
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    // Generar URL firmada para el avatar si existe
    let avatarUrl = null;
    if (user.avatar) {
      try {
        avatarUrl = await generateSignedUrl(user.avatar, 172800); // 2 d√≠as
      } catch (error) {
        console.error('Error generando URL firmada para avatar:', error);
        // Si falla la URL firmada, usar la URL directa
        avatarUrl = user.avatar;
      }
    }

    res.json({
      success: true,
      message: 'Token v√°lido',
      data: {
        _id: user._id,
        name: user.name,
        email: user.email,
        role: user.role,
        avatar: avatarUrl,
        status: user.status,
        lastLogin: user.lastLogin,
        createdAt: user.createdAt,
        updatedAt: user.updatedAt
      }
    });
  } catch (error) {
    console.error('Error verificando token:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// ===== ENDPOINT DE LOGIN CON COGNITO =====

// Endpoint de login con Cognito - SOLO COGNITO, NO MONGODB
app.post('/auth/cognito-login', async (req, res) => {
  try {
    const { email, password } = req.body;

    console.log('üîç [COGNITO LOGIN] Intentando login con Cognito real:', email);

    if (!email || !password) {
      return res.status(400).json({
        success: false,
        message: 'Email y contrase√±a son requeridos'
      });
    }

    // Verificar si Cognito est√° configurado
    console.log('üîç [COGNITO LOGIN] Verificando configuraci√≥n de Cognito...');
    console.log('üîç [COGNITO LOGIN] isConfigured():', cognitoService.isConfigured());
    
    if (!cognitoService.isConfigured()) {
      console.log('‚ö†Ô∏è [COGNITO LOGIN] Cognito no configurado, usando modo simulado');
      
      // Modo simulado para desarrollo
      const cognitoToken = `cognito-jwt-${Date.now()}-${email}`;
      
      return res.json({
        success: true,
        message: 'Login exitoso con Cognito (modo simulado)',
        data: {
          user: {
            email: email,
            name: email.split('@')[0],
            cognitoId: `cognito-${Date.now()}`,
            source: 'cognito-simulated',
            role: { nombre: 'superadmin' } // Rol por defecto para modo simulado
          },
          token: cognitoToken,
          tokenType: 'cognito',
          expiresIn: '1h'
        }
      });
    }

    // AUTENTICACI√ìN REAL CON COGNITO
    console.log('üîç [COGNITO LOGIN] Autenticando con AWS Cognito real...');
    
    const authResult = await cognitoService.authenticateUser(email, password);
    
    if (authResult.success) {
      console.log('‚úÖ [COGNITO LOGIN] Autenticaci√≥n exitosa con Cognito real');
      
      // Obtener informaci√≥n del usuario
      const userInfo = await cognitoService.getUserInfo(authResult.tokens.accessToken);
      
      // Extraer el rol del token de Cognito
      let userRole = 'adminaccount'; // Rol por defecto
      try {
        // Decodificar el ID token para extraer los grupos
        const jwt = require('jsonwebtoken');
        const decodedToken = jwt.decode(authResult.tokens.idToken);
        console.log('üîç [COGNITO LOGIN] Token decodificado:', decodedToken);
        
        if (decodedToken && decodedToken['cognito:groups'] && decodedToken['cognito:groups'].length > 0) {
          userRole = decodedToken['cognito:groups'][0];
          console.log('üîç [COGNITO LOGIN] Rol extra√≠do del token:', userRole);
        } else {
          console.log('‚ö†Ô∏è [COGNITO LOGIN] No se encontraron grupos en el token, usando rol por defecto');
        }
      } catch (error) {
        console.error('‚ùå [COGNITO LOGIN] Error decodificando token:', error);
        console.log('‚ö†Ô∏è [COGNITO LOGIN] Usando rol por defecto debido al error');
      }
      
      res.json({
        success: true,
        message: 'Login exitoso con Cognito',
        data: {
          user: {
            email: email,
            name: userInfo.success ? userInfo.user.name : email.split('@')[0],
            cognitoId: `cognito-${Date.now()}`,
            source: 'cognito-real',
            role: { nombre: userRole } // Incluir el rol en la respuesta
          },
          token: authResult.tokens.idToken, // Usar el ID token de Cognito
          accessToken: authResult.tokens.accessToken,
          refreshToken: authResult.tokens.refreshToken,
          tokenType: authResult.tokens.tokenType,
          expiresIn: authResult.tokens.expiresIn
        }
      });
    } else if (authResult.challengeName) {
      console.log('üîß [COGNITO LOGIN] Desaf√≠o requerido:', authResult.challengeName);
      res.status(400).json({
        success: false,
        message: authResult.message,
        challengeName: authResult.challengeName,
        session: authResult.session
      });
    } else {
      console.log('‚ùå [COGNITO LOGIN] Autenticaci√≥n fallida:', authResult.message);
      res.status(401).json({
        success: false,
        message: authResult.message
      });
    }

  } catch (error) {
    console.error('‚ùå [COGNITO LOGIN] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Endpoint para verificar configuraci√≥n JWT (solo para debugging)
app.get('/auth/config', (req, res) => {
  res.json({
    success: true,
    jwt_secret_length: config.JWT_SECRET.length,
    jwt_expire: config.JWT_EXPIRE,
    message: 'Configuraci√≥n JWT actual'
  });
});

// Obtener perfil - Versi√≥n simplificada para Cognito
app.get('/users/profile', authenticateToken, async (req, res) => {
  try {
    const user = req.user;
    
    // Si es usuario de Cognito, buscar informaci√≥n en MongoDB si es adminaccount
    if (user.isCognitoUser) {
      console.log('‚úÖ [PROFILE] Usuario de Cognito:', user.email);
      
      let userAccount = null;
      
      // Para adminaccount, buscar en la tabla users de MongoDB usando el email
      if (user.role?.nombre === 'adminaccount') {
        console.log('üîç [PROFILE] Adminaccount de Cognito, buscando en tabla users...');
        
        try {
          // Buscar el usuario en MongoDB usando el email
          const dbUser = await User.findOne({ email: user.email })
            .populate('account', 'nombre razonSocial')
            .populate('role', 'nombre descripcion');
          
          if (dbUser && dbUser.account) {
            userAccount = dbUser.account;
            console.log('‚úÖ [PROFILE] Usuario encontrado en MongoDB con instituci√≥n:', dbUser.account.nombre);
          } else {
            console.log('‚ö†Ô∏è [PROFILE] Usuario no encontrado en MongoDB o sin instituci√≥n asignada');
          }
        } catch (error) {
          console.error('‚ùå [PROFILE] Error buscando usuario en MongoDB:', error);
        }
      }
      
      return res.json({
        success: true,
        data: {
          id: user._id,
          email: user.email,
          name: user.name,
          role: user.role,
          status: user.status,
          source: 'cognito',
          account: userAccount, // Incluir informaci√≥n de la instituci√≥n desde MongoDB
          avatar: null // Los usuarios de Cognito no tienen avatar por ahora
        }
      });
    }

    // C√≥digo original para usuarios de MongoDB (legacy)
    // Buscar el usuario completo con el rol y cuenta populados
    const dbUser = await User.findById(req.user._id).populate('role', 'nombre descripcion nivel').populate('account', 'nombre razonSocial');
    if (!dbUser) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    // Para adminaccount, obtener la cuenta desde las asociaciones si no tiene cuenta asignada directamente
    let userAccount = dbUser.account;
    if (dbUser.role?.nombre === 'adminaccount' && !userAccount) {
      console.log('üîç [PROFILE] Adminaccount sin cuenta directa, obteniendo desde asociaciones...');
      const userAssociation = await Shared.findOne({
        user: dbUser._id,
        status: 'active'
      }).populate('account', 'nombre razonSocial');
      
      if (userAssociation && userAssociation.account) {
        userAccount = userAssociation.account;
        console.log('üîç [PROFILE] Cuenta obtenida desde asociaci√≥n:', userAccount);
      }
    }

    // Generar URL firmada para el avatar si existe
    let avatarUrl = null;
    if (dbUser.avatar) {
      try {
        avatarUrl = await generateSignedUrl(dbUser.avatar, 172800); // 2 d√≠as
      } catch (error) {
        console.error('Error generando URL firmada para avatar:', error);
        // Si falla la URL firmada, usar la URL directa
        avatarUrl = dbUser.avatar;
      }
    }

    res.json({
      success: true,
      data: {
        _id: dbUser._id,
        email: dbUser.email,
        nombre: dbUser.name,
        role: dbUser.role,
        account: userAccount,
        telefono: dbUser.telefono,
        avatar: avatarUrl,
        activo: dbUser.status === 'approved',
        createdAt: dbUser.createdAt,
        updatedAt: dbUser.updatedAt
      }
    });

  } catch (error) {
    console.error('Error obteniendo perfil:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Actualizar perfil
app.put('/users/profile', authenticateToken, async (req, res) => {
  try {
    const { name, email, phone, telefono } = req.body;
    const userId = req.user._id;

    console.log('üîç [Server] Actualizando perfil para usuario:', userId);
    console.log('üìù Datos recibidos:', { name, email, phone, telefono });

    // Buscar el usuario
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    console.log('üîç Usuario encontrado antes de actualizar:', {
      _id: user._id,
      email: user.email,
      name: user.name,
      telefono: user.telefono,
      status: user.status
    });

    // Verificar si el email ya existe (si se est√° cambiando)
    if (email && email !== user.email) {
      const existingUser = await User.findOne({ email });
      if (existingUser) {
        return res.status(400).json({
          success: false,
          message: 'El email ya est√° en uso'
        });
      }
    }

    // Actualizar campos
    if (name) user.name = name;
    if (email) user.email = email;
    
    // Manejar tanto 'phone' como 'telefono' para compatibilidad
    if (phone) user.telefono = phone;
    if (telefono) user.telefono = telefono;

    await user.save();

    console.log('‚úÖ Perfil actualizado exitosamente');
    console.log('üìù Usuario despu√©s de guardar:', {
      _id: user._id,
      email: user.email,
      name: user.name,
      telefono: user.telefono,
      status: user.status
    });

    // Generar URL firmada para el avatar si existe
    let avatarUrl = null;
    if (user.avatar) {
      try {
        avatarUrl = await generateSignedUrl(user.avatar, 172800); // 2 d√≠as
      } catch (error) {
        console.error('Error generando URL firmada para avatar:', error);
        // Si falla la URL firmada, usar la URL directa
        avatarUrl = user.avatar;
      }
    }

    res.json({
      success: true,
      message: 'Perfil actualizado exitosamente',
      data: {
        _id: user._id,
        email: user.email,
        nombre: user.name,
        role: user.role,
        telefono: user.telefono,
        avatar: avatarUrl,
        activo: user.status === 'approved',
        createdAt: user.createdAt,
        updatedAt: user.updatedAt
      }
    });
  } catch (error) {
    console.error('Error actualizando perfil:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Actualizar avatar del usuario
app.put('/users/avatar', authenticateToken, upload.single('avatar'), async (req, res) => {
  console.log('üñºÔ∏è [AVATAR ENDPOINT] Petici√≥n recibida');
  console.log('üñºÔ∏è [AVATAR ENDPOINT] Headers:', req.headers);
  console.log('üñºÔ∏è [AVATAR ENDPOINT] Body:', req.body);
  console.log('üñºÔ∏è [AVATAR ENDPOINT] File:', req.file);
  try {
    const userId = req.user._id;

    console.log('üñºÔ∏è [UPDATE AVATAR] Iniciando actualizaci√≥n de avatar');
    console.log('üë§ [UPDATE AVATAR] Usuario:', userId);
    console.log('üìÅ [UPDATE AVATAR] Archivo recibido:', req.file);

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se proporcion√≥ ninguna imagen'
      });
    }

    // El archivo se guard√≥ localmente, ahora lo subimos a S3
    console.log('üñºÔ∏è [UPDATE AVATAR] Archivo guardado localmente:', req.file.filename);
    console.log('üñºÔ∏è [UPDATE AVATAR] Subiendo a S3...');
    
    // Leer el archivo local
    const fileBuffer = fs.readFileSync(req.file.path);
    
    // Subir a S3
    const AWS = require('aws-sdk');
    const s3 = new AWS.S3({
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
      region: process.env.AWS_REGION || 'us-east-1'
    });
    
    const avatarKey = `avatars/${userId}/${Date.now()}-${req.file.originalname}`;
    
    const uploadParams = {
      Bucket: process.env.AWS_S3_BUCKET_NAME,
      Key: avatarKey,
      Body: fileBuffer,
      ContentType: req.file.mimetype
    };
    
    const s3Result = await s3.upload(uploadParams).promise();
    console.log('üñºÔ∏è [UPDATE AVATAR] Archivo subido a S3:', s3Result.Location);
    
    // Eliminar archivo local
    try {
      if (fs.existsSync(req.file.path)) {
        fs.unlinkSync(req.file.path);
        console.log('üñºÔ∏è [UPDATE AVATAR] Archivo local eliminado:', req.file.path);
      } else {
        console.log('üñºÔ∏è [UPDATE AVATAR] Archivo local no existe:', req.file.path);
      }
    } catch (error) {
      console.error('üñºÔ∏è [UPDATE AVATAR] Error eliminando archivo local:', error.message);
    }

    // Actualizar el usuario con la nueva imagen
    const updatedUser = await User.findByIdAndUpdate(
      userId,
      { 
        avatar: avatarKey, // Guardar la key de S3 (no la URL completa)
        updatedAt: new Date()
      },
      { new: true }
    ).populate('role');

    if (!updatedUser) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    console.log('‚úÖ [UPDATE AVATAR] Avatar actualizado exitosamente');

    // Generar URL firmada para la respuesta
    const { generateSignedUrl } = require('./config/s3.config');
    const signedUrl = await generateSignedUrl(avatarKey, 172800); // 2 d√≠as
    
    console.log('üñºÔ∏è [UPDATE AVATAR] URL firmada generada:', signedUrl);

    res.json({
      success: true,
      message: 'Avatar actualizado exitosamente',
      data: {
        user: {
          _id: updatedUser._id,
          name: updatedUser.name,
          email: updatedUser.email,
          avatar: signedUrl, // Devolver la URL firmada
          role: updatedUser.role
        }
      }
    });

  } catch (error) {
    console.error('Error actualizando avatar:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Actualizar avatar del estudiante (solo familyadmin)
app.put('/students/:studentId/avatar', authenticateToken, uploadStudentAvatarToS3.single('avatar'), async (req, res) => {
  console.log('üñºÔ∏è [STUDENT AVATAR ENDPOINT] Petici√≥n recibida');
  console.log('üñºÔ∏è [STUDENT AVATAR ENDPOINT] Student ID:', req.params.studentId);
  console.log('üñºÔ∏è [STUDENT AVATAR ENDPOINT] File:', req.file);
  
  try {
    const { studentId } = req.params;
    const userId = req.user._id;

    console.log('üñºÔ∏è [UPDATE STUDENT AVATAR] Iniciando actualizaci√≥n de avatar del estudiante');
    console.log('üë§ [UPDATE STUDENT AVATAR] Usuario:', userId);
    console.log('üéì [UPDATE STUDENT AVATAR] Estudiante:', studentId);
    console.log('üìÅ [UPDATE STUDENT AVATAR] Archivo recibido:', req.file);

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se proporcion√≥ ninguna imagen'
      });
    }

    // Verificar que el usuario es familyadmin y tiene acceso al estudiante
    const userAssociation = await Shared.findOne({
      user: userId,
      student: studentId,
      status: 'active'
    }).populate('role');

    if (!userAssociation) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para actualizar este estudiante'
      });
    }

    if (userAssociation.role?.nombre !== 'familyadmin') {
      return res.status(403).json({
        success: false,
        message: 'Solo los familyadmin pueden actualizar avatares de estudiantes'
      });
    }

    // Buscar el estudiante
    const Student = require('./shared/models/Student');
    const student = await Student.findById(studentId);
    
    if (!student) {
      return res.status(404).json({
        success: false,
        message: 'Estudiante no encontrado'
      });
    }

    // El archivo se subi√≥ directamente a S3 usando multer-s3
    console.log('üñºÔ∏è [UPDATE STUDENT AVATAR] Archivo subido a S3 usando multer-s3');
    console.log('üñºÔ∏è [UPDATE STUDENT AVATAR] Archivo info:', {
      location: req.file.location,
      key: req.file.key,
      bucket: req.file.bucket
    });
    
    // Nota: Para estudiantes usamos multer-s3 directamente, pero podr√≠amos procesar antes de subir
    // Por ahora mantenemos la funcionalidad actual
    const avatarKey = req.file.key;
    console.log('üñºÔ∏è [UPDATE STUDENT AVATAR] Key de S3 guardada:', avatarKey);

    // Actualizar el estudiante con la nueva imagen
    const updatedStudent = await Student.findByIdAndUpdate(
      studentId,
      { 
        avatar: avatarKey, // Guardar la key de S3 (no la URL completa)
        updatedAt: new Date()
      },
      { new: true }
    );

    if (!updatedStudent) {
      return res.status(404).json({
        success: false,
        message: 'Estudiante no encontrado'
      });
    }

    console.log('‚úÖ [UPDATE STUDENT AVATAR] Avatar del estudiante actualizado exitosamente');

    // Generar URL firmada para la respuesta
    const { generateSignedUrl } = require('./config/s3.config');
    const signedUrl = await generateSignedUrl(avatarKey, 172800); // 2 d√≠as
    
    console.log('üñºÔ∏è [UPDATE STUDENT AVATAR] URL firmada generada:', signedUrl);

    res.json({
      success: true,
      message: 'Avatar del estudiante actualizado exitosamente',
      data: {
        student: {
          _id: updatedStudent._id,
          nombre: updatedStudent.nombre,
          apellido: updatedStudent.apellido,
          avatar: signedUrl // Devolver la URL firmada
        }
      }
    });

  } catch (error) {
    console.error('Error actualizando avatar del estudiante:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Endpoint de prueba para verificar configuraci√≥n de S3 para avatares de estudiantes
app.get('/test-student-avatar-s3', async (req, res) => {
  try {
    console.log('üß™ [TEST STUDENT AVATAR S3] Probando configuraci√≥n...');
    
    // Verificar configuraci√≥n
    const config = {
      accessKeyId: process.env.AWS_ACCESS_KEY_ID ? 'Configurado' : 'No configurado',
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY ? 'Configurado' : 'No configurado',
      region: process.env.AWS_REGION || 'us-east-1',
      bucketName: process.env.AWS_S3_BUCKET_NAME || 'No configurado'
    };
    
    console.log('üß™ [TEST STUDENT AVATAR S3] Configuraci√≥n:', config);
    
    // Intentar generar una URL firmada de prueba para estudiantes
    const testKey = 'students/test/avatar-test.jpg';
    const { s3 } = require('./config/s3.config');
    
    // Verificar que el bucket existe
    try {
      await s3.headBucket({ Bucket: process.env.AWS_S3_BUCKET_NAME }).promise();
      console.log('‚úÖ [TEST STUDENT AVATAR S3] Bucket existe y es accesible');
    } catch (bucketError) {
      console.error('‚ùå [TEST STUDENT AVATAR S3] Error accediendo al bucket:', bucketError);
    }
    
    res.json({
      success: true,
      message: 'Configuraci√≥n de S3 para avatares de estudiantes verificada',
      data: {
        config,
        testKey
      }
    });
  } catch (error) {
    console.error('‚ùå [TEST STUDENT AVATAR S3] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error en configuraci√≥n de S3 para avatares de estudiantes',
      error: error.message
    });
  }
});

// ===== RUTAS DE USUARIOS =====

// Endpoint de prueba para S3
app.get('/test-s3', async (req, res) => {
  try {
    console.log('üß™ [TEST S3] Probando configuraci√≥n de S3...');
    console.log('üß™ [TEST S3] Configuraci√≥n:', {
      accessKeyId: process.env.AWS_ACCESS_KEY_ID ? 'Configurado' : 'No configurado',
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY ? 'Configurado' : 'No configurado',
      region: process.env.AWS_REGION || 'us-east-1',
      bucketName: process.env.AWS_S3_BUCKET_NAME || 'No configurado'
    });
    
    // Intentar generar una URL firmada de prueba
    const testKey = 'test/avatar-test.jpg';
    const testUrl = generateSignedUrl(testKey, 3600);
    
    res.json({
      success: true,
      message: 'Configuraci√≥n de S3 verificada',
      data: {
        config: {
          accessKeyId: !!process.env.AWS_ACCESS_KEY_ID,
          secretAccessKey: !!process.env.AWS_SECRET_ACCESS_KEY,
          region: process.env.AWS_REGION || 'us-east-1',
          bucketName: process.env.AWS_S3_BUCKET_NAME || null
        },
        testUrl: testUrl,
        testKey: testKey
      }
    });
  } catch (error) {
    console.error('‚ùå [TEST S3] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error en configuraci√≥n de S3',
      error: error.message
    });
  }
});

// Aprobar asociaci√≥n pendiente
app.put('/users/approve-association/:associationId', authenticateToken, async (req, res) => {
  try {
    const { associationId } = req.params;
    const currentUser = req.user;

    // Verificar que el usuario actual es adminaccount o superadmin
    if (!['adminaccount', 'superadmin'].includes(currentUser.role?.nombre)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para aprobar asociaciones'
      });
    }

    // Buscar la asociaci√≥n
    const association = await Shared.findById(associationId)
      .populate('user', 'name email')
      .populate('account', 'nombre razonSocial')
      .populate('role', 'nombre');

    if (!association) {
      return res.status(404).json({
        success: false,
        message: 'Asociaci√≥n no encontrada'
      });
    }

    // Verificar que la asociaci√≥n est√© pendiente
    if (association.status !== 'pending') {
      return res.status(400).json({
        success: false,
        message: 'La asociaci√≥n ya no est√° pendiente de aprobaci√≥n'
      });
    }

    // Verificar permisos: adminaccount solo puede aprobar asociaciones de su cuenta
    if (currentUser.role?.nombre === 'adminaccount') {
      console.log('üîç Verificando permisos para aprobar asociaci√≥n...');
      console.log('üë§ Usuario ID:', currentUser._id);
      console.log('üè¢ Cuenta de la asociaci√≥n:', association.account._id);
      
      const userAssociations = await Shared.find({ 
        user: currentUser._id, 
        status: { $in: ['active', 'pending'] }
      });
      
      console.log('üìã Asociaciones del usuario encontradas:', userAssociations.length);
      
      const userAccountIds = userAssociations.map(a => a.account.toString());
      console.log('üè¢ IDs de cuentas del usuario:', userAccountIds);
      
      if (!userAccountIds.includes(association.account._id.toString())) {
        console.log('‚ùå Permiso denegado: La cuenta no pertenece al usuario');
        return res.status(403).json({
          success: false,
          message: 'Solo puedes aprobar asociaciones de tu cuenta'
        });
      }
      
      console.log('‚úÖ Permiso concedido: La cuenta pertenece al usuario');
    }

    // Aprobar la asociaci√≥n
    association.status = 'active';
    await association.save();

    console.log(`‚úÖ Asociaci√≥n aprobada: ${association.user.name} en ${association.account.nombre}`);

    res.json({
      success: true,
      message: 'Asociaci√≥n aprobada exitosamente',
      data: {
        _id: association._id,
        user: {
          _id: association.user._id,
          name: association.user.name,
          email: association.user.email
        },
        account: {
          _id: association.account._id,
          nombre: association.account.nombre,
          razonSocial: association.account.razonSocial
        },
        role: {
          _id: association.role._id,
          nombre: association.role.nombre
        },
        status: association.status,
        updatedAt: association.updatedAt
      }
    });

  } catch (error) {
    console.error('Error aprobando asociaci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Rechazar asociaci√≥n pendiente
app.put('/users/reject-association/:associationId', authenticateToken, async (req, res) => {
  try {
    const { associationId } = req.params;
    const currentUser = req.user;

    // Verificar que el usuario actual es adminaccount o superadmin
    if (!['adminaccount', 'superadmin'].includes(currentUser.role?.nombre)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para rechazar asociaciones'
      });
    }

    // Buscar la asociaci√≥n
    const association = await Shared.findById(associationId)
      .populate('user', 'name email')
      .populate('account', 'nombre razonSocial')
      .populate('role', 'nombre');

    if (!association) {
      return res.status(404).json({
        success: false,
        message: 'Asociaci√≥n no encontrada'
      });
    }

    // Verificar que la asociaci√≥n est√© pendiente
    if (association.status !== 'pending') {
      return res.status(400).json({
        success: false,
        message: 'La asociaci√≥n ya no est√° pendiente de aprobaci√≥n'
      });
    }

    // Verificar permisos: adminaccount solo puede rechazar asociaciones de su cuenta
    if (currentUser.role?.nombre === 'adminaccount') {
      console.log('üîç Verificando permisos para rechazar asociaci√≥n...');
      console.log('üë§ Usuario ID:', currentUser._id);
      console.log('üè¢ Cuenta de la asociaci√≥n:', association.account._id);
      
      const userAssociations = await Shared.find({ 
        user: currentUser._id, 
        status: { $in: ['active', 'pending'] }
      });
      
      console.log('üìã Asociaciones del usuario encontradas:', userAssociations.length);
      
      const userAccountIds = userAssociations.map(a => a.account.toString());
      console.log('üè¢ IDs de cuentas del usuario:', userAccountIds);
      
      if (!userAccountIds.includes(association.account._id.toString())) {
        console.log('‚ùå Permiso denegado: La cuenta no pertenece al usuario');
        return res.status(403).json({
          success: false,
          message: 'Solo puedes rechazar asociaciones de tu cuenta'
        });
      }
      
      console.log('‚úÖ Permiso concedido: La cuenta pertenece al usuario');
    }

    // Rechazar la asociaci√≥n (cambiar a inactive)
    association.status = 'inactive';
    await association.save();

    console.log(`‚ùå Asociaci√≥n rechazada: ${association.user.name} en ${association.account.nombre}`);

    res.json({
      success: true,
      message: 'Asociaci√≥n rechazada exitosamente',
      data: {
        _id: association._id,
        user: {
          _id: association.user._id,
          name: association.user.name,
          email: association.user.email
        },
        account: {
          _id: association.account._id,
          nombre: association.account.nombre,
          razonSocial: association.account.razonSocial
        },
        role: {
          _id: association.role._id,
          nombre: association.role.nombre
        },
        status: association.status,
        updatedAt: association.updatedAt
      }
    });

  } catch (error) {
    console.error('Error rechazando asociaci√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Obtener asociaciones pendientes
app.get('/users/pending-associations', authenticateToken, getCognitoUserInstitution, async (req, res) => {
  try {
    const currentUser = req.user;

    // Verificar que el usuario actual es adminaccount o superadmin
    if (!['adminaccount', 'superadmin'].includes(currentUser.role?.nombre)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver asociaciones pendientes'
      });
    }

    let query = { status: 'pending' };

    // Si es adminaccount, solo mostrar asociaciones de su cuenta
    if (currentUser.role?.nombre === 'adminaccount') {
      console.log('üîç Adminaccount buscando asociaciones pendientes...');
      console.log('üë§ Usuario ID:', currentUser._id);
      
      // Usar el middleware global para obtener la instituci√≥n
      if (req.userInstitution) {
        console.log('üè¢ Instituci√≥n del usuario:', req.userInstitution.nombre, req.userInstitution._id);
        
        // Filtrar asociaciones pendientes de esta cuenta
        query.account = req.userInstitution._id;
        console.log('üë• Filtrando asociaciones pendientes de la cuenta:', req.userInstitution._id);
      } else {
        console.log('‚ö†Ô∏è Usuario sin instituci√≥n asignada');
        query.account = null; // No mostrar asociaciones
      }
      
      console.log('üîç Query final para asociaciones pendientes:', JSON.stringify(query, null, 2));
    }

    const pendingAssociations = await Shared.find(query)
      .populate('user', 'name email')
      .populate('account', 'nombre razonSocial')
      .populate('role', 'nombre')
      .populate('division', 'nombre descripcion')
      .sort({ createdAt: -1 });

    res.json({
      success: true,
      data: pendingAssociations.map(association => ({
        _id: association._id,
        user: {
          _id: association.user._id,
          name: association.user.name,
          email: association.user.email
        },
        account: {
          _id: association.account._id,
          nombre: association.account.nombre,
          razonSocial: association.account.razonSocial
        },
        role: {
          _id: association.role._id,
          nombre: association.role.nombre
        },
        division: association.division ? {
          _id: association.division._id,
          nombre: association.division.nombre,
          descripcion: association.division.descripcion
        } : null,
        status: association.status,
        createdAt: association.createdAt,
        updatedAt: association.updatedAt
      }))
    });

  } catch (error) {
    console.error('Error obteniendo asociaciones pendientes:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Registro desde app mobile (solo familyview)
app.post('/users/register-mobile', async (req, res) => {
  try {
    console.log('üéØ [REGISTER MOBILE] Iniciando registro desde app m√≥vil');
    console.log('üì¶ [REGISTER MOBILE] Body recibido:', JSON.stringify(req.body, null, 2));
    console.log('üîç [REGISTER MOBILE] Campos disponibles:', Object.keys(req.body));
    
    const { 
      email, 
      password, 
      nombre, 
      apellido,
      telefono
    } = req.body;

    // Validaciones b√°sicas
    console.log('üîç [REGISTER MOBILE] Validando campos requeridos...');
    console.log('üìã [REGISTER MOBILE] Campos:', {
      email: !!email,
      password: !!password,
      nombre: !!nombre,
      apellido: !!apellido,
      telefono: !!telefono
    });
    console.log('üìã [REGISTER MOBILE] Campos requeridos:', {
      email: !!email,
      password: !!password,
      nombre: !!nombre
    });
    
    if (!email || !password || !nombre) {
      const missingFields = [];
      if (!email) missingFields.push('email');
      if (!password) missingFields.push('password');
      if (!nombre) missingFields.push('nombre');
      
      console.log('‚ùå [REGISTER MOBILE] Campos faltantes:', missingFields);
      
      return res.status(400).json({
        success: false,
        message: `Campos requeridos faltantes: ${missingFields.join(', ')}`
      });
    }

    // Buscar solicitudes pendientes para este email
    console.log('üîç [REGISTER MOBILE] Buscando solicitudes pendientes para:', email);
    const pendingRequests = await RequestedShared.findPendingByEmail(email);
    console.log('üìã [REGISTER MOBILE] Solicitudes pendientes encontradas:', pendingRequests.length);

    // Buscar usuario existente por email
    let user = await User.findOne({ email });
    
    if (user) {
      console.log('üë§ Usuario existente encontrado:', user.email);
      return res.status(400).json({
        success: false,
        message: 'El usuario ya existe en el sistema'
      });
    }

    console.log('üÜï Creando nuevo usuario familyviewer:', email);
    
    // Obtener el rol familyviewer
    const role = await Role.findOne({ nombre: 'familyviewer' });
    
    if (!role) {
      console.log('‚ùå [REGISTER MOBILE] Rol familyviewer no encontrado');
      return res.status(500).json({
        success: false,
        message: 'Rol familyviewer no encontrado en el sistema'
      });
    }

    // Crear nuevo usuario
    const fullName = apellido ? `${nombre} ${apellido}` : nombre;
    user = new User({
      name: fullName,
      email: email,
      password: password,
      role: role._id,
      status: 'approved',
      telefono: telefono || null
    });

    await user.save();
    console.log('‚úÖ Usuario familyviewer creado exitosamente');



    // Procesar solicitudes pendientes si existen
    if (pendingRequests.length > 0) {
      console.log('üîç [REGISTER] Procesando solicitudes pendientes:', pendingRequests.length);
      
      for (const request of pendingRequests) {
        try {
          // Crear la asociaci√≥n solicitada
          const requestedShared = new Shared({
            user: user._id,
            account: request.account._id,
            division: request.division?._id,
            student: request.student?._id,
            role: request.role._id,
            status: 'active',
            createdBy: request.requestedBy
          });
          
          await requestedShared.save();
          
          // Verificar si el usuario ya tiene una asociaci√≥n activa
          const existingActiveAssociation = await ActiveAssociation.getActiveAssociation(user._id);
          
          if (!existingActiveAssociation) {
            // Si no tiene asociaci√≥n activa, establecer esta como activa autom√°ticamente
            try {
              await ActiveAssociation.setActiveAssociation(user._id, requestedShared._id);
              console.log(`üéØ [AUTO-ACTIVE] Asociaci√≥n autom√°ticamente establecida como activa para usuario ${user._id}`);
            } catch (error) {
              console.error('‚ùå [AUTO-ACTIVE] Error estableciendo asociaci√≥n activa autom√°ticamente:', error);
            }
          } else {
            console.log(`‚ÑπÔ∏è [AUTO-ACTIVE] Usuario ${user._id} ya tiene una asociaci√≥n activa, no se cambia autom√°ticamente`);
          }
          
          // Marcar la solicitud como completada
          await RequestedShared.markAsCompleted(request._id, user._id);
          
          console.log('‚úÖ [REGISTER] Asociaci√≥n solicitada creada para:', request.account.nombre);
        } catch (error) {
          console.error('‚ùå [REGISTER] Error al procesar solicitud pendiente:', error);
        }
      }
    }

    // Generar URL firmada para el avatar si existe
    let avatarUrl = null;
    if (user.avatar) {
      try {
        avatarUrl = await generateSignedUrl(user.avatar, 172800); // 2 d√≠as
      } catch (error) {
        console.error('Error generando URL firmada para avatar:', error);
        // Si falla la URL firmada, usar la URL directa
        avatarUrl = user.avatar;
      }
    }

    res.status(201).json({
      success: true,
      message: pendingRequests.length > 0 
        ? 'Usuario registrado exitosamente y asociaciones creadas'
        : 'Usuario registrado exitosamente. No hay asociaciones pendientes.',
      data: {
        user: {
          _id: user._id,
          name: user.name,
          email: user.email,
          role: user.role,
          avatar: avatarUrl,
          status: user.status
        },
        associationsCreated: pendingRequests.length
      }
    });

  } catch (error) {
    console.error('Error en registro mobile:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Listar usuarios
app.get('/users', authenticateToken, getCognitoUserInstitution, async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const search = req.query.search || '';

    // Construir query de b√∫squeda
    const query = {};
    if (search) {
      query.$or = [
        { name: { $regex: search, $options: 'i' } },
        { email: { $regex: search, $options: 'i' } }
      ];
    }

    // Filtrar seg√∫n el rol del usuario
    const currentUser = req.user;
    console.log('üîç Usuario actual:', currentUser.email, 'Rol:', currentUser.role?.nombre);

    // Si el usuario es superadmin, puede ver todos los usuarios
    if (currentUser.role?.nombre === 'superadmin') {
      console.log('üëë Superadmin: mostrando todos los usuarios');
    } 
    // Si el usuario es adminaccount, solo puede ver usuarios de su cuenta
    else if (currentUser.role?.nombre === 'adminaccount') {
      console.log('üè¢ Adminaccount: filtrando usuarios por cuenta');
      console.log('üë§ Usuario actual ID:', currentUser._id);
      
      // Usar el middleware global para obtener la instituci√≥n
      if (req.userInstitution) {
        console.log('üè¢ Instituci√≥n del usuario:', req.userInstitution.nombre, req.userInstitution._id);
        
        // Filtrar usuarios que pertenecen a esta cuenta
        query.account = req.userInstitution._id;
        console.log('üë• Filtrando usuarios de la cuenta:', req.userInstitution._id);
      } else {
        console.log('‚ö†Ô∏è Usuario sin instituci√≥n asignada');
        query._id = null; // No mostrar usuarios
      }
    }
    // Para otros roles, no mostrar usuarios
    else {
      console.log('üö´ Rol no autorizado:', currentUser.role?.nombre);
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver usuarios'
      });
    }

    // Obtener datos reales de la base de datos
    const total = await User.countDocuments(query);
    const users = await User.find(query)
      .populate('role')
      .skip((page - 1) * limit)
      .limit(limit)
      .sort({ createdAt: -1 });

    res.json({
      success: true,
      data: {
        users: users.map(user => ({
          _id: user._id,
          email: user.email,
          nombre: user.name,
          role: user.role,
          activo: user.status === 'approved',
          createdAt: user.createdAt,
          updatedAt: user.updatedAt
        })),
        total,
        page,
        limit
      }
    });
  } catch (error) {
    console.error('Error listando usuarios:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// ===== RUTAS DE GRUPOS (DIVISIONES) =====

// Listar grupos con filtros por cuenta
app.get('/grupos', authenticateToken, getCognitoUserInstitution, async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const search = req.query.search || '';
    const cuentaId = req.query.cuentaId;

    // Construir query de b√∫squeda
    const query = {};
    
    // Filtro por cuenta seg√∫n el rol del usuario
    if (req.user.role.nombre === 'superadmin') {
      // Superadmin puede ver todos los grupos
      if (cuentaId) {
        query.cuenta = cuentaId;
      }
    } else if (req.user.role.nombre === 'adminaccount') {
      // Adminaccount solo puede ver grupos de sus cuentas
      console.log('üîç Adminaccount buscando grupos...');
      console.log('üë§ Usuario ID:', req.user._id);
      
      // Usar el middleware global para obtener la instituci√≥n
      if (req.userInstitution) {
        console.log('üè¢ Instituci√≥n del usuario:', req.userInstitution.nombre, req.userInstitution._id);
        
        // Filtrar grupos que pertenecen a esta cuenta
        query.cuenta = req.userInstitution._id;
        console.log('üë• Filtrando grupos de la cuenta:', req.userInstitution._id);
      } else {
        console.log('‚ö†Ô∏è Usuario sin instituci√≥n asignada');
        query.cuenta = null; // No mostrar grupos
      }
      
      console.log('üîç Query final:', JSON.stringify(query, null, 2));
      
      if (cuentaId) {
        // Verificar que la cuenta solicitada pertenece al usuario
        if (!verifyAccountAccess(req, cuentaId)) {
          return res.status(403).json({
            success: false,
            message: 'No tienes permisos para ver grupos de esta cuenta'
          });
        }
        query.cuenta = cuentaId;
      }
    } else {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver grupos'
      });
    }

    // B√∫squeda por nombre
    if (search) {
      query.nombre = { $regex: search, $options: 'i' };
    }

    // Obtener datos reales de la base de datos
    console.log('üîç Ejecutando query en Grupo...');
    console.log('üìä Query:', JSON.stringify(query, null, 2));
    
    const total = await Grupo.countDocuments(query);
    console.log('üìä Total grupos encontrados:', total);
    
    const grupos = await Grupo.find(query)
      .populate('cuenta', 'nombre razonSocial')
      .populate('creadoPor', 'name email')
      .skip((page - 1) * limit)
      .limit(limit)
      .sort({ createdAt: -1 });

    res.json({
      success: true,
      data: {
        grupos: grupos.map(grupo => ({
          _id: grupo._id,
          nombre: grupo.nombre,
          descripcion: grupo.descripcion,
          cuenta: grupo.cuenta,
          activo: grupo.activo,
          creadoPor: grupo.creadoPor,
          createdAt: grupo.createdAt,
          updatedAt: grupo.updatedAt
        })),
        total,
        page,
        limit
      }
    });
  } catch (error) {
    console.error('Error listando grupos:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Crear nuevo grupo
app.post('/grupos', authenticateToken, async (req, res) => {
  try {
    const { nombre, descripcion, cuentaId } = req.body;

    // Validaciones b√°sicas
    if (!nombre) {
      return res.status(400).json({
        success: false,
        message: 'Nombre es requerido'
      });
    }

    let targetCuentaId = cuentaId;

    // Verificar permisos seg√∫n rol
    if (req.user.role.nombre === 'superadmin') {
      // Superadmin puede crear grupos en cualquier cuenta
      if (!cuentaId) {
        return res.status(400).json({
          success: false,
          message: 'Cuenta es requerida para superadmin'
        });
      }
    } else if (req.user.role.nombre === 'adminaccount') {
      // Adminaccount solo puede crear grupos en su cuenta asociada
      const userAccount = await Shared.findOne({
        user: req.user._id,
        status: { $in: ['active', 'pending'] }
      }).populate('account');

      if (!userAccount) {
        return res.status(403).json({
          success: false,
          message: 'No tienes una cuenta asociada'
        });
      }

      // Si se especifica una cuentaId, debe ser la misma que la del admin
      if (cuentaId && cuentaId !== userAccount.account._id.toString()) {
        return res.status(403).json({
          success: false,
          message: 'Solo puedes crear grupos en tu cuenta asociada'
        });
      }

      // Usar autom√°ticamente la cuenta del admin
      targetCuentaId = userAccount.account._id;
    } else {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para crear grupos'
      });
    }

    // Verificar que la cuenta existe
    const cuenta = await Account.findById(targetCuentaId);
    if (!cuenta) {
      return res.status(400).json({
        success: false,
        message: 'La cuenta especificada no existe'
      });
    }

    // Crear el grupo
    const grupo = new Grupo({
      nombre,
      descripcion: descripcion || '',
      cuenta: targetCuentaId,
      activo: true,
      creadoPor: req.user._id
    });

    await grupo.save();

    // Populate para la respuesta
    await grupo.populate('cuenta', 'nombre razonSocial');
    await grupo.populate('creadoPor', 'name email');

    res.status(201).json({
      success: true,
      message: 'Grupo creado exitosamente',
      data: {
        grupo: {
          _id: grupo._id,
          nombre: grupo.nombre,
          descripcion: grupo.descripcion,
          cuenta: grupo.cuenta,
          activo: grupo.activo,
          creadoPor: grupo.creadoPor,
          createdAt: grupo.createdAt
        }
      }
    });

  } catch (error) {
    console.error('Error creando grupo:', error);
    console.error('Error details:', error.message);
    console.error('Error stack:', error.stack);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor',
      error: error.message
    });
  }
});

// Obtener divisiones por cuenta para registro mobile
app.get('/grupos/mobile/:cuentaId', async (req, res) => {
  try {
    const { cuentaId } = req.params;

    // Verificar que la cuenta existe y est√° activa
    const cuenta = await Account.findById(cuentaId);
    if (!cuenta || cuenta.activo === false) {
      return res.status(404).json({
        success: false,
        message: 'Cuenta no encontrada o inactiva'
      });
    }

    // Obtener divisiones activas de la cuenta
    const grupos = await Grupo.find({ 
      cuenta: cuentaId, 
      activo: true 
    })
    .select('nombre descripcion _id')
    .sort({ nombre: 1 });

    res.json({
      success: true,
      data: {
        grupos: grupos,
        total: grupos.length,
        cuenta: {
          _id: cuenta._id,
          nombre: cuenta.nombre,
          razonSocial: cuenta.razonSocial
        }
      }
    });
  } catch (error) {
    console.error('Error obteniendo divisiones para mobile:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Obtener grupo por ID
app.get('/grupos/:id', authenticateToken, async (req, res) => {
  try {
    const grupo = await Grupo.findById(req.params.id)
      .populate('cuenta', 'nombre razonSocial')
      .populate('creadoPor', 'name email');

    if (!grupo) {
      return res.status(404).json({
        success: false,
        message: 'Grupo no encontrado'
      });
    }

    // Verificar permisos
    if (req.user.role.nombre === 'superadmin') {
      // Superadmin puede ver cualquier grupo
    } else if (req.user.role.nombre === 'adminaccount') {
      // Adminaccount solo puede ver grupos de sus cuentas
      const userAccount = await Shared.findOne({
        user: req.user._id,
        account: grupo.cuenta._id,
        status: 'active'
      });

      if (!userAccount) {
        return res.status(403).json({
          success: false,
          message: 'No tienes permisos para ver este grupo'
        });
      }
    } else {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver grupos'
      });
    }

    res.json({
      success: true,
      data: {
        grupo: {
          _id: grupo._id,
          nombre: grupo.nombre,
          descripcion: grupo.descripcion,
          cuenta: grupo.cuenta,
          activo: grupo.activo,
          creadoPor: grupo.creadoPor,
          createdAt: grupo.createdAt,
          updatedAt: grupo.updatedAt
        }
      }
    });

  } catch (error) {
    console.error('Error obteniendo grupo:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Actualizar grupo
app.put('/grupos/:id', authenticateToken, async (req, res) => {
  try {
    const { nombre, descripcion, activo } = req.body;

    const grupo = await Grupo.findById(req.params.id)
      .populate('cuenta', 'nombre razonSocial');

    if (!grupo) {
      return res.status(404).json({
        success: false,
        message: 'Grupo no encontrado'
      });
    }

    // Verificar permisos
    if (req.user.role.nombre === 'superadmin') {
      // Superadmin puede editar cualquier grupo
    } else if (req.user.role.nombre === 'adminaccount') {
      // Adminaccount solo puede editar grupos de sus cuentas
      const userAccount = await Shared.findOne({
        user: req.user._id,
        account: grupo.cuenta._id,
        status: 'active'
      });

      if (!userAccount) {
        return res.status(403).json({
          success: false,
          message: 'No tienes permisos para editar este grupo'
        });
      }
    } else {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para editar grupos'
      });
    }

    // Actualizar campos
    if (nombre !== undefined) grupo.nombre = nombre;
    if (descripcion !== undefined) grupo.descripcion = descripcion;
    if (activo !== undefined) grupo.activo = activo;

    await grupo.save();

    // Populate para la respuesta
    await grupo.populate('creadoPor', 'name email');

    res.json({
      success: true,
      message: 'Grupo actualizado exitosamente',
      data: {
        grupo: {
          _id: grupo._id,
          nombre: grupo.nombre,
          descripcion: grupo.descripcion,
          cuenta: grupo.cuenta,
          activo: grupo.activo,
          creadoPor: grupo.creadoPor,
          createdAt: grupo.createdAt,
          updatedAt: grupo.updatedAt
        }
      }
    });

  } catch (error) {
    console.error('Error actualizando grupo:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Eliminar grupo
app.delete('/grupos/:id', authenticateToken, async (req, res) => {
  try {
    const grupo = await Grupo.findById(req.params.id)
      .populate('cuenta', 'nombre razonSocial');

    if (!grupo) {
      return res.status(404).json({
        success: false,
        message: 'Grupo no encontrado'
      });
    }

    // Verificar permisos
    if (req.user.role.nombre === 'superadmin') {
      // Superadmin puede eliminar cualquier grupo
    } else if (req.user.role.nombre === 'adminaccount') {
      // Adminaccount solo puede eliminar grupos de sus cuentas
      
      // Para usuarios de Cognito, verificar contra la cuenta directa
      if (req.user.isCognitoUser) {
        console.log('üîç Usuario de Cognito, verificando cuenta directa');
        
        // Buscar el usuario completo en MongoDB para obtener su cuenta
        const dbUser = await User.findOne({ email: req.user.email })
          .populate('account', 'nombre razonSocial');
        
        if (!dbUser || !dbUser.account || dbUser.account._id.toString() !== grupo.cuenta._id.toString()) {
          return res.status(403).json({
            success: false,
            message: 'No tienes permisos para eliminar este grupo'
          });
        }
      } else {
        // Para usuarios legacy, verificar contra las asociaciones
        const userAccount = await Shared.findOne({
          user: req.user._id,
          account: grupo.cuenta._id,
          status: 'active'
        });

        if (!userAccount) {
          return res.status(403).json({
            success: false,
            message: 'No tienes permisos para eliminar este grupo'
          });
        }
      }
    } else {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para eliminar grupos'
      });
    }

    await Grupo.findByIdAndDelete(req.params.id);

    res.json({
      success: true,
      message: 'Grupo eliminado exitosamente'
    });

  } catch (error) {
    console.error('Error eliminando grupo:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// ===== RUTAS DE CUENTAS =====

// Obtener cuentas para registro mobile (solo cuentas activas)
app.get('/accounts/mobile', async (req, res) => {
  try {
    const accounts = await Account.find({ activo: { $ne: false } })
      .select('nombre razonSocial _id')
      .sort({ nombre: 1 });

    res.json({
      success: true,
      data: {
        accounts: accounts,
        total: accounts.length
      }
    });
  } catch (error) {
    console.error('Error obteniendo cuentas para mobile:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});



// Listar cuentas
app.get('/accounts', authenticateToken, getCognitoUserInstitution, async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const search = req.query.search || '';

    // Construir query de b√∫squeda
    const query = {};
    if (search) {
      query.$or = [
        { nombre: { $regex: search, $options: 'i' } },
        { razonSocial: { $regex: search, $options: 'i' } }
      ];
    }

    // Filtrar seg√∫n el rol del usuario
    const currentUser = req.user;
    console.log('üîç Usuario actual:', currentUser.email, 'Rol:', currentUser.role?.nombre);

    // Verificar permisos seg√∫n el rol
    if (currentUser.role?.nombre === 'superadmin') {
      console.log('üëë Superadmin: mostrando todas las cuentas');
    } else if (currentUser.role?.nombre === 'adminaccount') {
      console.log('üë§ Adminaccount: mostrando solo sus cuentas');
      
      // Usar el middleware global para obtener la instituci√≥n
      if (req.userInstitution) {
        console.log('üè¢ Instituci√≥n del usuario:', req.userInstitution.nombre, req.userInstitution._id);
        
        // Filtrar por la cuenta del usuario
        query._id = req.userInstitution._id;
        console.log('üë• Filtrando cuenta del usuario:', req.userInstitution._id);
      } else {
        console.log('‚ö†Ô∏è Usuario sin instituci√≥n asignada');
        // return res.status(200).json({
          success: true,
          data: {
            accounts: [],
            total: 0,
            page,
            limit
          }
        });
      }
    } else {
      console.log('üö´ Usuario no autorizado para ver cuentas:', currentUser.role?.nombre);
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver cuentas'
      });
    }

    // Obtener datos reales de la base de datos
    const total = await Account.countDocuments(query);
    const accounts = await Account.find(query)
      .populate({
        path: 'usuarioAdministrador',
        select: 'name email status',
        populate: {
          path: 'role',
          select: 'nombre descripcion nivel'
        }
      })
      .skip((page - 1) * limit)
      .limit(limit)
      .sort({ createdAt: -1 });

    // Generar URLs firmadas para los logos
    const accountsWithSignedUrls = accounts.map(account => {
      const accountObj = account.toObject();
      if (accountObj.logo) {
        accountObj.logoSignedUrl = generateSignedUrl(accountObj.logo, 172800); // 2 d√≠as
      }
      return accountObj;
    });

    res.json({
      success: true,
      data: {
        accounts: accountsWithSignedUrls,
        total,
        page,
        limit
      }
    });
  } catch (error) {
    console.error('Error listando cuentas:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Crear cuenta
app.post('/accounts', authenticateToken, async (req, res) => {
  try {
    const { nombre, razonSocial, address, emailAdmin, nombreAdmin, logo } = req.body;

    if (!nombre || !razonSocial || !address || !emailAdmin || !nombreAdmin) {
      return res.status(400).json({
        success: false,
        message: 'Todos los campos son requeridos'
      });
    }

    // Verificar si ya existe una cuenta con el mismo nombre
    const existingAccount = await Account.findOne({ nombre });
    if (existingAccount) {
      return res.status(400).json({
        success: false,
        message: 'Ya existe una cuenta con ese nombre'
      });
    }

    // Verificar si ya existe un usuario con el email del administrador
    const existingUser = await User.findOne({ email: emailAdmin });
    if (existingUser) {
      return res.status(400).json({
        success: false,
        message: 'Ya existe un usuario con ese email de administrador'
      });
    }

    // Obtener el rol de administrador de cuenta
    const adminRole = await Role.findOne({ nombre: 'adminaccount' });
    if (!adminRole) {
      return res.status(500).json({
        success: false,
        message: 'Rol de administrador no encontrado'
      });
    }

    // Generar contrase√±a aleatoria segura
    const randomPassword = generateRandomPassword(12);
    console.log('üîë [CREATE ACCOUNT] Contrase√±a generada para administrador:', randomPassword);

    // Crear usuario administrador primero
    const adminUser = new User({
      name: nombreAdmin,
      email: emailAdmin,
      password: randomPassword, // Contrase√±a aleatoria segura
      role: adminRole._id,
      status: 'approved'
    });

    await adminUser.save();

    // Crear nueva cuenta con el usuario administrador
    const account = new Account({
      nombre,
      razonSocial,
      address,
      emailAdmin,
      nombreAdmin,
      logo: logo || 'https://via.placeholder.com/150',
      activo: true,
      usuarioAdministrador: adminUser._id
    });

    await account.save();

    // Actualizar el usuario con la cuenta asignada
    adminUser.account = account._id;
    await adminUser.save();

    // Crear asociaci√≥n del admin de la cuenta
    await createAssociationByRole(
      adminUser._id, 
      account._id, 
      'adminaccount', 
      null, 
      null, 
      req.user._id
    );

    // Enviar email de bienvenida con credenciales al administrador (as√≠ncrono)
    sendEmailAsync(sendInstitutionWelcomeEmail, null, adminUser.email, adminUser.name, account.nombre, randomPassword);
    console.log('üìß [CREATE ACCOUNT] Email de bienvenida programado para env√≠o as√≠ncrono al administrador:', adminUser.email);

    // Populate el usuario administrador
    await account.populate('usuarioAdministrador');

    res.status(201).json({
      success: true,
      message: 'Cuenta creada exitosamente con usuario administrador',
      data: {
        account,
        adminUser: {
          _id: adminUser._id,
          name: adminUser.name,
          email: adminUser.email,
          role: adminUser.role,
          status: adminUser.status
        }
      }
    });
  } catch (error) {
    console.error('Error creando cuenta:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Endpoint para crear usuario adminaccount adicional para una cuenta existente (solo superadmin)
app.post('/accounts/:accountId/admin-users', authenticateToken, async (req, res) => {
  try {
    const { accountId } = req.params;
    const { nombre, apellido, email } = req.body;
    const { userId } = req.user;

    console.log('üë§ [CREATE ADMIN USER] Iniciando creaci√≥n de usuario adminaccount...');
    console.log('üë§ [CREATE ADMIN USER] Usuario solicitante ID:', userId);
    console.log('üè´ [CREATE ADMIN USER] Cuenta ID:', accountId);
    console.log('üìã [CREATE ADMIN USER] Datos recibidos:', { nombre, apellido, email });

    // Verificar que el usuario sea superadmin
    const currentUser = await User.findById(userId).populate('role');
    if (!currentUser || currentUser.role?.nombre !== 'superadmin') {
      return res.status(403).json({
        success: false,
        message: 'Solo los superadministradores pueden crear usuarios adminaccount'
      });
    }

    // Validar campos requeridos
    if (!nombre || !apellido || !email) {
      return res.status(400).json({
        success: false,
        message: 'Nombre, apellido y email son requeridos'
      });
    }

    // Verificar que la cuenta existe
    const account = await Account.findById(accountId);
    if (!account) {
      return res.status(404).json({
        success: false,
        message: 'Cuenta no encontrada'
      });
    }

    // Verificar si ya existe un usuario con ese email
    const existingUser = await User.findOne({ email: email.toLowerCase() });
    if (existingUser) {
      return res.status(400).json({
        success: false,
        message: 'Ya existe un usuario con ese email'
      });
    }

    // Obtener el rol de adminaccount
    const adminRole = await Role.findOne({ nombre: 'adminaccount' });
    if (!adminRole) {
      return res.status(500).json({
        success: false,
        message: 'Rol de adminaccount no encontrado'
      });
    }

    // Generar contrase√±a aleatoria segura
    const randomPassword = generateRandomPassword(12);
    console.log('üîë [CREATE ADMIN USER] Contrase√±a generada:', randomPassword);

    // Crear el usuario adminaccount
    const adminUser = new User({
      name: `${nombre} ${apellido}`,
      email: email.toLowerCase(),
      password: randomPassword,
      role: adminRole._id,
      status: 'approved',
      account: accountId
    });

    await adminUser.save();
    console.log('‚úÖ [CREATE ADMIN USER] Usuario adminaccount creado:', adminUser.email);

    // Crear asociaci√≥n del admin con la cuenta
    await createAssociationByRole(
      adminUser._id,
      accountId,
      'adminaccount',
      null,
      null,
      userId
    );
    console.log('‚úÖ [CREATE ADMIN USER] Asociaci√≥n creada');

    // Enviar email de bienvenida (as√≠ncrono)
    sendEmailAsync(
      emailService.sendNewUserCreatedEmail,
      emailService,
      {
        name: adminUser.name,
        email: adminUser.email
      },
      randomPassword,
      account.nombre,
      'Administrador de Instituci√≥n'
    );
    console.log('üìß [CREATE ADMIN USER] Email de bienvenida programado para env√≠o as√≠ncrono a:', adminUser.email);

    // Populate el rol del usuario
    await adminUser.populate('role', 'nombre descripcion');

    const responseData = {
      success: true,
      message: 'Usuario adminaccount creado exitosamente',
      data: {
        user: {
          _id: adminUser._id,
          name: adminUser.name,
          email: adminUser.email,
          role: adminUser.role,
          status: adminUser.status,
          account: accountId
        },
        account: {
          _id: account._id,
          nombre: account.nombre
        }
      }
    };

    console.log('‚úÖ [CREATE ADMIN USER] Respuesta exitosa:', JSON.stringify(responseData, null, 2));
    res.status(201).json(responseData);

  } catch (error) {
    console.error('‚ùå [CREATE ADMIN USER] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Endpoint para obtener estad√≠sticas del dashboard (solo superadmin)
app.get('/dashboard/stats', authenticateToken, async (req, res) => {
  try {
    console.log('üîç [DASHBOARD STATS] Usuario autenticado:', req.user);
    
    // Para usuarios de Cognito, usar la informaci√≥n directamente del req.user
    if (req.user.isCognitoUser) {
      console.log('üîç [DASHBOARD STATS] Usuario de Cognito detectado');
      console.log('üîç [DASHBOARD STATS] Rol del usuario:', req.user.role?.nombre);
      
      if (req.user.role?.nombre !== 'superadmin' && req.user.role?.nombre !== 'adminaccount') {
        return res.status(403).json({
          success: false,
          message: 'Solo los superadministradores y administradores de cuenta pueden ver estad√≠sticas del dashboard'
        });
      }
    } else {
      // Para usuarios de MongoDB (legacy)
      const userId = req.user.userId || req.user._id;
      const currentUser = await User.findById(userId).populate('role');
      if (!currentUser || (currentUser.role?.nombre !== 'superadmin' && currentUser.role?.nombre !== 'adminaccount')) {
        return res.status(403).json({
          success: false,
          message: 'Solo los superadministradores y administradores de cuenta pueden ver estad√≠sticas del dashboard'
        });
      }
    }

    console.log('üìä [DASHBOARD STATS] Obteniendo estad√≠sticas para superadmin...');

    // Obtener estad√≠sticas
    const [
      institucionesActivas,
      usuariosActivos,
      alumnosActivos,
      totalActividades
    ] = await Promise.all([
      // Instituciones activas
      Account.countDocuments({ activo: true }),
      
      // Usuarios activos (todos los usuarios aprobados)
      User.countDocuments({ status: 'approved' }),
      
      // Alumnos activos (usuarios con rol estudiante)
      User.countDocuments({ 
        status: 'approved',
        role: await Role.findOne({ nombre: 'estudiante' }).select('_id')
      }),
      
      // Total de actividades
      Activity.countDocuments({})
    ]);

    const stats = {
      institucionesActivas,
      usuariosActivos,
      alumnosActivos,
      totalActividades
    };

    console.log('üìä [DASHBOARD STATS] Estad√≠sticas obtenidas:', stats);

    res.json({
      success: true,
      data: stats
    });

  } catch (error) {
    console.error('‚ùå [DASHBOARD STATS] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener estad√≠sticas del dashboard'
    });
  }
});

// Endpoint para obtener actividades recientes (solo superadmin)
app.get('/dashboard/recent-activities', authenticateToken, async (req, res) => {
  try {
    console.log('üîç [DASHBOARD ACTIVITIES] Usuario autenticado:', req.user);
    
    // Para usuarios de Cognito, usar la informaci√≥n directamente del req.user
    if (req.user.isCognitoUser) {
      console.log('üîç [DASHBOARD ACTIVITIES] Usuario de Cognito detectado');
      console.log('üîç [DASHBOARD ACTIVITIES] Rol del usuario:', req.user.role?.nombre);
      
      if (req.user.role?.nombre !== 'superadmin' && req.user.role?.nombre !== 'adminaccount') {
        return res.status(403).json({
          success: false,
          message: 'Solo los superadministradores y administradores de cuenta pueden ver actividades recientes'
        });
      }
    } else {
      // Para usuarios de MongoDB (legacy)
      const userId = req.user.userId || req.user._id;
      const currentUser = await User.findById(userId).populate('role');
      if (!currentUser || (currentUser.role?.nombre !== 'superadmin' && currentUser.role?.nombre !== 'adminaccount')) {
        return res.status(403).json({
          success: false,
          message: 'Solo los superadministradores y administradores de cuenta pueden ver actividades recientes'
        });
      }
    }

    console.log('üìã [RECENT ACTIVITIES] Obteniendo √∫ltimas 20 actividades...');

    // Obtener las √∫ltimas 20 actividades con informaci√≥n de instituci√≥n y divisi√≥n
    const activities = await Activity.find({})
      .populate({
        path: 'usuario',
        select: 'name email'
      })
      .populate({
        path: 'account',
        select: 'nombre'
      })
      .populate({
        path: 'division',
        select: 'nombre'
      })
      .sort({ createdAt: -1 })
      .limit(20)
      .select('descripcion account division createdAt');

    const recentActivities = activities.map(activity => ({
      id: activity._id,
      descripcion: activity.descripcion,
      institucion: activity.account?.nombre || 'Sin instituci√≥n',
      division: activity.division?.nombre || 'Sin divisi√≥n',
      fecha: activity.createdAt
    }));

    console.log('üìã [RECENT ACTIVITIES] Actividades obtenidas:', recentActivities.length);

    res.json({
      success: true,
      data: recentActivities
    });

  } catch (error) {
    console.error('‚ùå [RECENT ACTIVITIES] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener actividades recientes'
    });
  }
});

// Obtener cuenta por ID
app.get('/accounts/:id', async (req, res) => {
  try {
    const { id } = req.params;

    const account = await Account.findById(id).populate({
      path: 'usuarioAdministrador',
      select: 'name email status',
      populate: {
        path: 'role',
        select: 'nombre descripcion nivel'
      }
    });
    
    if (!account) {
      return res.status(404).json({
        success: false,
        message: 'Cuenta no encontrada'
      });
    }

    // Generar URL firmada para el logo
    const accountObj = account.toObject();
    if (accountObj.logo) {
      accountObj.logoSignedUrl = generateSignedUrl(accountObj.logo, 3600); // 1 hora
    }

    res.json({
      success: true,
      data: accountObj
    });
  } catch (error) {
    console.error('Error obteniendo cuenta:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Actualizar cuenta
app.put('/accounts/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { nombre, razonSocial, address, emailAdmin, nombreAdmin, logo, activo } = req.body;

    const account = await Account.findById(id);
    
    if (!account) {
      return res.status(404).json({
        success: false,
        message: 'Cuenta no encontrada'
      });
    }

    // Verificar si el nombre ya existe en otra cuenta
    if (nombre && nombre !== account.nombre) {
      const existingAccount = await Account.findOne({ nombre, _id: { $ne: id } });
      if (existingAccount) {
        return res.status(400).json({
          success: false,
          message: 'Ya existe una cuenta con ese nombre'
        });
      }
    }

    // Obtener el usuario administrador actual
    const adminUser = await User.findById(account.usuarioAdministrador);
    if (!adminUser) {
      return res.status(404).json({
        success: false,
        message: 'Usuario administrador no encontrado'
      });
    }

    // Actualizar campos de la cuenta
    if (nombre) account.nombre = nombre;
    if (razonSocial) account.razonSocial = razonSocial;
    if (address) account.address = address;
    if (logo) account.logo = logo;
    if (typeof activo === 'boolean') account.activo = activo;

    // Actualizar campos del usuario administrador
    if (emailAdmin && emailAdmin !== adminUser.email) {
      // Verificar que el nuevo email no est√© en uso
      const existingUser = await User.findOne({ email: emailAdmin, _id: { $ne: adminUser._id } });
      if (existingUser) {
        return res.status(400).json({
          success: false,
          message: 'Ya existe un usuario con ese email'
        });
      }
      adminUser.email = emailAdmin;
    }

    if (nombreAdmin && nombreAdmin !== adminUser.name) {
      adminUser.name = nombreAdmin;
    }

    // Guardar cambios
    account.updatedAt = new Date();
    await account.save();
    await adminUser.save();

    // Populate el usuario administrador
    await account.populate({
      path: 'usuarioAdministrador',
      select: 'name email status',
      populate: {
        path: 'role',
        select: 'nombre descripcion nivel'
      }
    });

    // Generar URL firmada para el logo
    const accountObj = account.toObject();
    if (accountObj.logo) {
      accountObj.logoSignedUrl = generateSignedUrl(accountObj.logo, 3600); // 1 hora
    }

    res.json({
      success: true,
      message: 'Cuenta actualizada exitosamente',
      data: accountObj
    });
  } catch (error) {
    console.error('Error actualizando cuenta:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Eliminar cuenta
app.delete('/accounts/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    const account = await Account.findById(id);
    
    if (!account) {
      return res.status(404).json({
        success: false,
        message: 'Cuenta no encontrada'
      });
    }

    await Account.findByIdAndDelete(id);

    res.json({
      success: true,
      message: 'Cuenta eliminada exitosamente'
    });
  } catch (error) {
    console.error('Error eliminando cuenta:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Estad√≠sticas de cuentas
app.get('/accounts/stats', async (req, res) => {
  try {
    const total = await Account.countDocuments();
    const activas = await Account.countDocuments({ activo: true });
    const inactivas = await Account.countDocuments({ activo: false });

    res.json({
      success: true,
      data: {
        total,
        activas,
        inactivas,
        porcentajeActivas: total > 0 ? Math.round((activas / total) * 100) : 0
      }
    });
  } catch (error) {
    console.error('Error obteniendo estad√≠sticas:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// ===== RUTAS DE IM√ÅGENES =====

// Renovar URL firmada de imagen
app.post('/images/refresh-signed-url', authenticateToken, async (req, res) => {
  try {
    const { imageKey } = req.body;
    
    if (!imageKey) {
      return res.status(400).json({
        success: false,
        message: 'imageKey es requerido'
      });
    }

    const signedUrl = generateSignedUrl(imageKey, 172800); // 2 d√≠as

    if (!signedUrl) {
      return res.status(500).json({
        success: false,
        message: 'Error generando URL firmada'
      });
    }

    res.json({
      success: true,
      data: {
        imageKey,
        signedUrl
      }
    });
  } catch (error) {
    console.error('Error renovando URL firmada:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// ===== RUTAS DE GRUPOS =====

// Listar grupos
app.get('/groups', async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const accountId = req.query.accountId;

    // Simular datos de grupos
    const groups = [
      {
        _id: '64f8a1b2c3d4e5f6a7b8c9d0',
        nombre: 'Grupo Ejemplo',
        descripcion: 'Descripci√≥n del grupo',
        account: accountId || '64f8a1b2c3d4e5f6a7b8c9d1',
        creadoPor: '64f8a1b2c3d4e5f6a7b8c9d2',
        usuarios: ['64f8a1b2c3d4e5f6a7b8c9d3'],
        permisos: ['leer', 'escribir'],
        activo: true,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      }
    ];

    res.json({
      success: true,
      data: {
        groups,
        total: groups.length,
        page,
        limit
      }
    });
  } catch (error) {
    console.error('Error listando grupos:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Obtener grupos por cuenta
app.get('/groups/account/:accountId', authenticateToken, async (req, res) => {
  try {
    const { accountId } = req.params;
    const { userId } = req.user;
    const { activo } = req.query;

    // Verificar que el usuario tiene acceso a esta cuenta
    const user = await User.findById(userId).populate('role');
    const userAssociation = await Shared.findOne({
      user: userId,
      account: accountId,
      status: 'active'
    });

    if (!userAssociation && user.role?.nombre !== 'superadmin') {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver grupos de esta cuenta'
      });
    }

    // Buscar grupos de la cuenta
    let query = { account: accountId };
    
    // Filtrar por estado activo si se especifica
    if (activo !== undefined) {
      query.activo = activo === 'true';
    }

    const grupos = await Group.find(query)
      .populate('creadoPor', 'name email')
      .sort({ createdAt: -1 });

    console.log(`üìä Encontrados ${grupos.length} grupos para la cuenta ${accountId}`);

    res.json({
      success: true,
      data: {
        grupos: grupos.map(grupo => ({
          _id: grupo._id,
          nombre: grupo.nombre,
          descripcion: grupo.descripcion,
          activo: grupo.activo,
          creadoPor: grupo.creadoPor ? {
            _id: grupo.creadoPor._id,
            name: grupo.creadoPor.name,
            email: grupo.creadoPor.email
          } : null,
          createdAt: grupo.createdAt,
          updatedAt: grupo.updatedAt
        }))
      }
    });

  } catch (error) {
    console.error('Error obteniendo grupos por cuenta:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// ===== RUTAS DE EVENTOS =====

// Endpoint de debug para verificar eventos
app.get('/debug/eventos', authenticateToken, async (req, res) => {
  try {
    const { divisionId, fechaInicio, fechaFin } = req.query;
    
    console.log('üîç [DEBUG EVENTOS] Par√°metros:', { divisionId, fechaInicio, fechaFin });
    
    // Query simple para ver todos los eventos
    let query = {};
    
    if (divisionId) {
      query.division = divisionId;
    }
    
    if (fechaInicio && fechaFin) {
      query.fecha = {
        $gte: fechaInicio,
        $lte: fechaFin
      };
    }
    
    console.log('üîç [DEBUG EVENTOS] Query:', JSON.stringify(query, null, 2));
    
    const eventos = await Event.find(query)
      .populate('institucion', 'nombre')
      .populate('division', 'nombre')
      .lean();
    
    console.log('üîç [DEBUG EVENTOS] Total eventos encontrados:', eventos.length);
    
    res.json({
      success: true,
      data: {
        total: eventos.length,
        eventos: eventos.map(e => ({
          _id: e._id,
          titulo: e.titulo,
          fecha: e.fecha,
          fechaISO: e.fecha.toISOString(),
          division: e.division?.nombre || 'Sin divisi√≥n',
          institucion: e.institucion?.nombre || 'Sin instituci√≥n'
        }))
      }
    });
    
  } catch (error) {
    console.error('‚ùå [DEBUG EVENTOS] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener eventos de debug'
    });
  }
});

// Obtener datos del calendario de eventos
app.get('/backoffice/eventos/calendar', authenticateToken, getCognitoUserInstitution, async (req, res) => {
  try {
    // Verificar permisos del usuario
    let currentUser;
    if (req.user.isCognitoUser) {
      currentUser = await User.findOne({ email: req.user.email }).populate('role');
    } else {
      const { userId } = req.user;
      currentUser = await User.findById(userId).populate('role');
    }
    
    if (!currentUser) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    const userId = currentUser._id;
    const { 
      divisionId,
      fechaInicio,
      fechaFin
    } = req.query;
    
    console.log('üìÖ [CALENDAR EVENTOS] Usuario:', userId);
    console.log('üìÖ [CALENDAR EVENTOS] Par√°metros:', { divisionId, fechaInicio, fechaFin });
    console.log('üìÖ [CALENDAR EVENTOS] Fechas convertidas:', { 
      fechaInicioDate: new Date(fechaInicio), 
      fechaFinDate: new Date(fechaFin) 
    });
    
    // Obtener informaci√≥n del usuario para verificar su rol
    const user = await User.findById(userId).populate('role');
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    // Construir query base
    let query = {};
    
    // L√≥gica seg√∫n el rol
    if (user.role?.nombre === 'superadmin') {
      // Superadmin ve todos los eventos
    } else if (user.role?.nombre === 'adminaccount') {
      // Adminaccount ve todos los eventos de su cuenta
      if (user.account?._id) {
        query.institucion = user.account._id;
      } else {
        // Si no tiene account, usar cuenta por defecto
        query.institucion = '68d47433390104381d43c0ca';
      }
    } else {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para acceder a esta secci√≥n'
      });
    }
    
    // Filtros adicionales
    if (divisionId) {
      query.division = divisionId;
    }
    
    if (fechaInicio && fechaFin) {
      // Crear fechas UTC para evitar problemas de zona horaria
      const startDate = new Date(fechaInicio + 'T00:00:00.000Z');
      const endDate = new Date(fechaFin + 'T23:59:59.999Z');
      
      query.fecha = {
        $gte: startDate,
        $lte: endDate
      };
      
      console.log('üìÖ [CALENDAR EVENTOS] Filtro de fechas:', {
        fechaInicio: startDate.toISOString(),
        fechaFin: endDate.toISOString()
      });
    }
    
    console.log('üìÖ [CALENDAR EVENTOS] Query:', JSON.stringify(query, null, 2));
    
    // DEBUG: Buscar TODOS los eventos de la divisi√≥n sin filtro de fecha
    const allEvents = await Event.find({
      institucion: query.institucion,
      division: query.division
    }).lean();
    
    console.log('üìÖ [CALENDAR EVENTOS] TODOS los eventos de la divisi√≥n:', allEvents.map(e => ({
      id: e._id,
      titulo: e.titulo,
      fecha: e.fecha,
      institucion: e.institucion,
      division: e.division
    })));
    
    // Buscar eventos
    const eventos = await Event.find(query)
      .populate('institucion', 'nombre')
      .populate('division', 'nombre')
      .populate('creador', 'name email')
      .lean();
    
    console.log('üìÖ [CALENDAR EVENTOS] Eventos encontrados:', eventos.length);
    console.log('üìÖ [CALENDAR EVENTOS] Eventos detallados:', eventos.map(e => ({
      id: e._id,
      titulo: e.titulo,
      fecha: e.fecha,
      division: e.division?.nombre || 'Sin divisi√≥n'
    })));
    
    // Buscar autorizaciones para cada evento
    const eventosConAutorizaciones = await Promise.all(eventos.map(async (evento) => {
      const autorizaciones = await EventAuthorization.find({ event: evento._id })
        .populate('student', 'nombre email')
        .populate('familyadmin', 'name email')
        .lean();
      
      return {
        ...evento,
        autorizaciones: autorizaciones.map(auth => ({
          _id: auth._id,
          tipo: 'Autorizaci√≥n de evento',
          estado: auth.autorizado ? 'aprobada' : 'pendiente',
          estudiante: {
            _id: auth.student?._id,
            nombre: auth.student?.nombre,
            email: auth.student?.email
          },
          autorizadoPor: {
            _id: auth.familyadmin?._id,
            nombre: auth.familyadmin?.name
          },
          fechaAutorizacion: auth.fechaAutorizacion,
          observaciones: auth.comentarios
        }))
      };
    }));
    
    // Agrupar eventos por fecha
    const calendarData = {};
    
    eventosConAutorizaciones.forEach(evento => {
      const fecha = evento.fecha.toISOString().split('T')[0]; // YYYY-MM-DD
      
      if (!calendarData[fecha]) {
        calendarData[fecha] = {
          fecha: fecha,
          totalEventos: 0,
          eventos: []
        };
      }
      
      calendarData[fecha].totalEventos++;
      calendarData[fecha].eventos.push({
        _id: evento._id,
        titulo: evento.titulo,
        descripcion: evento.descripcion,
        fecha: evento.fecha,
        hora: evento.hora,
        lugar: evento.lugar,
        estado: evento.estado,
        participantes: evento.participantes || [],
        creador: evento.creador,
        institucion: evento.institucion,
        division: evento.division,
        autorizaciones: evento.autorizaciones || []
      });
    });
    
    console.log('üìÖ [CALENDAR EVENTOS] Datos del calendario generados:', Object.keys(calendarData).length, 'fechas');
    
    res.json({
      success: true,
      data: calendarData
    });
    
  } catch (error) {
    console.error('‚ùå [CALENDAR EVENTOS] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener datos del calendario de eventos'
    });
  }
});

// Listar eventos
app.get('/events', authenticateToken, async (req, res) => {
  try {
    const { accountId, search, page = 1, limit = 20 } = req.query;
    const currentUser = req.user;

    console.log('üìÖ [EVENTS] Usuario:', currentUser._id, currentUser.role?.nombre);
    console.log('üìÖ [EVENTS] Query params:', { accountId, search, page, limit });

    // Verificar permisos
    if (!['adminaccount', 'superadmin', 'coordinador'].includes(currentUser.role?.nombre)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver eventos'
      });
    }

    let query = {};

    // Filtro por instituci√≥n seg√∫n el rol del usuario
    if (currentUser.role?.nombre === 'superadmin') {
      // Superadmin puede ver todos los eventos
      if (accountId) {
        query.institucion = accountId;
      }
    } else if (currentUser.role?.nombre === 'adminaccount') {
      // Adminaccount solo puede ver eventos de sus cuentas
      try {
        const userAccounts = await Shared.find({ 
          user: currentUser._id, 
          status: { $in: ['active', 'pending'] }
        }).select('account');
        
        const accountIds = userAccounts.map(ah => ah.account);
        query.institucion = { $in: accountIds };
        
        if (accountId) {
          // Verificar que la cuenta solicitada pertenece al usuario
          if (!accountIds.includes(accountId)) {
            return res.status(403).json({
              success: false,
              message: 'No tienes permisos para ver eventos de esta cuenta'
            });
          }
          query.institucion = accountId;
        }
      } catch (error) {
        console.error('Error obteniendo cuentas del usuario:', error);
        return res.status(500).json({
          success: false,
          message: 'Error interno del servidor'
        });
      }
    } else if (currentUser.role?.nombre === 'coordinador') {
      // Coordinador puede ver eventos de sus cuentas
      if (accountId) {
        query.institucion = accountId;
      }
    }

    // B√∫squeda por t√≠tulo o descripci√≥n
    if (search) {
      query.$or = [
        { titulo: { $regex: search, $options: 'i' } },
        { descripcion: { $regex: search, $options: 'i' } }
      ];
    }

    console.log('üìÖ [EVENTS] Query final:', JSON.stringify(query, null, 2));

    // Obtener datos reales de la base de datos
    const total = await Event.countDocuments(query);
    console.log('üìÖ [EVENTS] Total eventos:', total);
    
    const events = await Event.find(query)
      .populate('creador', 'name email')
      .populate('institucion', 'nombre razonSocial')
      .populate('division', 'nombre descripcion')
      .skip((page - 1) * limit)
      .limit(limit)
      .sort({ fecha: 1 });

    console.log('üìÖ [EVENTS] Eventos encontrados:', events.length);

    res.json({
      success: true,
      data: {
        events: events.map(event => ({
          _id: event._id,
          titulo: event.titulo,
          descripcion: event.descripcion,
          fecha: event.fecha,
          hora: event.hora,
          lugar: event.lugar,
          estado: event.estado,
          requiereAutorizacion: event.requiereAutorizacion,
          creador: event.creador,
          institucion: event.institucion,
          division: event.division,
          participantes: event.participantes,
          createdAt: event.createdAt,
          updatedAt: event.updatedAt
        })),
        total,
        page: parseInt(page),
        limit: parseInt(limit)
      }
    });
  } catch (error) {
    console.error('Error listando eventos:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// ===== RUTAS DE ROLES =====

// Listar roles
app.get('/roles', async (req, res) => {
  try {
    // Simular datos de roles
    const roles = [
      {
        _id: '64f8a1b2c3d4e5f6a7b8c9d1',
        nombre: 'superadmin',
        descripcion: 'Super administrador con acceso total al sistema',
        permisos: ['todos'],
        nivel: 1,
        activo: true,
        esRolSistema: true,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      },
      {
        _id: '64f8a1b2c3d4e5f6a7b8c9d2',
        nombre: 'adminaccount',
        descripcion: 'Administrador de cuenta con permisos completos dentro de su cuenta',
        permisos: ['usuarios', 'cuentas', 'grupos', 'eventos'],
        nivel: 2,
        activo: true,
        esRolSistema: true,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      }
    ];
    
    res.json({
      success: true,
      data: roles
    });
  } catch (error) {
    console.error('Error listando roles:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Jerarqu√≠a de roles
app.get('/roles/hierarchy', async (req, res) => {
  try {
    const hierarchy = {
      1: 'superadmin',
      2: 'adminaccount',
      3: 'coordinador',
      4: 'familyadmin',
      5: 'familyviewer'
    };
    
    res.json({
      success: true,
      data: hierarchy
    });
  } catch (error) {
    console.error('Error obteniendo jerarqu√≠a:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// ===== RUTAS DE ACCIONES DE ESTUDIANTES =====

// Endpoint de prueba sin autenticaci√≥n
app.get('/api/student-actions/test', async (req, res) => {
  console.log('üéØ [TEST] Endpoint de prueba llamado');
  try {
    res.json({
      success: true,
      message: 'Endpoint de acciones funcionando',
      data: []
    });
  } catch (error) {
    console.error('‚ùå [TEST] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Obtener todas las acciones configuradas (sin filtros)
app.get('/api/student-actions', authenticateToken, getCognitoUserInstitution, async (req, res) => {
  try {
    // Verificar permisos del usuario
    let currentUser;
    if (req.user.isCognitoUser) {
      currentUser = await User.findOne({ email: req.user.email }).populate('role');
    } else {
      const { userId } = req.user;
      currentUser = await User.findById(userId).populate('role');
    }

    if (!currentUser) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    // Construir query base
    const query = { activa: true };

    // Filtrar por rol
    if (currentUser.role?.nombre === 'superadmin') {
      // Superadmin puede ver todas las acciones
    } else if (currentUser.role?.nombre === 'adminaccount') {
      // Adminaccount solo puede ver acciones de sus divisiones
      if (req.userInstitution) {
        const userDivisions = await Grupo.find({ cuenta: req.userInstitution._id }).select('_id');
        const divisionIds = userDivisions.map(d => d._id);
        query.division = { $in: divisionIds };
      } else {
        return res.status(403).json({
          success: false,
          message: 'No tienes una instituci√≥n asignada'
        });
      }
    } else {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver estas acciones'
      });
    }

    const acciones = await StudentAction.find(query)
      .populate('division', 'nombre descripcion')
      .populate('creadoPor', 'nombre email')
      .sort({ orden: 1, nombre: 1 });

    res.json({
      success: true,
      data: acciones
    });
  } catch (error) {
    console.error('Error obteniendo acciones:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor',
      error: error.message
    });
  }
});

// Obtener acciones configuradas por divisi√≥n
app.get('/api/student-actions/division/:divisionId', authenticateToken, async (req, res) => {
  try {
    const { divisionId } = req.params;
    const currentUser = req.user;

    console.log('üéØ [STUDENT ACTIONS] Obteniendo acciones para divisi√≥n:', divisionId);

    // Verificar permisos
    if (!['adminaccount', 'superadmin', 'coordinador'].includes(currentUser.role?.nombre)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver acciones de estudiantes'
      });
    }

    // Obtener acciones de la divisi√≥n
    const acciones = await StudentAction.find({ 
      division: divisionId, 
      activo: true 
    }).sort({ orden: 1, nombre: 1 });

    res.json({
      success: true,
      data: acciones
    });

  } catch (error) {
    console.error('‚ùå [STUDENT ACTIONS] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Crear nueva acci√≥n para una divisi√≥n
app.post('/api/student-actions', authenticateToken, async (req, res) => {
  try {
    const { nombre, descripcion, division, color, orden } = req.body;
    const currentUser = req.user;

    console.log('üéØ [STUDENT ACTIONS CREATE] Datos recibidos:', { nombre, descripcion, division, color });
    console.log('üéØ [STUDENT ACTIONS CREATE] Usuario:', currentUser.email, 'Rol:', currentUser.role?.nombre);

    // Verificar permisos
    if (!['adminaccount', 'superadmin'].includes(currentUser.role?.nombre)) {
      console.log('‚ùå [STUDENT ACTIONS CREATE] Sin permisos para crear acciones');
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para crear acciones de estudiantes'
      });
    }

    // Validar campos requeridos
    if (!nombre || !division) {
      console.log('‚ùå [STUDENT ACTIONS CREATE] Campos requeridos faltantes:', { nombre, division });
      return res.status(400).json({
        success: false,
        message: 'Nombre y divisi√≥n son requeridos'
      });
    }

    console.log('üéØ [STUDENT ACTIONS CREATE] Verificando divisi√≥n:', division);
    // Verificar que la divisi√≥n existe
    let divisionExists = await Group.findById(division);
    
    // TEMPORAL: Si no existe la divisi√≥n, crear una de prueba
    if (!divisionExists) {
      console.log('‚ùå [STUDENT ACTIONS CREATE] Divisi√≥n no encontrada:', division);
      console.log('üîß [STUDENT ACTIONS CREATE] Creando divisi√≥n de prueba...');
      
      // Crear divisi√≥n de prueba
      divisionExists = new Group({
        _id: division,
        nombre: 'Divisi√≥n de Prueba',
        account: currentUser.account || new mongoose.Types.ObjectId(),
        descripcion: 'Divisi√≥n creada autom√°ticamente para pruebas',
        creadoPor: currentUser._id
      });
      
      await divisionExists.save();
      console.log('‚úÖ [STUDENT ACTIONS CREATE] Divisi√≥n de prueba creada:', divisionExists.nombre);
    } else {
      console.log('‚úÖ [STUDENT ACTIONS CREATE] Divisi√≥n encontrada:', divisionExists.nombre);
    }
    
    // Verificar que la divisi√≥n pertenece a la instituci√≥n del usuario
    // Si el usuario tiene una asociaci√≥n activa, usar esa cuenta
    // Si no, usar la cuenta de la divisi√≥n
    const userAccount = currentUser.account || divisionExists.account;
    console.log('üîç [STUDENT ACTIONS CREATE] Cuenta del usuario:', userAccount);
    console.log('üîç [STUDENT ACTIONS CREATE] Cuenta de la divisi√≥n:', divisionExists.account);
    
    if (userAccount && divisionExists.account && userAccount.toString() !== divisionExists.account.toString()) {
      console.log('‚ùå [STUDENT ACTIONS CREATE] La divisi√≥n no pertenece a la instituci√≥n del usuario');
      return res.status(403).json({
        success: false,
        message: 'La divisi√≥n no pertenece a tu instituci√≥n'
      });
    }

    // Crear la acci√≥n
    console.log('üéØ [STUDENT ACTIONS CREATE] Creando nueva acci√≥n...');
    const nuevaAccion = new StudentAction({
      nombre,
      descripcion,
      division,
      account: divisionExists.account,
      color: color || '#3B82F6',
      orden: orden || 0,
      creadoPor: currentUser._id
    });

    console.log('üéØ [STUDENT ACTIONS CREATE] Guardando acci√≥n en BD...');
    await nuevaAccion.save();
    console.log('‚úÖ [STUDENT ACTIONS CREATE] Acci√≥n guardada exitosamente:', nuevaAccion._id);

    res.status(201).json({
      success: true,
      message: 'Acci√≥n creada exitosamente',
      data: nuevaAccion
    });

  } catch (error) {
    console.error('‚ùå [STUDENT ACTIONS CREATE] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Actualizar acci√≥n existente
app.put('/api/student-actions/:actionId', authenticateToken, async (req, res) => {
  try {
    const { actionId } = req.params;
    const { nombre, descripcion, categoria, icono, color, orden, activo } = req.body;
    const currentUser = req.user;

    console.log('üéØ [STUDENT ACTIONS UPDATE] Actualizando acci√≥n:', actionId);

    // Verificar permisos
    if (!['adminaccount', 'superadmin'].includes(currentUser.role?.nombre)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para actualizar acciones de estudiantes'
      });
    }

    // Buscar la acci√≥n
    const accion = await StudentAction.findById(actionId);
    if (!accion) {
      return res.status(404).json({
        success: false,
        message: 'La acci√≥n no existe'
      });
    }

    // Actualizar campos
    if (nombre) accion.nombre = nombre;
    if (descripcion !== undefined) accion.descripcion = descripcion;
    if (categoria) accion.categoria = categoria;
    if (icono) accion.icono = icono;
    if (color) accion.color = color;
    if (orden !== undefined) accion.orden = orden;
    if (activo !== undefined) accion.activo = activo;

    await accion.save();

    res.json({
      success: true,
      message: 'Acci√≥n actualizada exitosamente',
      data: accion
    });

  } catch (error) {
    console.error('‚ùå [STUDENT ACTIONS UPDATE] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Eliminar acci√≥n
app.delete('/api/student-actions/:actionId', authenticateToken, async (req, res) => {
  try {
    const { actionId } = req.params;
    const currentUser = req.user;

    console.log('üéØ [STUDENT ACTIONS DELETE] Eliminando acci√≥n:', actionId);

    // Verificar permisos
    if (!['adminaccount', 'superadmin'].includes(currentUser.role?.nombre)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para eliminar acciones de estudiantes'
      });
    }

    // Buscar y eliminar la acci√≥n
    const accion = await StudentAction.findByIdAndDelete(actionId);
    if (!accion) {
      return res.status(404).json({
        success: false,
        message: 'La acci√≥n no existe'
      });
    }

    res.json({
      success: true,
      message: 'Acci√≥n eliminada exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [STUDENT ACTIONS DELETE] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Registrar acci√≥n diaria de un estudiante
app.post('/api/student-actions/log', authenticateToken, async (req, res) => {
  try {
    const { estudiante, accion, comentarios, imagenes } = req.body;
    const currentUser = req.user;

    console.log('üéØ [STUDENT ACTION LOG] Registrando acci√≥n:', { estudiante, accion });

    // Verificar permisos
    if (!['adminaccount', 'superadmin', 'coordinador'].includes(currentUser.role?.nombre)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para registrar acciones de estudiantes'
      });
    }

    // Validar campos requeridos
    if (!estudiante || !accion) {
      return res.status(400).json({
        success: false,
        message: 'Estudiante y acci√≥n son requeridos'
      });
    }

    // Verificar que el estudiante existe
    const estudianteExists = await Student.findById(estudiante);
    if (!estudianteExists) {
      return res.status(404).json({
        success: false,
        message: 'El estudiante no existe'
      });
    }

    // Verificar que la acci√≥n existe
    const accionExists = await StudentAction.findById(accion);
    if (!accionExists) {
      return res.status(404).json({
        success: false,
        message: 'La acci√≥n no existe'
      });
    }

    // Crear el registro de acci√≥n
    const actionLog = new StudentActionLog({
      estudiante,
      accion,
      registradoPor: currentUser._id,
      division: estudianteExists.division,
      account: estudianteExists.account,
      comentarios,
      imagenes: imagenes || []
    });

    await actionLog.save();

    res.status(201).json({
      success: true,
      message: 'Acci√≥n registrada exitosamente',
      data: actionLog
    });

  } catch (error) {
    console.error('‚ùå [STUDENT ACTION LOG] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Obtener acciones registradas de un estudiante
app.get('/api/student-actions/log/student/:studentId', authenticateToken, async (req, res) => {
  try {
    const { studentId } = req.params;
    const { fecha } = req.query;
    const currentUser = req.user;

    console.log('üéØ [STUDENT ACTION LOG GET] Obteniendo acciones para estudiante:', studentId);

    // Verificar permisos
    if (!['adminaccount', 'superadmin', 'coordinador', 'familyadmin', 'familyviewer'].includes(currentUser.role?.nombre)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver acciones de estudiantes'
      });
    }

    // Construir filtro de fecha
    let fechaFilter = {};
    if (fecha) {
      const startDate = new Date(fecha);
      const endDate = new Date(fecha);
      endDate.setDate(endDate.getDate() + 1);
      
      fechaFilter = {
        fechaAccion: {
          $gte: startDate,
          $lt: endDate
        }
      };
    }

    // Obtener acciones del estudiante
    const acciones = await StudentActionLog.find({
      estudiante: studentId,
      ...fechaFilter
    })
    .populate('accion', 'nombre descripcion categoria icono color')
    .populate('registradoPor', 'name email')
    .sort({ fechaAccion: -1 });

    res.json({
      success: true,
      data: acciones
    });

  } catch (error) {
    console.error('‚ùå [STUDENT ACTION LOG GET] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// ===== RUTAS DE ASISTENCIAS =====

// Listar asistencias por cuenta
app.get('/asistencias', authenticateToken, async (req, res) => {
  try {
    const { accountId, grupoId, alumnoId, fechaInicio, fechaFin, page = 1, limit = 20 } = req.query;
    const currentUser = req.user;

    // Verificar permisos
    if (!['adminaccount', 'superadmin', 'coordinador'].includes(currentUser.role?.nombre)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver asistencias'
      });
    }

    let query = { activo: true };

    // Filtro por cuenta seg√∫n el rol del usuario
    if (currentUser.role?.nombre === 'superadmin') {
      // Superadmin puede ver todas las asistencias
      if (accountId) {
        query.account = accountId;
      }
    } else if (currentUser.role?.nombre === 'adminaccount') {
      // Adminaccount solo puede ver asistencias de sus cuentas
      const userAccounts = await Shared.find({ 
        user: currentUser._id, 
        status: { $in: ['active', 'pending'] }
      }).select('account');
      
      const accountIds = userAccounts.map(ah => ah.account);
      query.account = { $in: accountIds };
      
      if (accountId) {
        // Verificar que la cuenta solicitada pertenece al usuario
        if (!accountIds.includes(accountId)) {
          return res.status(403).json({
            success: false,
            message: 'No tienes permisos para ver asistencias de esta cuenta'
          });
        }
        query.account = accountId;
      }
    } else if (currentUser.role?.nombre === 'coordinador') {
      // Coordinador puede ver asistencias de sus grupos
      if (accountId) {
        query.account = accountId;
      }
    }

    // Filtros adicionales
    if (grupoId) {
      query.division = grupoId;
    }
    
    if (alumnoId) {
      query.alumno = alumnoId;
    }
    
    if (fechaInicio && fechaFin) {
      query.fecha = {
        $gte: fechaInicio,
        $lte: fechaFin
      };
    }

    // Obtener datos reales de la base de datos
    const total = await Asistencia.countDocuments(query);
    const asistencias = await Asistencia.find(query)
      .populate('alumno', 'name email')
      .populate('account', 'nombre razonSocial')
      .populate('grupo', 'nombre descripcion')
      .populate('registradoPor', 'name email')
      .skip((page - 1) * limit)
      .limit(limit)
      .sort({ fecha: -1, horaLlegada: -1 });

    res.json({
      success: true,
      data: {
        asistencias: asistencias.map(asistencia => ({
          _id: asistencia._id,
          alumno: asistencia.alumno,
          account: asistencia.account,
          grupo: asistencia.grupo,
          fecha: asistencia.fecha,
          estado: asistencia.estado,
          horaLlegada: asistencia.horaLlegada,
          horaSalida: asistencia.horaSalida,
          observaciones: asistencia.observaciones,
          registradoPor: asistencia.registradoPor,
          activo: asistencia.activo,
          createdAt: asistencia.createdAt,
          updatedAt: asistencia.updatedAt
        })),
        total,
        page: parseInt(page),
        limit: parseInt(limit)
      }
    });
  } catch (error) {
    console.error('Error listando asistencias:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Registrar nueva asistencia
app.post('/asistencias', authenticateToken, async (req, res) => {
  try {
    const { alumnoId, accountId, grupoId, fecha, estado, horaLlegada, horaSalida, observaciones } = req.body;
    const currentUser = req.user;

    // Verificar permisos
    if (!['adminaccount', 'superadmin', 'coordinador'].includes(currentUser.role?.nombre)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para registrar asistencias'
      });
    }

    // Validaciones
    if (!alumnoId || !accountId || !grupoId || !fecha) {
      return res.status(400).json({
        success: false,
        message: 'alumnoId, accountId, grupoId y fecha son requeridos'
      });
    }

    // Verificar que el alumno existe
    const alumno = await User.findById(alumnoId);
    if (!alumno) {
      return res.status(404).json({
        success: false,
        message: 'Alumno no encontrado'
      });
    }

    // Verificar que la cuenta existe
    console.log('üîç [ASISTENCIA] accountId recibido:', accountId, typeof accountId);
    console.log('üîç [ASISTENCIA] Modelo Account disponible:', !!Account);
    console.log('üîç [ASISTENCIA] Iniciando b√∫squeda de cuenta...');
    try {
      const account = await Account.findById(accountId);
      console.log('üîç [ASISTENCIA] Resultado de Account.findById:', account);
      if (!account) {
        console.log('‚ùå [ASISTENCIA] Cuenta no encontrada para ID:', accountId);
        return res.status(400).json({
          success: false,
          message: 'La cuenta especificada no existe'
        });
      }
      console.log('‚úÖ [ASISTENCIA] Cuenta encontrada:', account.nombre);
    } catch (e) {
      console.error('‚ùå [ASISTENCIA] Error en Account.findById:', e);
      return res.status(500).json({
        success: false,
        message: 'Error buscando la cuenta',
        error: e.message
      });
    }

    // Verificar que el grupo existe
    const grupo = await Grupo.findById(grupoId);
    if (!grupo) {
      return res.status(404).json({
        success: false,
        message: 'Grupo no encontrado'
      });
    }

    // Verificar permisos seg√∫n rol
    if (currentUser.role?.nombre === 'adminaccount') {
      const userAccounts = await Shared.find({ 
        user: currentUser._id, 
        status: { $in: ['active', 'pending'] }
      }).select('account');
      
      const accountIds = userAccounts.map(ah => ah.account.toString());
      if (!accountIds.includes(accountId)) {
        return res.status(403).json({
          success: false,
          message: 'No tienes permisos para registrar asistencias en esta cuenta'
        });
      }
    }

    // Verificar si ya existe una asistencia para este alumno en esta fecha y grupo
    const fechaAsistencia = new Date(fecha);
    const asistenciaExistente = await Asistencia.existeAsistencia(alumnoId, fechaAsistencia, grupoId);
    
    if (asistenciaExistente) {
      return res.status(400).json({
        success: false,
        message: 'Ya existe una asistencia registrada para este alumno en esta fecha y grupo'
      });
    }

    // Crear nueva asistencia
    const nuevaAsistencia = new Asistencia({
      alumno: alumnoId,
      account: accountId,
      grupo: grupoId,
      fecha: fechaAsistencia,
      estado: estado || 'presente',
      horaLlegada: horaLlegada ? new Date(horaLlegada) : null,
      horaSalida: horaSalida ? new Date(horaSalida) : null,
      observaciones,
      registradoPor: currentUser._id
    });

    await nuevaAsistencia.save();

    // Obtener la asistencia con datos poblados
    const asistenciaGuardada = await Asistencia.findById(nuevaAsistencia._id)
      .populate('alumno', 'name email')
      .populate('account', 'nombre razonSocial')
      .populate('grupo', 'nombre descripcion')
      .populate('registradoPor', 'name email');

    console.log(`‚úÖ Asistencia registrada: ${asistenciaGuardada.alumno.name} en ${asistenciaGuardada.grupo.nombre}`);

    res.status(201).json({
      success: true,
      message: 'Asistencia registrada exitosamente',
      data: asistenciaGuardada
    });

  } catch (error) {
    console.error('Error registrando asistencia:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Actualizar asistencia
app.put('/asistencias/:asistenciaId', authenticateToken, async (req, res) => {
  try {
    const { asistenciaId } = req.params;
    const { estado, horaLlegada, horaSalida, observaciones } = req.body;
    const currentUser = req.user;

    // Verificar permisos
    if (!['adminaccount', 'superadmin', 'coordinador'].includes(currentUser.role?.nombre)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para actualizar asistencias'
      });
    }

    // Buscar la asistencia
    const asistencia = await Asistencia.findById(asistenciaId)
      .populate('alumno', 'name email')
      .populate('account', 'nombre razonSocial')
      .populate('grupo', 'nombre descripcion')
      .populate('registradoPor', 'name email');

    if (!asistencia) {
      return res.status(404).json({
        success: false,
        message: 'Asistencia no encontrada'
      });
    }

    // Verificar permisos seg√∫n rol
    if (currentUser.role?.nombre === 'adminaccount') {
      const userAccounts = await Shared.find({ 
        user: currentUser._id, 
        status: { $in: ['active', 'pending'] }
      }).select('account');
      
      const accountIds = userAccounts.map(ah => ah.account.toString());
      if (!accountIds.includes(asistencia.account._id.toString())) {
        return res.status(403).json({
          success: false,
          message: 'No tienes permisos para actualizar asistencias de esta cuenta'
        });
      }
    }

    // Actualizar campos
    if (estado) asistencia.estado = estado;
    if (horaLlegada !== undefined) asistencia.horaLlegada = horaLlegada ? new Date(horaLlegada) : null;
    if (horaSalida !== undefined) asistencia.horaSalida = horaSalida ? new Date(horaSalida) : null;
    if (observaciones !== undefined) asistencia.observaciones = observaciones;

    await asistencia.save();

    console.log(`‚úÖ Asistencia actualizada: ${asistencia.alumno.name} en ${asistencia.grupo.nombre}`);

    res.json({
      success: true,
      message: 'Asistencia actualizada exitosamente',
      data: asistencia
    });

  } catch (error) {
    console.error('Error actualizando asistencia:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Eliminar asistencia (marcar como inactiva)
app.delete('/asistencias/:asistenciaId', authenticateToken, async (req, res) => {
  try {
    const { asistenciaId } = req.params;
    const currentUser = req.user;

    // Verificar permisos
    if (!['adminaccount', 'superadmin'].includes(currentUser.role?.nombre)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para eliminar asistencias'
      });
    }

    // Buscar la asistencia
    const asistencia = await Asistencia.findById(asistenciaId)
      .populate('alumno', 'name email')
      .populate('account', 'nombre razonSocial')
      .populate('grupo', 'nombre descripcion');

    if (!asistencia) {
      return res.status(404).json({
        success: false,
        message: 'Asistencia no encontrada'
      });
    }

    // Verificar permisos seg√∫n rol
    if (currentUser.role?.nombre === 'adminaccount') {
      const userAccounts = await Shared.find({ 
        user: currentUser._id, 
        status: { $in: ['active', 'pending'] }
      }).select('account');
      
      const accountIds = userAccounts.map(ah => ah.account.toString());
      if (!accountIds.includes(asistencia.account._id.toString())) {
        return res.status(403).json({
          success: false,
          message: 'No tienes permisos para eliminar asistencias de esta cuenta'
        });
      }
    }

    // Marcar como inactiva
    asistencia.activo = false;
    await asistencia.save();

    console.log(`‚ùå Asistencia eliminada: ${asistencia.alumno.name} en ${asistencia.grupo.nombre}`);

    res.json({
      success: true,
      message: 'Asistencia eliminada exitosamente'
    });

  } catch (error) {
    console.error('Error eliminando asistencia:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// ===== RUTAS DE ACTIVITY =====

// Listar actividades
app.get('/activities', authenticateToken, getCognitoUserInstitution, async (req, res) => {
  try {
    const { accountId, userId, tipo, entidad, fechaInicio, fechaFin, page = 1, limit = 50 } = req.query;
    const currentUser = req.user;

    // Verificar permisos
    if (!['adminaccount', 'superadmin', 'coordinador'].includes(currentUser.role?.nombre)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver actividades'
      });
    }

    // Incluir actividades activas y en borrador para el backoffice
    let query = { 
      activo: true,
      $or: [
        { estado: { $exists: false } }, // Actividades sin estado (legacy)
        { estado: 'publicada' },
        { estado: 'borrador' }
      ]
    };

    // Filtro por cuenta seg√∫n el rol del usuario
    if (currentUser.role?.nombre === 'superadmin') {
      // Superadmin puede ver todas las actividades
      if (accountId) {
        query.account = accountId;
      }
    } else if (currentUser.role?.nombre === 'adminaccount') {
      // Adminaccount solo puede ver actividades de sus cuentas
      // Usar el middleware global para obtener la instituci√≥n
      if (req.userInstitution) {
        console.log('üè¢ Instituci√≥n del usuario:', req.userInstitution.nombre, req.userInstitution._id);
        
        query.account = req.userInstitution._id;
        
        if (accountId) {
          // Verificar que la cuenta solicitada pertenece al usuario
          if (!verifyAccountAccess(req, accountId)) {
            return res.status(403).json({
              success: false,
              message: 'No tienes permisos para ver actividades de esta cuenta'
            });
          }
          query.account = accountId;
        }
      } else {
        console.log('‚ö†Ô∏è Usuario sin instituci√≥n asignada');
        query.account = null; // No mostrar actividades
      }
    } else if (currentUser.role?.nombre === 'coordinador') {
      // Coordinador puede ver actividades de sus cuentas
      if (accountId) {
        query.account = accountId;
      }
    }

    // Filtros adicionales
    if (userId) {
      query.usuario = userId;
    }
    
    if (tipo) {
      query.tipo = tipo;
    }
    
    if (entidad) {
      query.entidad = entidad;
    }
    
    if (fechaInicio && fechaFin) {
      query.createdAt = {
        $gte: fechaInicio,
        $lte: fechaFin
      };
    }

    // Obtener datos reales de la base de datos
    const total = await Activity.countDocuments(query);
    const activities = await Activity.find(query)
      .populate('usuario', 'name email')
      .populate('account', 'nombre razonSocial')
      .sort({ createdAt: -1 })
      .limit(50); // Limitar a las √∫ltimas 50 actividades

    res.json({
      success: true,
      data: {
        activities: activities.map(activity => ({
          _id: activity._id,
          usuario: activity.usuario,
          account: activity.account,
          tipo: activity.tipo,
          entidad: activity.entidad,
          entidadId: activity.entidadId,
          descripcion: activity.descripcion,
          datos: activity.datos,
          ip: activity.ip,
          userAgent: activity.userAgent,
          activo: activity.activo,
          createdAt: activity.createdAt,
          updatedAt: activity.updatedAt
        })),
        total,
        page: parseInt(page),
        limit: parseInt(limit)
      }
    });
  } catch (error) {
    console.error('Error listando actividades:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Registrar actividad (helper para otros endpoints)
const registrarActividad = async (data) => {
  try {
    await Activity.registrarActividad({
      usuario: data.usuario,
      account: data.account,
      tipo: data.tipo,
      entidad: data.entidad,
      entidadId: data.entidadId,
      descripcion: data.descripcion,
      datos: data.datos || {},
      ip: data.ip,
      userAgent: data.userAgent
    });
  } catch (error) {
    console.error('Error registrando actividad:', error);
  }
};

// Endpoint para eliminar una actividad
app.delete('/activities/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const userId = req.user._id;

    console.log('üóëÔ∏è [DELETE ACTIVITY] Iniciando eliminaci√≥n de actividad:', id);
    console.log('üë§ [DELETE ACTIVITY] Usuario:', userId);

    // Verificar que el usuario tiene permisos para eliminar actividades
    const user = await User.findById(userId).populate('role');
    const userRole = user?.role?.nombre;

    console.log('üé≠ [DELETE ACTIVITY] Rol del usuario:', userRole);

    if (userRole !== 'coordinador') {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para eliminar actividades'
      });
    }

    // Buscar la actividad
    const activity = await Activity.findById(id);
    
    if (!activity) {
      return res.status(404).json({
        success: false,
        message: 'Actividad no encontrada'
      });
    }

    // Verificar que el usuario tiene acceso a la instituci√≥n de la actividad
    const userAssociation = await Shared.findOne({
      user: userId,
      account: activity.account,
      status: 'active'
    });

    if (!userAssociation) {
      return res.status(403).json({
        success: false,
        message: 'No tienes acceso a esta instituci√≥n'
      });
    }

    // Eliminar la actividad (soft delete)
    activity.activo = false;
    await activity.save();

    console.log('‚úÖ [DELETE ACTIVITY] Actividad eliminada exitosamente');

    res.json({
      success: true,
      message: 'Actividad eliminada exitosamente'
    });

  } catch (error) {
    console.error('Error eliminando actividad:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Endpoint para obtener actividades filtradas por instituci√≥n y divisi√≥n (para mobile)
app.get('/activities/mobile', authenticateToken, async (req, res) => {
  try {
    const { accountId, divisionId, selectedDate } = req.query;
    const userId = req.user._id;

    console.log('üéØ [ACTIVITIES MOBILE] Iniciando b√∫squeda de actividades');
    console.log('üë§ [ACTIVITIES MOBILE] Usuario:', userId);
    console.log('üè¢ [ACTIVITIES MOBILE] AccountId:', accountId);
    console.log('üìö [ACTIVITIES MOBILE] DivisionId:', divisionId);

    if (!accountId) {
      return res.status(400).json({
        success: false,
        message: 'accountId es requerido'
      });
    }

    // Verificar que el usuario tenga acceso a esta cuenta
    const userAssociation = await Shared.findOne({
      user: userId,
      account: accountId,
      status: 'active'
    }).populate('role student');

    if (!userAssociation) {
      return res.status(403).json({
        success: false,
        message: 'No tienes acceso a esta instituci√≥n'
      });
    }

    console.log('üîç [ACTIVITIES MOBILE] Asociaci√≥n del usuario:', {
      role: userAssociation.role?.nombre,
      student: userAssociation.student?._id,
      studentName: userAssociation.student ? `${userAssociation.student.nombre} ${userAssociation.student.apellido}` : 'N/A'
    });

    // Construir query base seg√∫n el rol del usuario
    const userRole = userAssociation.role?.nombre;
    const userStudent = userAssociation.student?._id;
    
    console.log('üé≠ [ACTIVITIES MOBILE] Rol del usuario:', userRole);
    console.log('üë®‚Äçüéì [ACTIVITIES MOBILE] Estudiante vinculado:', userStudent);

    let query = {
      account: accountId,
      activo: true,
      $or: [
        { estado: 'publicada' }, // Actividades expl√≠citamente publicadas
        { estado: { $exists: false } } // Actividades existentes sin campo estado (compatibilidad)
      ]
    };

    // Filtrar por fecha: usar solo como fecha l√≠mite superior (hasta la fecha seleccionada)
    if (selectedDate) {
      // Usar la fecha seleccionada como l√≠mite superior
      const selected = new Date(selectedDate);
      const endDate = new Date(selected.getFullYear(), selected.getMonth(), selected.getDate(), 23, 59, 59, 999);
      query.createdAt = {
        $lte: endDate
      };
      console.log('üìÖ [ACTIVITIES MOBILE] Usando fecha seleccionada como l√≠mite superior:', selectedDate);
      console.log('üìÖ [ACTIVITIES MOBILE] Fecha l√≠mite calculada:', endDate.toISOString());
    } else {
      // Si no hay fecha seleccionada, no aplicar filtro de fecha (mostrar todas las actividades)
      console.log('üìÖ [ACTIVITIES MOBILE] Sin filtro de fecha - mostrando todas las actividades');
    }

    // Agregar filtro por divisi√≥n si se proporciona
    if (divisionId) {
      query.division = divisionId;
      console.log('üè¢ [ACTIVITIES MOBILE] Filtro por divisi√≥n aplicado:', divisionId);
    } else {
      console.log('üè¢ [ACTIVITIES MOBILE] Sin filtro de divisi√≥n');
    }

    // Filtrar seg√∫n el rol del usuario
    if (userRole === 'coordinador') {
      console.log('üë®‚Äçüíº [ACTIVITIES MOBILE] Coordinador: mostrando todas las actividades del d√≠a');
      // Coordinador ve todas las actividades del d√≠a (no se agrega filtro adicional)
    } else if (userRole === 'familyadmin' || userRole === 'familyviewer') {
      if (userStudent) {
        console.log('üë®‚Äçüë©‚Äçüëß‚Äçüë¶ [ACTIVITIES MOBILE] Familyadmin/Viewer: filtrando por estudiante vinculado');
        // Familyadmin/Viewer solo ve actividades donde su estudiante est√© en participantes
        query.participantes = userStudent;
      } else {
        console.log('‚ö†Ô∏è [ACTIVITIES MOBILE] Familyadmin/Viewer sin estudiante vinculado: no hay actividades');
        // Si no tiene estudiante vinculado, no mostrar actividades
        query.participantes = null; // Esto no devolver√° resultados
      }
    } else {
      console.log('‚ùì [ACTIVITIES MOBILE] Rol no reconocido:', userRole);
      // Para otros roles, no mostrar actividades
      query.participantes = null; // Esto no devolver√° resultados
    }

    console.log('üîç [ACTIVITIES MOBILE] Query final:', JSON.stringify(query, null, 2));

    // DEBUG: Contar actividades totales antes del l√≠mite
    const totalActivities = await Activity.countDocuments(query);
    console.log('üìä [ACTIVITIES MOBILE] Total actividades en DB que coinciden con query:', totalActivities);

    // Obtener actividades
    const activities = await Activity.find(query)
      .populate('usuario', 'name email')
      .populate('account', 'nombre razonSocial')
      .populate('division', 'nombre descripcion')
      .populate('participantes', 'nombre apellido dni')
      .sort({ createdAt: -1 })
      .limit(100); // Limitar a las √∫ltimas 100 actividades

    console.log('üìä [ACTIVITIES MOBILE] Actividades encontradas:', activities.length, '(m√°ximo 100 actividades)');
    console.log('üìä [ACTIVITIES MOBILE] Total en DB vs encontradas:', `${totalActivities} vs ${activities.length}`);
    activities.forEach((activity, index) => {
      console.log(`üìã [ACTIVITIES MOBILE] Actividad ${index + 1}:`, {
        id: activity._id,
        titulo: activity.titulo,
        participantes: activity.participantes?.map(p => p._id) || [],
        createdAt: activity.createdAt
      });
    });

    // Generar URLs firmadas para las im√°genes
    const activitiesWithSignedUrls = await Promise.all(activities.map(async (activity) => {
      let imagenesSignedUrls = [];
      
      // Si la actividad tiene im√°genes, generar URLs firmadas
      if (activity.imagenes && Array.isArray(activity.imagenes)) {
        try {
          imagenesSignedUrls = await Promise.all(activity.imagenes.map(async (imageKey) => {
            // Generar URL firmada usando la key directamente
            const signedUrl = await generateSignedUrl(imageKey);
            return signedUrl;
          }));
        } catch (error) {
          console.error('Error generando URLs firmadas para actividad:', activity._id, error);
          imagenesSignedUrls = []; // No devolver URLs si falla
        }
      }

      // Formatear participantes como string de nombres
      const participantesNombres = Array.isArray(activity.participantes) 
        ? activity.participantes
          .filter(p => p) // Filtrar participantes nulos/undefined
          .map(p => `${p.nombre} ${p.apellido}`)
          .join(', ')
        : '';

      return {
        _id: activity._id,
        usuario: activity.usuario,
        account: activity.account,
        division: activity.division,
        tipo: activity.tipo,
        entidad: activity.entidad,
        entidadId: activity.entidadId,
        descripcion: activity.descripcion,
        titulo: activity.titulo,
        participantes: participantesNombres,
        imagenes: imagenesSignedUrls,
        datos: activity.datos || {},
        activo: activity.activo,
        createdAt: activity.createdAt,
        updatedAt: activity.updatedAt
      };
    }));

    console.log('üîç Debug - Activities with signed URLs:', JSON.stringify(activitiesWithSignedUrls, null, 2));

    res.json({
      success: true,
      data: {
        activities: activitiesWithSignedUrls
      }
    });
  } catch (error) {
    console.error('Error obteniendo actividades para mobile:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Rutas de upload
app.use('/upload', uploadRoutes);

// Rutas de documentos
console.log('üîç Registrando rutas de documentos...');
app.use('/api/documents', documentRoutes);
console.log('‚úÖ Rutas de documentos registradas');

// Endpoint para subir im√°genes
app.post('/upload-image', authenticateToken, upload.single('image'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'No se proporcion√≥ ning√∫n archivo'
      });
    }

    const imageUrl = `${req.protocol}://${req.get('host')}/uploads/${req.file.filename}`;
    
    res.json({
      success: true,
      imageUrl: imageUrl,
      filename: req.file.filename
    });
  } catch (error) {
    console.error('Error uploading image:', error);
    res.status(500).json({
      success: false,
      message: 'Error al subir la imagen'
    });
  }
});

// Endpoint para crear actividades
app.post('/activities', authenticateToken, async (req, res) => {
  try {
    const { titulo, participantes, descripcion, imagenes, accountId, divisionId, userId } = req.body;

    if (!titulo || !participantes || !accountId || !userId) {
      return res.status(400).json({
        success: false,
        message: 'Faltan campos obligatorios'
      });
    }

    // Verificar que el usuario tiene acceso a la cuenta
    const userAssociation = await Shared.findOne({
      user: userId,
      account: accountId,
      status: 'active'
    });

    if (!userAssociation) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para crear actividades en esta cuenta'
      });
    }

    // Validar que participantes sea un array
    if (!Array.isArray(participantes)) {
      return res.status(400).json({
        success: false,
        message: 'Participantes debe ser un array de IDs de estudiantes'
      });
    }

    // Crear la actividad
    const activity = new Activity({
      titulo,
      participantes, // Guardar el array de IDs tal como viene del mobile
      descripcion: descripcion || '',
      imagenes: imagenes || [],
      account: accountId,
      division: divisionId,
      createdBy: userId,
      usuario: userId,
      tipo: 'create',
      entidad: 'event',
      estado: 'borrador' // Las actividades se crean en estado borrador
    });

    await activity.save();

    res.json({
      success: true,
      message: 'Actividad creada correctamente',
      activity: activity
    });
  } catch (error) {
    console.error('Error creating activity:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Endpoint para cambiar estado de actividad
app.patch('/activities/:id/estado', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { estado } = req.body;
    const currentUser = req.user;

    // Verificar que el estado sea v√°lido
    if (!['borrador', 'publicada'].includes(estado)) {
      return res.status(400).json({
        success: false,
        message: 'Estado inv√°lido. Debe ser "borrador" o "publicada"'
      });
    }

    // Verificar permisos
    if (!['adminaccount', 'superadmin', 'coordinador'].includes(currentUser.role?.nombre)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para cambiar el estado de actividades'
      });
    }

    // Buscar la actividad
    const activity = await Activity.findById(id);
    if (!activity) {
      return res.status(404).json({
        success: false,
        message: 'Actividad no encontrada'
      });
    }

    // Verificar que el usuario tenga acceso a esta actividad
    if (currentUser.role?.nombre === 'adminaccount') {
      console.log('üîç [DEBUG] Verificando permisos para adminaccount');
      console.log('üîç [DEBUG] currentUser.userId:', currentUser.userId);
      console.log('üîç [DEBUG] activity.account:', activity.account);
      
      const userAccounts = await Shared.find({ 
        user: currentUser.userId, 
        status: { $in: ['active', 'pending'] }
      }).select('account');
      
      console.log('üîç [DEBUG] userAccounts encontradas:', userAccounts.length);
      console.log('üîç [DEBUG] userAccounts:', userAccounts);
      
      const accountIds = userAccounts.map(ah => ah.account);
      console.log('üîç [DEBUG] accountIds del usuario:', accountIds);
      console.log('üîç [DEBUG] activity.account:', activity.account);
      console.log('üîç [DEBUG] activity.account.toString():', activity.account.toString());
      
      // Verificar si alguna de las cuentas del usuario coincide con la cuenta de la actividad
      const hasAccess = accountIds.some(accountId => accountId.equals(activity.account));
      console.log('üîç [DEBUG] ¬øUsuario tiene acceso?', hasAccess);
      
      if (!hasAccess) {
        console.log('‚ùå [DEBUG] Usuario no tiene acceso a esta actividad');
        return res.status(403).json({
          success: false,
          message: 'No tienes permisos para modificar esta actividad'
        });
      }
      console.log('‚úÖ [DEBUG] Usuario tiene acceso a la actividad');
    }

    // Actualizar el estado
    activity.estado = estado;
    await activity.save();

    res.json({
      success: true,
      message: `Actividad ${estado === 'publicada' ? 'publicada' : 'marcada como borrador'} correctamente`,
      activity: activity
    });
  } catch (error) {
    console.error('Error changing activity status:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Endpoint para eliminar actividades
app.delete('/activities/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { userId } = req.user;

    // Verificar que la actividad existe
    const activity = await Activity.findById(id);

    if (!activity) {
      return res.status(404).json({
        success: false,
        message: 'Actividad no encontrada'
      });
    }

    // Verificar permisos (solo superadmin puede eliminar actividades)
    const user = await User.findById(userId).populate('role');

    if (user.role?.nombre !== 'superadmin') {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para eliminar actividades'
      });
    }

    // Eliminar la actividad
    await Activity.findByIdAndDelete(id);

    res.json({
      success: true,
      message: 'Actividad eliminada correctamente'
    });
  } catch (error) {
    console.error('Error deleting activity:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// ===== ENDPOINTS PARA BACKOFFICE - ACTIVIDADES =====

// Endpoint para obtener datos del calendario de actividades
app.get('/backoffice/actividades/calendar', authenticateToken, getCognitoUserInstitution, async (req, res) => {
  try {
    const { divisionId, fechaInicio, fechaFin } = req.query;
    
    // Verificar permisos del usuario
    let currentUser;
    if (req.user.isCognitoUser) {
      currentUser = await User.findOne({ email: req.user.email }).populate('role');
    } else {
      currentUser = req.user;
    }
    
    if (!currentUser) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    console.log('üìÖ [BACKOFFICE ACTIVITIES] Obteniendo datos del calendario');
    console.log('üìÖ [BACKOFFICE ACTIVITIES] DivisionId:', divisionId);
    console.log('üìÖ [BACKOFFICE ACTIVITIES] FechaInicio:', fechaInicio);
    console.log('üìÖ [BACKOFFICE ACTIVITIES] FechaFin:', fechaFin);
    console.log('üìÖ [BACKOFFICE ACTIVITIES] User role:', currentUser.role?.nombre);
    console.log('üìÖ [BACKOFFICE ACTIVITIES] User ID:', currentUser._id);

    // Verificar permisos
    if (!['adminaccount', 'superadmin', 'coordinador'].includes(currentUser.role?.nombre)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver actividades'
      });
    }

    if (!divisionId || !fechaInicio || !fechaFin) {
      return res.status(400).json({
        success: false,
        message: 'divisionId, fechaInicio y fechaFin son requeridos'
      });
    }

    // Construir query base seg√∫n el rol del usuario
    let query = {
      division: divisionId,
      activo: true
    };

    // Para adminaccount, no filtrar por estado (ver todas las actividades)
    if (currentUser.role?.nombre === 'adminaccount') {
      // Adminaccount puede ver todas las actividades sin filtro de estado
      console.log('üë®‚Äçüíº [BACKOFFICE ACTIVITIES] Adminaccount - sin filtro de estado (ver todas)');
    } else {
      // Para otros roles, incluir filtro de estado
      query.$or = [
        { estado: { $exists: false } }, // Actividades sin estado (legacy)
        { estado: 'publicada' },
        { estado: 'borrador' }
      ];
    }

    // Filtro por cuenta seg√∫n el rol del usuario
    if (currentUser.role?.nombre === 'superadmin') {
      // Superadmin puede ver todas las actividades
    } else if (currentUser.role?.nombre === 'adminaccount') {
      // Adminaccount solo puede ver actividades de sus cuentas
      const userAccounts = await Shared.find({ 
        user: currentUser._id, 
        status: { $in: ['active', 'pending'] }
      }).select('account');
      
      const accountIds = userAccounts.map(ah => ah.account);
      query.account = { $in: accountIds };
    } else if (currentUser.role?.nombre === 'coordinador') {
      // Coordinador puede ver actividades de sus cuentas
      const userAccounts = await Shared.find({ 
        user: currentUser._id, 
        status: { $in: ['active', 'pending'] }
      }).select('account');
      
      const accountIds = userAccounts.map(ah => ah.account);
      query.account = { $in: accountIds };
    }

    // Filtro por fecha - CORREGIDO: usar UTC para evitar problemas de timezone
    // Convertir a objetos Date si vienen como strings
    const fechaInicioDate = new Date(fechaInicio);
    const fechaFinDate = new Date(fechaFin);
    
    // Convertir a UTC para evitar problemas de timezone
    const fechaInicioUTC = new Date(fechaInicioDate.getTime() - (fechaInicioDate.getTimezoneOffset() * 60000));
    const fechaFinUTC = new Date(fechaFinDate.getTime() - (fechaFinDate.getTimezoneOffset() * 60000));
    
    console.log('üåç [BACKOFFICE ACTIVITIES] Filtro de fechas UTC:');
    console.log('  - Fecha inicio original:', fechaInicio);
    console.log('  - Fecha inicio local:', fechaInicioDate.toISOString());
    console.log('  - Fecha inicio UTC:', fechaInicioUTC.toISOString());
    console.log('  - Fecha fin original:', fechaFin);
    console.log('  - Fecha fin local:', fechaFinDate.toISOString());
    console.log('  - Fecha fin UTC:', fechaFinUTC.toISOString());
    
    // Para el backoffice, mostrar todas las actividades del mes del calendario
    // Filtro de fechas simplificado - solo por mes del calendario
    query.$or = [
      // Actividades con fechas definidas que caen en el rango del mes
      {
        fechaInicio: { $exists: true, $ne: null },
        fechaFin: { $exists: true, $ne: null },
        $or: [
          { fechaInicio: { $gte: fechaInicioUTC, $lte: fechaFinUTC } },
          { fechaFin: { $gte: fechaInicioUTC, $lte: fechaFinUTC } },
          { 
            fechaInicio: { $lte: fechaInicioUTC },
            fechaFin: { $gte: fechaFinUTC }
          }
        ]
      },
      // Actividades sin fechas definidas - mostrar todas del mes
      {
        $or: [
          { fechaInicio: { $exists: false } },
          { fechaInicio: null },
          { fechaFin: { $exists: false } },
          { fechaFin: null }
        ]
      }
    ];

    console.log('üìÖ [BACKOFFICE ACTIVITIES] Query:', JSON.stringify(query, null, 2));
    
    // Log espec√≠fico para adminaccount
    if (currentUser.role?.nombre === 'adminaccount') {
      console.log('üë®‚Äçüíº [BACKOFFICE ACTIVITIES] Adminaccount debug - User ID:', currentUser._id);
      console.log('üë®‚Äçüíº [BACKOFFICE ACTIVITIES] Adminaccount debug - Query account filter:', query.account);
      
      // Verificar cu√°ntas actividades hay en total para esta divisi√≥n
      const totalActivities = await Activity.countDocuments({
        division: divisionId,
        activo: true
      });
      console.log('üë®‚Äçüíº [BACKOFFICE ACTIVITIES] Total actividades en divisi√≥n (sin filtro de cuenta):', totalActivities);
      
      // Verificar cu√°ntas actividades hay para la cuenta espec√≠fica
      if (query.account) {
        const accountActivities = await Activity.countDocuments({
          division: divisionId,
          activo: true,
          account: query.account
        });
        console.log('üë®‚Äçüíº [BACKOFFICE ACTIVITIES] Actividades para cuenta filtrada:', accountActivities);
        console.log('üë®‚Äçüíº [BACKOFFICE ACTIVITIES] Cuenta filtrada:', query.account);
      }
      
      // Verificar espec√≠ficamente la cuenta 68d9bb7b183e322dd4c7b516
      const specificAccountActivities = await Activity.countDocuments({
        division: divisionId,
        activo: true,
        account: '68d9bb7b183e322dd4c7b516'
      });
      console.log('üë®‚Äçüíº [BACKOFFICE ACTIVITIES] Actividades para cuenta espec√≠fica 68d9bb7b183e322dd4c7b516:', specificAccountActivities);
      
      // Verificar si la cuenta est√° en el filtro
      if (query.account && query.account.$in) {
        const isInFilter = query.account.$in.includes('68d9bb7b183e322dd4c7b516');
        console.log('üë®‚Äçüíº [BACKOFFICE ACTIVITIES] ¬øEst√° la cuenta 68d9bb7b183e322dd4c7b516 en el filtro?', isInFilter);
      }
      
      // Verificar espec√≠ficamente la actividad 68dc4cf8626391464e2baeff
      const specificActivity = await Activity.findById('68dc4cf8626391464e2baeff');
      if (specificActivity) {
        console.log('üë®‚Äçüíº [BACKOFFICE ACTIVITIES] Actividad espec√≠fica 68dc4cf8626391464e2baeff encontrada:', {
          id: specificActivity._id,
          titulo: specificActivity.titulo,
          account: specificActivity.account,
          division: specificActivity.division,
          activo: specificActivity.activo,
          estado: specificActivity.estado,
          fechaInicio: specificActivity.fechaInicio,
          fechaFin: specificActivity.fechaFin,
          createdAt: specificActivity.createdAt
        });
        
        // Verificar si cumple con cada condici√≥n del query
        const meetsDivision = specificActivity.division.toString() === divisionId;
        const meetsActive = specificActivity.activo === true;
        const meetsAccount = query.account ? 
          (query.account.$in ? query.account.$in.includes(specificActivity.account.toString()) : 
           query.account === specificActivity.account.toString()) : true;
        const meetsDateRange = specificActivity.fechaInicio <= fechaFin && specificActivity.fechaFin >= fechaInicio;
        const meetsCreatedAtRange = specificActivity.createdAt >= fechaInicioUTC && specificActivity.createdAt <= fechaFinUTC;
        
        console.log('üë®‚Äçüíº [BACKOFFICE ACTIVITIES] Condiciones para actividad 68dc4cf8626391464e2baeff:');
        console.log('  - Divisi√≥n correcta:', meetsDivision, '(esperada:', divisionId, ', actual:', specificActivity.division, ')');
        console.log('  - Activa:', meetsActive, '(actual:', specificActivity.activo, ')');
        console.log('  - Cuenta en filtro:', meetsAccount, '(filtro:', query.account, ', actual:', specificActivity.account, ')');
        console.log('  - Rango de fechas (fechaInicio/fechaFin):', meetsDateRange, '(fechaInicio:', specificActivity.fechaInicio, ', fechaFin:', specificActivity.fechaFin, ')');
        console.log('  - Rango de fechas (createdAt):', meetsCreatedAtRange, '(createdAt:', specificActivity.createdAt, ', rango UTC:', fechaInicioUTC, 'a', fechaFinUTC, ')');
        
        // Verificar si cumple con el query completo
        const meetsAllConditions = meetsDivision && meetsActive && meetsAccount && meetsDateRange && meetsCreatedAtRange;
        console.log('üë®‚Äçüíº [BACKOFFICE ACTIVITIES] ¬øCumple todas las condiciones?', meetsAllConditions);
      } else {
        console.log('üë®‚Äçüíº [BACKOFFICE ACTIVITIES] Actividad 68dc4cf8626391464e2baeff NO encontrada en la base de datos');
      }
      
      // Buscar actividades del 29 de septiembre espec√≠ficamente
      const actividades29 = await Activity.find({
        division: divisionId,
        activo: true,
        $or: [
          { fechaInicio: { $gte: new Date('2025-09-29T00:00:00.000Z'), $lt: new Date('2025-09-30T00:00:00.000Z') } },
          { fechaFin: { $gte: new Date('2025-09-29T00:00:00.000Z'), $lt: new Date('2025-09-30T00:00:00.000Z') } },
          { createdAt: { $gte: new Date('2025-09-29T00:00:00.000Z'), $lt: new Date('2025-09-30T00:00:00.000Z') } }
        ]
      });
      
      console.log('üë®‚Äçüíº [BACKOFFICE ACTIVITIES] Actividades del 29 de septiembre encontradas:', actividades29.length);
      actividades29.forEach((act, index) => {
        console.log(`üë®‚Äçüíº [BACKOFFICE ACTIVITIES] Actividad 29/${index + 1}:`, {
          id: act._id,
          titulo: act.titulo,
          account: act.account,
          fechaInicio: act.fechaInicio,
          fechaFin: act.fechaFin,
          createdAt: act.createdAt
        });
      });
    }

    // Obtener actividades
    const activities = await Activity.find(query)
      .populate('account', 'nombre razonSocial')
      .populate('division', 'nombre descripcion')
      .populate('usuario', 'name email')
      .populate('participantes', 'nombre apellido')
      .sort({ createdAt: -1 });

    console.log('üìÖ [BACKOFFICE ACTIVITIES] Actividades encontradas:', activities.length);
    
    // Log detallado de las actividades encontradas
    if (currentUser.role?.nombre === 'adminaccount') {
      console.log('üë®‚Äçüíº [BACKOFFICE ACTIVITIES] Detalle de actividades encontradas:');
      activities.forEach((activity, index) => {
        console.log(`üë®‚Äçüíº [BACKOFFICE ACTIVITIES] Actividad ${index + 1}:`, {
          id: activity._id,
          titulo: activity.titulo,
          account: activity.account?._id || activity.account,
          estado: activity.estado,
          activo: activity.activo
        });
      });
    }

    // Agrupar por fecha y generar URLs firmadas para las im√°genes
    const calendarData = {};
    
    for (const activity of activities) {
      const fecha = activity.createdAt.toISOString().split('T')[0];
      
      if (!calendarData[fecha]) {
        calendarData[fecha] = {
          fecha: fecha,
          totalActividades: 0,
          actividades: []
        };
      }
      
      // Generar URLs firmadas para las im√°genes y videos
      let imagenesSignedUrls = [];
      if (activity.imagenes && Array.isArray(activity.imagenes)) {
        try {
          const { generateSignedUrl } = require('./config/s3.config');
          imagenesSignedUrls = await Promise.all(activity.imagenes.map(async (mediaKey) => {
            // Generar URL firmada usando la key directamente
            const signedUrl = await generateSignedUrl(mediaKey, 172800); // 2 d√≠as
            return signedUrl;
          }));
        } catch (error) {
          console.error('Error generando URLs firmadas para actividad:', activity._id, error);
          imagenesSignedUrls = []; // No devolver URLs si falla
        }
      }
      
      calendarData[fecha].totalActividades++;
      calendarData[fecha].actividades.push({
        _id: activity._id,
        titulo: activity.titulo,
        descripcion: activity.descripcion,
        fecha: activity.createdAt.toISOString().split('T')[0],
        hora: activity.createdAt.toTimeString().split(' ')[0],
        lugar: activity.lugar || '',
        estado: activity.estado || 'publicada', // Actividades existentes sin estado se consideran publicadas
        categoria: activity.categoria || 'general',
        imagenes: imagenesSignedUrls,
        objetivos: activity.objetivos || [],
        materiales: activity.materiales || [],
        evaluacion: activity.evaluacion || '',
        observaciones: activity.observaciones || '',
        participantes: activity.participantes || [],
        creador: {
          name: activity.usuario?.name || 'Desconocido'
        },
        institucion: {
          _id: activity.account?._id,
          nombre: activity.account?.nombre || 'Sin instituci√≥n'
        },
        division: activity.division ? {
          _id: activity.division._id,
          nombre: activity.division.nombre
        } : null
      });
    }

    console.log('üìÖ [BACKOFFICE ACTIVITIES] Datos del calendario generados:', Object.keys(calendarData).length, 'd√≠as');

    res.json({
      success: true,
      data: calendarData
    });

  } catch (error) {
    console.error('Error obteniendo datos del calendario:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Endpoint para eliminar una actividad (solo adminaccount)
app.delete('/backoffice/actividades/:id', authenticateToken, async (req, res) => {
  try {
    console.log('üóëÔ∏è [BACKOFFICE DELETE] ===== INICIO DELETE ACTIVIDAD =====');
    console.log('üóëÔ∏è [BACKOFFICE DELETE] Headers:', req.headers);
    console.log('üóëÔ∏è [BACKOFFICE DELETE] Authorization:', req.headers.authorization);
    
    const { id } = req.params;
    const currentUser = req.user;
    
    console.log('üóëÔ∏è [BACKOFFICE DELETE] ID de actividad:', id);
    console.log('üóëÔ∏è [BACKOFFICE DELETE] Usuario autenticado:', currentUser);

    console.log('üóëÔ∏è [BACKOFFICE DELETE] Eliminando actividad:', id);
    console.log('üóëÔ∏è [BACKOFFICE DELETE] Usuario:', currentUser._id, currentUser.role?.nombre);
    console.log('üóëÔ∏è [BACKOFFICE DELETE] Role completo:', currentUser.role);
    console.log('üóëÔ∏è [BACKOFFICE DELETE] Role nombre:', currentUser.role?.nombre);
    console.log('üóëÔ∏è [BACKOFFICE DELETE] ¬øEs adminaccount?', currentUser.role?.nombre === 'adminaccount');

    // Verificar que solo adminaccount puede eliminar actividades
    if (currentUser.role?.nombre !== 'adminaccount') {
      console.log('üóëÔ∏è [BACKOFFICE DELETE] ERROR: Usuario no es adminaccount');
      console.log('üóëÔ∏è [BACKOFFICE DELETE] Role actual:', currentUser.role?.nombre);
      return res.status(403).json({ 
        success: false, 
        message: 'Solo los usuarios adminaccount pueden eliminar actividades' 
      });
    }

    // Verificar que la actividad existe
    const actividad = await Activity.findById(id);
    if (!actividad) {
      return res.status(404).json({ 
        success: false, 
        message: 'Actividad no encontrada' 
      });
    }

    // Verificar que la actividad pertenece a una cuenta asociada del usuario
    const userAccounts = await Shared.find({ 
      user: currentUser._id, 
      status: { $in: ['active', 'pending'] }
    }).select('account');
    
    const accountIds = userAccounts.map(ah => ah.account);
    
    console.log('üóëÔ∏è [BACKOFFICE DELETE] Cuentas asociadas del usuario:', accountIds);
    console.log('üóëÔ∏è [BACKOFFICE DELETE] Cuenta de la actividad:', actividad.account.toString());
    console.log('üóëÔ∏è [BACKOFFICE DELETE] Cuenta de la actividad (tipo):', typeof actividad.account);
    console.log('üóëÔ∏è [BACKOFFICE DELETE] Cuentas asociadas (tipos):', accountIds.map(id => typeof id));
    
    // Convertir todos a string para comparar correctamente
    const accountIdsString = accountIds.map(id => id.toString());
    const actividadAccountString = actividad.account.toString();
    
    console.log('üóëÔ∏è [BACKOFFICE DELETE] Cuentas asociadas (strings):', accountIdsString);
    console.log('üóëÔ∏è [BACKOFFICE DELETE] Cuenta de la actividad (string):', actividadAccountString);
    console.log('üóëÔ∏è [BACKOFFICE DELETE] ¬øPuede eliminar?', accountIdsString.includes(actividadAccountString));
    
    if (!accountIdsString.includes(actividadAccountString)) {
      console.log('üóëÔ∏è [BACKOFFICE DELETE] ERROR: No tiene permisos para eliminar esta actividad');
      return res.status(403).json({ 
        success: false, 
        message: 'No tienes permisos para eliminar esta actividad' 
      });
    }

    // Eliminar la actividad
    await Activity.findByIdAndDelete(id);

    console.log('üóëÔ∏è [BACKOFFICE DELETE] Actividad eliminada:', {
      id: id,
      titulo: actividad.titulo,
      account: actividad.account,
      eliminadoPor: currentUser._id
    });

    res.json({ 
      success: true, 
      message: 'Actividad eliminada correctamente' 
    });

  } catch (error) {
    console.error('Error eliminando actividad:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Error interno del servidor' 
    });
  }
});

// Endpoint para obtener actividades de un d√≠a espec√≠fico
app.get('/backoffice/actividades/day', authenticateToken, async (req, res) => {
  try {
    const { fecha, divisionId } = req.query;
    const currentUser = req.user;

    console.log('üìÖ [BACKOFFICE ACTIVITIES DAY] Obteniendo actividades del d√≠a');
    console.log('üìÖ [BACKOFFICE ACTIVITIES DAY] Fecha:', fecha);
    console.log('üìÖ [BACKOFFICE ACTIVITIES DAY] DivisionId:', divisionId);

    // Verificar permisos
    if (!['adminaccount', 'superadmin', 'coordinador'].includes(currentUser.role?.nombre)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver actividades'
      });
    }

    if (!fecha || !divisionId) {
      return res.status(400).json({
        success: false,
        message: 'fecha y divisionId son requeridos'
      });
    }

    // Construir query base seg√∫n el rol del usuario
    let query = {
      division: divisionId,
      activo: true
    };

    // Para adminaccount, no filtrar por estado (ver todas las actividades)
    if (currentUser.role?.nombre === 'adminaccount') {
      // Adminaccount puede ver todas las actividades sin filtro de estado
      console.log('üë®‚Äçüíº [BACKOFFICE ACTIVITIES DAY] Adminaccount - sin filtro de estado (ver todas)');
    } else {
      // Para otros roles, incluir filtro de estado
      query.$or = [
        { estado: { $exists: false } }, // Actividades sin estado (legacy)
        { estado: 'publicada' },
        { estado: 'borrador' }
      ];
    }

    // Filtro por cuenta seg√∫n el rol del usuario
    if (currentUser.role?.nombre === 'superadmin') {
      // Superadmin puede ver todas las actividades
    } else if (currentUser.role?.nombre === 'adminaccount') {
      // Adminaccount solo puede ver actividades de sus cuentas
      const userAccounts = await Shared.find({ 
        user: currentUser._id, 
        status: { $in: ['active', 'pending'] }
      }).select('account');
      
      const accountIds = userAccounts.map(ah => ah.account);
      query.account = { $in: accountIds };
    } else if (currentUser.role?.nombre === 'coordinador') {
      // Coordinador puede ver actividades de sus cuentas
      const userAccounts = await Shared.find({ 
        user: currentUser._id, 
        status: { $in: ['active', 'pending'] }
      }).select('account');
      
      const accountIds = userAccounts.map(ah => ah.account);
      query.account = { $in: accountIds };
    }

    // Filtro por fecha (todo el d√≠a)
    const startDate = new Date(fecha);
    const endDate = new Date(fecha);
    endDate.setDate(endDate.getDate() + 1);
    
    query.createdAt = {
      $gte: startDate,
      $lt: endDate
    };

    console.log('üìÖ [BACKOFFICE ACTIVITIES DAY] Query:', JSON.stringify(query, null, 2));

    // Obtener actividades
    const activities = await Activity.find(query)
      .populate('account', 'nombre razonSocial')
      .populate('division', 'nombre descripcion')
      .populate('usuario', 'name email')
      .populate('participantes', 'nombre apellido')
      .sort({ createdAt: -1 });

    console.log('üìÖ [BACKOFFICE ACTIVITIES DAY] Actividades encontradas:', activities.length);

    // Formatear actividades
    const formattedActivities = activities.map(activity => ({
      _id: activity._id,
      titulo: activity.titulo,
      descripcion: activity.descripcion,
      fecha: activity.createdAt.toISOString().split('T')[0],
      hora: activity.createdAt.toTimeString().split(' ')[0],
      lugar: activity.lugar || '',
      estado: activity.estado || 'activa',
      categoria: activity.categoria || 'general',
      imagenes: activity.imagenes || [],
      objetivos: activity.objetivos || [],
      materiales: activity.materiales || [],
      evaluacion: activity.evaluacion || '',
      observaciones: activity.observaciones || '',
      participantes: activity.participantes || [],
      creador: {
        name: activity.usuario?.name || 'Desconocido'
      },
      institucion: {
        _id: activity.account?._id,
        nombre: activity.account?.nombre || 'Sin instituci√≥n'
      },
      division: activity.division ? {
        _id: activity.division._id,
        nombre: activity.division.nombre
      } : null
    }));

    res.json({
      success: true,
      data: formattedActivities
    });

  } catch (error) {
    console.error('Error obteniendo actividades del d√≠a:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// ==================== ENDPOINTS PARA ALUMNOS ====================

// Endpoint para obtener alumnos por instituci√≥n y divisi√≥n
app.get('/students', authenticateToken, getCognitoUserInstitution, async (req, res) => {
  try {
    const { accountId, divisionId, year } = req.query;

    // Verificar permisos del usuario
    let currentUser;
    if (req.user.isCognitoUser) {
      currentUser = await User.findOne({ email: req.user.email }).populate('role');
    } else {
      const { userId } = req.user;
      currentUser = await User.findById(userId).populate('role');
    }

    if (!currentUser) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    // Construir query base
    const query = {};

    // Filtrar por rol
    if (currentUser.role?.nombre === 'superadmin') {
      // Superadmin puede ver todos los estudiantes
      if (accountId) query.account = accountId;
      if (divisionId) query.division = divisionId;
    } else if (currentUser.role?.nombre === 'adminaccount') {
      // Adminaccount solo puede ver estudiantes de su instituci√≥n
      if (req.userInstitution) {
        query.account = req.userInstitution._id;
        if (divisionId) query.division = divisionId;
      } else {
        return res.status(403).json({
          success: false,
          message: 'No tienes una instituci√≥n asignada'
        });
      }
    } else {
      // Otros roles requieren accountId y divisionId
      if (!accountId || !divisionId) {
        return res.status(400).json({
          success: false,
          message: 'accountId y divisionId son requeridos'
        });
      }

      // Verificar permisos
      if (!req.user.isCognitoUser) {
        const userAssociation = await Shared.findOne({
          user: currentUser._id,
          account: accountId,
          status: 'active'
        });

        if (!userAssociation) {
          return res.status(403).json({
            success: false,
            message: 'No tienes permisos para acceder a esta instituci√≥n'
          });
        }
      }

      query.account = accountId;
      query.division = divisionId;
    }

    if (year) {
      query.year = parseInt(year);
    }

    const students = await Student.find(query)
      .populate('account', 'nombre razonSocial')
      .populate('division', 'nombre descripcion')
      .sort({ apellido: 1, nombre: 1 });

    res.json({
      success: true,
      data: {
        students,
        total: students.length
      }
    });
  } catch (error) {
    console.error('Error obteniendo alumnos:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Endpoint para obtener alumnos por cuenta y divisi√≥n seleccionada
app.get('/students/by-account-division', authenticateToken, async (req, res) => {
  try {
    const { accountId, divisionId, year } = req.query;
    const { userId } = req.user;

    if (!accountId) {
      return res.status(400).json({
        success: false,
        message: 'accountId es requerido'
      });
    }

    // Verificar permisos del usuario para esta cuenta
    const userAssociation = await Shared.findOne({
      user: userId,
      account: accountId,
      status: 'active'
    });

    if (!userAssociation) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para acceder a esta instituci√≥n'
      });
    }

    // Construir query
    const query = {
      account: accountId
    };

    // Si se especifica divisi√≥n, filtrar por ella
    if (divisionId) {
      query.division = divisionId;
    }

    if (year) {
      query.year = parseInt(year);
    }

    const students = await Student.find(query)
      .populate('account', 'nombre razonSocial')
      .populate('division', 'nombre descripcion')
      .sort({ apellido: 1, nombre: 1 });

    // Procesar URLs de avatares para cada estudiante
    const studentsWithAvatarUrls = await Promise.all(students.map(async (student) => {
      const studentObj = student.toObject();
      
      if (student.avatar) {
        try {
          // Verificar si es una key de S3 para estudiantes
          if (student.avatar.includes('students/')) {
            // Es una key de S3 para estudiantes, generar URL firmada
            const { generateSignedUrl } = require('./config/s3.config');
            const signedUrl = await generateSignedUrl(student.avatar, 172800); // 2 d√≠as
            studentObj.avatar = signedUrl;
          } else if (!student.avatar.startsWith('http')) {
            // Es una key local, generar URL local
            const localUrl = `${req.protocol}://${req.get('host')}/uploads/${student.avatar.split('/').pop()}`;
            studentObj.avatar = localUrl;
          }
          // Si ya es una URL completa, no hacer nada
        } catch (error) {
          console.error('Error procesando avatar del estudiante:', student._id, error);
          // En caso de error, mantener el avatar original
        }
      }
      
      return studentObj;
    }));

    res.json({
      success: true,
      data: {
        students: studentsWithAvatarUrls,
        total: students.length
      }
    });
  } catch (error) {
    console.error('Error obteniendo alumnos por cuenta y divisi√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Endpoint para descargar plantilla de estudiantes
app.get('/students/template', authenticateToken, async (req, res) => {
  try {
    // Crear datos de ejemplo para la plantilla
    const templateData = [
      ['Nombre', 'Apellido', 'DNI', 'Email', 'A√±o', 'Nombre Tutor', 'Email Tutor', 'DNI Tutor'],
      ['Juan', 'P√©rez', '12345678', 'juan.perez@email.com', '2024', 'Carlos P√©rez', 'carlos.perez@email.com', '87654321'],
      ['Mar√≠a', 'Garc√≠a', '23456789', 'maria.garcia@email.com', '2024', 'Ana Garc√≠a', 'ana.garcia@email.com', '76543210'],
      ['Pedro', 'L√≥pez', '34567890', 'pedro.lopez@email.com', '2024', 'Luis L√≥pez', 'luis.lopez@email.com', '65432109']
    ];

    // Crear el workbook y worksheet
    const workbook = XLSX.utils.book_new();
    const worksheet = XLSX.utils.aoa_to_sheet(templateData);

    // Ajustar el ancho de las columnas
    worksheet['!cols'] = [
      { width: 15 }, // Nombre
      { width: 15 }, // Apellido
      { width: 12 }, // DNI
      { width: 25 }, // Email
      { width: 8 },  // A√±o
      { width: 15 }, // Nombre Tutor
      { width: 25 }, // Email Tutor
      { width: 12 }  // DNI Tutor
    ];

    // Agregar el worksheet al workbook
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Estudiantes');

    // Generar el buffer del archivo
    const buffer = XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' });

    // Configurar headers para la descarga
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    res.setHeader('Content-Disposition', 'attachment; filename="plantilla_estudiantes.xlsx"');
    res.setHeader('Content-Length', buffer.length);

    // Enviar el archivo
    res.send(buffer);

  } catch (error) {
    console.error('Error generando plantilla de estudiantes:', error);
    res.status(500).json({
      success: false,
      message: 'Error generando plantilla de estudiantes'
    });
  }
});

// Endpoint para cargar alumnos desde Excel
app.post('/students/upload-excel', authenticateToken, uploadExcel.single('excel'), async (req, res) => {
  try {
    console.log('üìÅ Archivo recibido:', req.file);
    console.log('üìã Body recibido:', req.body);
    
    const { accountId, divisionId, year } = req.body;
    const { userId } = req.user;

    if (!accountId || !divisionId || !year || !req.file) {
      console.log('‚ùå Datos faltantes:', { accountId, divisionId, year, hasFile: !!req.file });
      return res.status(400).json({
        success: false,
        message: 'accountId, divisionId, year y archivo Excel son requeridos'
      });
    }

    // Verificar permisos del usuario
    const user = await User.findById(userId).populate('role');
    const userAssociation = await Shared.findOne({
      user: userId,
      account: accountId,
      status: 'active'
    });

    if (!userAssociation && user.role?.nombre !== 'superadmin') {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para cargar alumnos en esta instituci√≥n'
      });
    }

    // Verificar que la instituci√≥n y divisi√≥n existen
    const account = await Account.findById(accountId);
    const division = await Grupo.findById(divisionId);

    if (!account || !division) {
      return res.status(404).json({
        success: false,
        message: 'Instituci√≥n o divisi√≥n no encontrada'
      });
    }

    // Procesar el archivo Excel
    console.log('üìñ Leyendo archivo Excel:', req.file.path);
    const workbook = XLSX.readFile(req.file.path);
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];
    const data = XLSX.utils.sheet_to_json(worksheet);
    console.log('üìä Datos extra√≠dos:', data.length, 'filas');

    const results = {
      success: 0,
      errors: [],
      total: data.length
    };

    // Procesar cada fila
    for (let i = 0; i < data.length; i++) {
      const row = data[i];
      const rowNumber = i + 2; // +2 porque Excel empieza en 1 y tenemos headers

      try {
        // Verificar si la fila est√° vac√≠a (todos los campos requeridos est√°n vac√≠os)
        const isRowEmpty = !row.nombre && !row.apellido && !row.dni && !row.dniTutor && !row.nombreTutor && !row.emailTutor;
        if (isRowEmpty) {
          continue; // Saltar filas completamente vac√≠as
        }

        // Validar campos requeridos del alumno
        if (!row.nombre || !row.apellido || !row.dni) {
          const missingFields = [];
          if (!row.nombre) missingFields.push('nombre');
          if (!row.apellido) missingFields.push('apellido');
          if (!row.dni) missingFields.push('dni');
          
          results.errors.push({
            row: rowNumber,
            error: `Faltan campos requeridos del alumno: ${missingFields.join(', ')}`
          });
          continue;
        }

        // Validar campos requeridos del tutor
        if (!row.dniTutor || !row.nombreTutor || !row.emailTutor) {
          const missingFields = [];
          if (!row.dniTutor) missingFields.push('dniTutor');
          if (!row.nombreTutor) missingFields.push('nombreTutor');
          if (!row.emailTutor) missingFields.push('emailTutor');
          
          results.errors.push({
            row: rowNumber,
            error: `Faltan campos requeridos del tutor: ${missingFields.join(', ')}`
          });
          continue;
        }

        // Validar formato de email solo si est√° presente
        if (row.email) {
          const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
          if (!emailRegex.test(row.email)) {
            results.errors.push({
              row: rowNumber,
              error: 'Formato de email inv√°lido'
            });
            continue;
          }
        }

        // Verificar si el alumno ya existe - SOLO por DNI
        const existingStudent = await Student.findOne({
          dni: String(row.dni).trim()
        });

        if (existingStudent) {
          results.errors.push({
            row: rowNumber,
            error: `Alumno ya existe con DNI ${String(row.dni).trim()}`
          });
          continue;
        }

        // Manejar el tutor
        let tutorUser = null;
        
        // Buscar si el tutor ya existe
        const existingTutor = await User.findOne({
          $or: [
            { email: String(row.emailTutor).toLowerCase().trim() },
            { dni: String(row.dniTutor).trim() }
          ]
        });

        if (existingTutor) {
          tutorUser = existingTutor;
          console.log(`‚úÖ Tutor encontrado: ${existingTutor.email}`);
          
          // Verificar si ya tiene una asociaci√≥n con esta cuenta y grupo
          const existingAssociation = await Shared.findOne({
            user: existingTutor._id,
            account: accountId,
            division: divisionId,
            status: 'active'
          });
          
          if (existingAssociation) {
            console.log(`‚ÑπÔ∏è Tutor ya tiene asociaci√≥n con esta cuenta y grupo`);
          } else {
            console.log(`‚ö†Ô∏è Tutor existe pero no tiene asociaci√≥n con esta cuenta/grupo`);
          }
        } else {
          // Crear nuevo tutor
          console.log(`üÜï Creando nuevo tutor: ${row.emailTutor}`);
          
          // Obtener el rol de tutor (usamos familyadmin que es el m√°s apropiado para padres/tutores)
          const tutorRole = await Role.findOne({ nombre: 'familyadmin' });
          if (!tutorRole) {
            results.errors.push({
              row: rowNumber,
              error: 'Rol de tutor no encontrado en el sistema'
            });
            continue;
          }

          // Generar contrase√±a aleatoria segura para el tutor
          const tutorPassword = generateRandomPassword(12);
          console.log('üîë [STUDENTS UPLOAD] Contrase√±a generada para tutor:', tutorPassword);

          // Crear el usuario tutor
          const tutorData = {
            name: String(row.nombreTutor).trim(),
            email: String(row.emailTutor).toLowerCase().trim(),
            password: tutorPassword, // Contrase√±a aleatoria segura
            role: tutorRole._id,
            status: 'approved', // Aprobado autom√°ticamente
            dni: String(row.dniTutor).trim()
          };

          tutorUser = new User(tutorData);
          await tutorUser.save();
          console.log(`‚úÖ Tutor creado: ${tutorUser.email}`);

          // Enviar email de bienvenida al nuevo tutor (as√≠ncrono)
          sendEmailAsync(
            emailService.sendNewUserCreatedEmail,
            emailService,
            {
              name: tutorUser.name,
              email: tutorUser.email
            },
            tutorData.password,
            account.nombre,
            'Tutor/Padre'
          );
          console.log(`üìß [STUDENTS UPLOAD] Email de bienvenida programado para env√≠o as√≠ncrono a: ${tutorUser.email}`);

          // La asociaci√≥n se crear√° despu√©s de crear el alumno
          console.log(`‚è≥ Asociaci√≥n del tutor se crear√° despu√©s de crear el alumno...`);
        }

        // Crear el alumno
        console.log(`üë§ Creando alumno...`);
        const studentData = {
          nombre: String(row.nombre).trim(),
          apellido: String(row.apellido).trim(),
          dni: String(row.dni).trim(),
          account: accountId,
          division: divisionId,
          year: parseInt(year),
          tutor: tutorUser._id, // Vincular al tutor
          createdBy: userId
        };
        
        // Solo agregar email si est√° presente
        if (row.email) {
          studentData.email = String(row.email).toLowerCase().trim();
        }
        
        console.log(`üìù Datos del alumno:`, studentData);
        const student = new Student(studentData);

        await student.save();
        console.log(`‚úÖ Alumno creado exitosamente: ${student.nombre} ${student.apellido}`);
        
        // Crear asociaci√≥n del tutor con instituci√≥n + grupo + alumno espec√≠fico
        console.log(`üîó Creando asociaci√≥n completa del tutor...`);
        
        // Verificar si ya existe una asociaci√≥n para este tutor con este alumno
        const existingStudentAssociation = await Shared.findOne({
          user: tutorUser._id,
          account: accountId,
          division: divisionId,
          student: student._id,
          status: 'active'
        });
        
        if (existingStudentAssociation) {
          console.log(`‚ÑπÔ∏è Asociaci√≥n tutor-alumno ya existe`);
        } else {
          await createAssociationByRole(
            tutorUser._id, 
            accountId, 
            'familyadmin', 
            divisionId, 
            student._id, 
            userId
          );

          // Enviar email de asociaci√≥n a instituci√≥n (solo si el tutor ya exist√≠a)
          if (existingTutor) {
            try {
              await emailService.sendInstitutionAssociationEmail(
                {
                  name: tutorUser.name,
                  email: tutorUser.email
                },
                account.nombre,
                division.nombre,
                'Tutor/Padre',
                {
                  nombre: student.nombre,
                  apellido: student.apellido,
                  dni: student.dni
                }
              );
              console.log(`üìß Email de asociaci√≥n enviado a: ${tutorUser.email}`);
            } catch (emailError) {
              console.error(`‚ùå Error enviando email de asociaci√≥n a ${tutorUser.email}:`, emailError.message);
              // No fallar la operaci√≥n por error de email
            }
          }
        }
        
        results.success++;

      } catch (error) {
        console.log(`‚ùå Error en fila ${rowNumber}:`, error.message);
        console.log(`‚ùå Stack trace:`, error.stack);
        results.errors.push({
          row: rowNumber,
          error: error.message
        });
      }
    }

    // Eliminar el archivo temporal
    fs.unlinkSync(req.file.path);

    res.json({
      success: true,
      message: `Carga completada. ${results.success} alumnos cargados exitosamente.`,
      data: results
    });

  } catch (error) {
    console.error('Error cargando alumnos desde Excel:', error);
    
    // Eliminar archivo temporal si existe
    if (req.file && fs.existsSync(req.file.path)) {
      fs.unlinkSync(req.file.path);
    }

    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Endpoint de prueba para descargar plantilla de coordinadores (sin auth)
app.get('/coordinators/template-test', async (req, res) => {
  try {
    console.log('üìÑ Generando plantilla de coordinadores (test)...');
    
    // Crear datos de ejemplo para la plantilla
    const templateData = [
      ['Nombre', 'Email', 'DNI'],
      ['Juan P√©rez', 'juan.perez@institucion.com', '12345678'],
      ['Mar√≠a Garc√≠a', 'maria.garcia@institucion.com', '87654321'],
      ['Carlos L√≥pez', 'carlos.lopez@institucion.com', '11223344']
    ];

    // Crear el workbook y worksheet
    const workbook = XLSX.utils.book_new();
    const worksheet = XLSX.utils.aoa_to_sheet(templateData);

    // Ajustar el ancho de las columnas
    worksheet['!cols'] = [
      { width: 20 }, // Nombre
      { width: 30 }, // Email
      { width: 15 }  // DNI
    ];

    // Agregar el worksheet al workbook
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Coordinadores');

    // Generar el archivo temporal
    const tempFilePath = path.join(__dirname, 'temp_template.xlsx');
    XLSX.writeFile(workbook, tempFilePath);

    console.log(`üìä Archivo generado: ${tempFilePath}`);

    // Leer el archivo y enviarlo
    const fileBuffer = fs.readFileSync(tempFilePath);
    
    // Configurar headers para la descarga
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    res.setHeader('Content-Disposition', 'attachment; filename="plantilla_coordinadores_test.xlsx"');
    res.setHeader('Content-Length', fileBuffer.length);
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Pragma', 'no-cache');

    // Enviar el archivo
    res.send(fileBuffer);
    
    // Limpiar archivo temporal
    fs.unlinkSync(tempFilePath);
    
    console.log('‚úÖ Plantilla enviada exitosamente');

  } catch (error) {
    console.error('‚ùå Error generando plantilla:', error);
    res.status(500).json({
      success: false,
      message: 'Error generando plantilla'
    });
  }
});

// Endpoint para descargar plantilla de coordinadores
app.get('/coordinators/template', authenticateToken, async (req, res) => {
  try {
    console.log('üìÑ Generando plantilla de coordinadores...');
    
    // Crear datos de ejemplo para la plantilla
    const templateData = [
      ['Nombre', 'Email', 'DNI'],
      ['Juan P√©rez', 'juan.perez@institucion.com', '12345678'],
      ['Mar√≠a Garc√≠a', 'maria.garcia@institucion.com', '87654321'],
      ['Carlos L√≥pez', 'carlos.lopez@institucion.com', '11223344']
    ];

    // Crear el workbook y worksheet
    const workbook = XLSX.utils.book_new();
    const worksheet = XLSX.utils.aoa_to_sheet(templateData);

    // Ajustar el ancho de las columnas
    worksheet['!cols'] = [
      { width: 20 }, // Nombre
      { width: 30 }, // Email
      { width: 15 }  // DNI
    ];

    // Agregar el worksheet al workbook
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Coordinadores');

    // Generar el buffer directamente
    const buffer = XLSX.write(workbook, { 
      type: 'buffer', 
      bookType: 'xlsx'
    });

    console.log(`üìä Archivo generado: ${buffer.length} bytes`);
    
    // Configurar headers para la descarga
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    res.setHeader('Content-Disposition', 'attachment; filename="plantilla_coordinadores.xlsx"');
    res.setHeader('Content-Length', buffer.length);
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Pragma', 'no-cache');

    // Enviar el archivo
    res.send(buffer);
    
    console.log('‚úÖ Plantilla enviada exitosamente');

  } catch (error) {
    console.error('‚ùå Error generando plantilla:', error);
    res.status(500).json({
      success: false,
      message: 'Error generando plantilla'
    });
  }
});

// Endpoint para cargar coordinadores desde Excel
app.post('/coordinators/upload-excel', authenticateToken, uploadExcel.single('file'), async (req, res) => {
  try {
    console.log('üìÅ [COORDINATORS UPLOAD] Iniciando carga de coordinadores...');
    console.log('üìÅ [COORDINATORS UPLOAD] Archivo recibido:', req.file ? 'S√≠' : 'No');
    console.log('üìÅ [COORDINATORS UPLOAD] Body recibido:', req.body);
    
    if (!req.file) {
      console.log('‚ùå [COORDINATORS UPLOAD] No se proporcion√≥ archivo');
      return res.status(400).json({
        success: false,
        message: 'No se ha proporcionado ning√∫n archivo'
      });
    }

    const { userId } = req.user;
    const { divisionId } = req.body; // ID de la divisi√≥n donde se cargar√°n los coordinadores

    console.log('üë§ [COORDINATORS UPLOAD] Usuario ID:', userId);
    console.log('üè´ [COORDINATORS UPLOAD] Divisi√≥n ID:', divisionId);

    if (!divisionId) {
      console.log('‚ùå [COORDINATORS UPLOAD] No se proporcion√≥ divisionId');
      return res.status(400).json({
        success: false,
        message: 'ID de divisi√≥n es requerido'
      });
    }

    // Verificar que la divisi√≥n existe
    const division = await Grupo.findById(divisionId);
    if (!division) {
      return res.status(404).json({
        success: false,
        message: 'Divisi√≥n no encontrada'
      });
    }

    // Verificar permisos del usuario
    const currentUser = await User.findById(userId).populate('role');
    if (!currentUser) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    // Solo superadmin y adminaccount pueden cargar coordinadores
    if (currentUser.role?.nombre !== 'superadmin' && currentUser.role?.nombre !== 'adminaccount') {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para cargar coordinadores'
      });
    }

    // Si es adminaccount, verificar que pertenece a la cuenta de la divisi√≥n
    if (currentUser.role?.nombre === 'adminaccount') {
      const userAssociation = await Shared.findOne({
        user: currentUser._id,
        account: division.cuenta,
        status: 'active'
      });

      if (!userAssociation) {
        return res.status(403).json({
          success: false,
          message: 'No tienes permisos para cargar coordinadores en esta divisi√≥n'
        });
      }
    }

    // Leer el archivo Excel
    console.log('üìñ [COORDINATORS UPLOAD] Leyendo archivo Excel:', req.file.path);
    const workbook = XLSX.readFile(req.file.path);
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];
    const data = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

    console.log('üìä [COORDINATORS UPLOAD] Datos extra√≠dos:', data.length, 'filas');
    console.log('üìã [COORDINATORS UPLOAD] Primera fila (encabezados):', data[0]);
    if (data.length > 1) {
      console.log('üìã [COORDINATORS UPLOAD] Segunda fila (primer dato):', data[1]);
    }

    // Validar que hay datos
    if (data.length < 2) {
      console.log('‚ùå [COORDINATORS UPLOAD] Archivo no tiene suficientes datos');
      return res.status(400).json({
        success: false,
        message: 'El archivo debe contener al menos una fila de datos (excluyendo encabezados)'
      });
    }

    const results = {
      success: 0,
      errors: []
    };

    // Obtener el rol de coordinador
    const coordinadorRole = await Role.findOne({ nombre: 'coordinador' });
    if (!coordinadorRole) {
      return res.status(500).json({
        success: false,
        message: 'Rol de coordinador no encontrado en el sistema'
      });
    }

    // Procesar cada fila (empezar desde la fila 2, saltando encabezados)
    console.log('üîÑ [COORDINATORS UPLOAD] Procesando filas...');
    for (let i = 1; i < data.length; i++) {
      const row = data[i];
      const rowNumber = i + 1;

      console.log(`üìù [COORDINATORS UPLOAD] Procesando fila ${rowNumber}:`, row);

      try {
        // Verificar si la fila est√° vac√≠a
        const isRowEmpty = !row[0] && !row[1] && !row[2];
        if (isRowEmpty) {
          console.log(`‚è≠Ô∏è [COORDINATORS UPLOAD] Fila ${rowNumber} est√° vac√≠a, saltando...`);
          continue;
        }

        // Extraer datos de la fila
        const nombre = String(row[0] || '').trim();
        const email = String(row[1] || '').toLowerCase().trim();
        const dni = String(row[2] || '').trim();

        console.log(`üìã [COORDINATORS UPLOAD] Fila ${rowNumber} - Datos extra√≠dos:`, {
          nombre,
          email,
          dni
        });

        // Validar campos requeridos
        if (!nombre || !email || !dni) {
          const missingFields = [];
          if (!nombre) missingFields.push('nombre');
          if (!email) missingFields.push('email');
          if (!dni) missingFields.push('dni');
          
          results.errors.push({
            row: rowNumber,
            error: `Faltan campos requeridos: ${missingFields.join(', ')}`
          });
          continue;
        }

        // Validar formato de email
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(email)) {
          results.errors.push({
            row: rowNumber,
            error: 'Formato de email inv√°lido'
          });
          continue;
        }

        // Verificar si el coordinador ya existe
        console.log(`üîç [COORDINATORS UPLOAD] Fila ${rowNumber} - Buscando coordinador existente...`);
        const existingCoordinator = await User.findOne({
          $or: [
            { email: email },
            { dni: dni }
          ]
        });

        let coordinatorUser = null;

        if (existingCoordinator) {
          coordinatorUser = existingCoordinator;
          console.log(`‚úÖ [COORDINATORS UPLOAD] Fila ${rowNumber} - Coordinador encontrado: ${existingCoordinator.email} (ID: ${existingCoordinator._id})`);
        } else {
          // Crear nuevo coordinador
          console.log(`üÜï Creando nuevo coordinador: ${email}`);
          
          // Generar contrase√±a aleatoria segura para el coordinador
          const coordinatorPassword = generateRandomPassword(12);
          console.log('üîë [COORDINATORS UPLOAD] Contrase√±a generada para coordinador:', coordinatorPassword);

          // Crear el usuario coordinador
          const coordinatorData = {
            name: nombre,
            email: email,
            password: coordinatorPassword, // Contrase√±a aleatoria segura
            role: coordinadorRole._id,
            status: 'approved', // Aprobado autom√°ticamente
            dni: dni
          };

          coordinatorUser = new User(coordinatorData);
          await coordinatorUser.save();
          console.log(`‚úÖ Coordinador creado: ${coordinatorUser.email}`);

          // Enviar email de bienvenida al nuevo coordinador (as√≠ncrono)
          const institutionName = division.cuenta ? (await Account.findById(division.cuenta)).nombre : 'Instituci√≥n';
          sendEmailAsync(
            emailService.sendNewUserCreatedEmail,
            emailService,
            {
              name: coordinatorUser.name,
              email: coordinatorUser.email
            },
            coordinatorData.password,
            institutionName,
            'Coordinador'
          );
          console.log(`üìß [COORDINATORS UPLOAD] Email de bienvenida programado para env√≠o as√≠ncrono a: ${coordinatorUser.email}`);
        }

        // Verificar qu√© asociaciones tiene el usuario en esta divisi√≥n
        console.log(`üîç [COORDINATORS UPLOAD] Fila ${rowNumber} - Verificando asociaciones existentes en esta divisi√≥n...`);
        const allUserAssociations = await Shared.find({
          user: coordinatorUser._id,
          account: division.cuenta,
          division: divisionId,
          status: 'active'
        }).populate('role', 'nombre');

        console.log(`üìã [COORDINATORS UPLOAD] Fila ${rowNumber} - Asociaciones existentes:`, allUserAssociations.map(assoc => ({
          id: assoc._id,
          role: assoc.role?.nombre,
          status: assoc.status
        })));

        // Verificar si ya existe una asociaci√≥n espec√≠ficamente como coordinador
        const existingCoordinatorAssociation = await Shared.findOne({
          user: coordinatorUser._id,
          account: division.cuenta,
          division: divisionId,
          role: coordinadorRole._id,
          status: 'active'
        });

        if (existingCoordinatorAssociation) {
          console.log(`‚ÑπÔ∏è [COORDINATORS UPLOAD] Fila ${rowNumber} - Coordinador ya tiene asociaci√≥n como coordinador con esta divisi√≥n (ID: ${existingCoordinatorAssociation._id})`);
        } else {
          // Crear asociaci√≥n del coordinador con instituci√≥n + divisi√≥n
          console.log(`üîó [COORDINATORS UPLOAD] Fila ${rowNumber} - Creando asociaci√≥n del coordinador...`);
          try {
            await createAssociationByRole(
              coordinatorUser._id,
              division.cuenta,
              'coordinador',
              divisionId,
              null,
              userId
            );
            console.log(`‚úÖ [COORDINATORS UPLOAD] Fila ${rowNumber} - Asociaci√≥n creada exitosamente`);
          } catch (associationError) {
            console.error(`‚ùå [COORDINATORS UPLOAD] Fila ${rowNumber} - Error creando asociaci√≥n:`, associationError);
            throw associationError;
          }

          // Enviar email de asociaci√≥n a instituci√≥n (solo si el coordinador ya exist√≠a)
          if (existingCoordinator) {
            try {
              const account = await Account.findById(division.cuenta);
              await emailService.sendInstitutionAssociationEmail(
                {
                  name: coordinatorUser.name,
                  email: coordinatorUser.email
                },
                account.nombre,
                division.nombre,
                'Coordinador'
              );
              console.log(`üìß Email de asociaci√≥n enviado a: ${coordinatorUser.email}`);
            } catch (emailError) {
              console.error(`‚ùå Error enviando email de asociaci√≥n a ${coordinatorUser.email}:`, emailError.message);
              // No fallar la operaci√≥n por error de email
            }
          }
        }

        results.success++;
        console.log(`‚úÖ [COORDINATORS UPLOAD] Fila ${rowNumber} - Procesada exitosamente`);

      } catch (error) {
        console.log(`‚ùå [COORDINATORS UPLOAD] Error en fila ${rowNumber}:`, error.message);
        console.log(`‚ùå [COORDINATORS UPLOAD] Stack trace:`, error.stack);
        results.errors.push({
          row: rowNumber,
          error: error.message
        });
      }
    }

    console.log(`üìä [COORDINATORS UPLOAD] Procesamiento completado:`, {
      success: results.success,
      errors: results.errors.length,
      total: data.length - 1
    });

    // Eliminar el archivo temporal
    console.log('üóëÔ∏è [COORDINATORS UPLOAD] Eliminando archivo temporal...');
    fs.unlinkSync(req.file.path);

    console.log('‚úÖ [COORDINATORS UPLOAD] Respuesta enviada:', {
      success: true,
      message: `Carga completada. ${results.success} coordinadores cargados exitosamente.`,
      data: results
    });

    res.json({
      success: true,
      message: `Carga completada. ${results.success} coordinadores cargados exitosamente.`,
      data: results
    });

  } catch (error) {
    console.error('Error cargando coordinadores desde Excel:', error);
    
    // Eliminar archivo temporal si existe
    if (req.file && fs.existsSync(req.file.path)) {
      fs.unlinkSync(req.file.path);
    }

    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Endpoint para obtener coordinadores por divisi√≥n
app.get('/coordinators/by-division/:divisionId', authenticateToken, getCognitoUserInstitution, async (req, res) => {
  try {
    const { divisionId } = req.params;
    const { userId } = req.user;

    console.log('üîç Obteniendo coordinadores para divisi√≥n:', divisionId);

    // Verificar que la divisi√≥n existe
    const division = await Grupo.findById(divisionId);
    if (!division) {
      return res.status(404).json({
        success: false,
        message: 'Divisi√≥n no encontrada'
      });
    }

    // Verificar permisos del usuario
    let currentUser;
    if (req.user.isCognitoUser) {
      // Para usuarios de Cognito, buscar por email
      currentUser = await User.findOne({ email: req.user.email }).populate('role');
    } else {
      // Para usuarios legacy, buscar por ID
      currentUser = await User.findById(userId).populate('role');
    }
    
    if (!currentUser) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    // Solo superadmin y adminaccount pueden ver coordinadores
    if (currentUser.role?.nombre !== 'superadmin' && currentUser.role?.nombre !== 'adminaccount') {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver coordinadores'
      });
    }

    // Si es adminaccount, verificar que pertenece a la cuenta de la divisi√≥n
    if (currentUser.role?.nombre === 'adminaccount') {
      // Verificar acceso a la divisi√≥n usando el middleware
      if (!await verifyDivisionAccess(req, divisionId)) {
        return res.status(403).json({
          success: false,
          message: 'No tienes permisos para ver coordinadores de esta divisi√≥n'
        });
      }
    }

    // Buscar todas las asociaciones de coordinadores para esta divisi√≥n
    const coordinadorAssociations = await Shared.find({
      division: divisionId,
      status: 'active'
    }).populate([
      {
        path: 'user',
        select: 'name email status createdAt'
      },
      {
        path: 'role',
        select: 'nombre descripcion'
      }
    ]);

    // Filtrar solo los coordinadores
    const coordinadores = coordinadorAssociations.filter(association => 
      association.role?.nombre === 'coordinador'
    );

    console.log(`üìä Encontrados ${coordinadores.length} coordinadores para la divisi√≥n ${division.nombre}`);

    res.json({
      success: true,
      data: {
        division: {
          _id: division._id,
          nombre: division.nombre,
          descripcion: division.descripcion
        },
        coordinadores: coordinadores.map(association => ({
          _id: association.user._id,
          nombre: association.user.name,
          email: association.user.email,
          activo: association.user.status === 'approved',
          asociacionId: association._id,
          fechaAsociacion: association.createdAt
        }))
      }
    });

  } catch (error) {
    console.error('Error obteniendo coordinadores por divisi√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Endpoint para obtener todos los coordinadores
app.get('/coordinators', authenticateToken, getCognitoUserInstitution, async (req, res) => {
  try {
    const { userId } = req.user;

    console.log('üîç Obteniendo todos los coordinadores...');
    console.log('üë§ Usuario del token:', req.user);
    console.log('üîç isCognitoUser:', req.user.isCognitoUser);
    console.log('üìß Email del usuario:', req.user.email);

    // Verificar permisos del usuario
    let currentUser;
    if (req.user.isCognitoUser) {
      // Para usuarios de Cognito, buscar por email
      console.log('üîç Buscando usuario de Cognito por email:', req.user.email);
      currentUser = await User.findOne({ email: req.user.email }).populate('role');
      console.log('üë§ Usuario encontrado en MongoDB:', currentUser ? 'S√≠' : 'No');
    } else {
      // Para usuarios legacy, buscar por ID
      console.log('üîç Buscando usuario legacy por ID:', userId);
      currentUser = await User.findById(userId).populate('role');
      console.log('üë§ Usuario legacy encontrado:', currentUser ? 'S√≠' : 'No');
    }
    
    if (!currentUser) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    // Solo superadmin y adminaccount pueden ver coordinadores
    if (currentUser.role?.nombre !== 'superadmin' && currentUser.role?.nombre !== 'adminaccount') {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver coordinadores'
      });
    }

    // Buscar todas las asociaciones de coordinadores
    let query = {
      status: 'active'
    };

    // Si es adminaccount, filtrar solo por sus cuentas
    if (currentUser.role?.nombre === 'adminaccount') {
      // Usar el middleware global para obtener la instituci√≥n
      if (req.userInstitution) {
        console.log('üè¢ Instituci√≥n del usuario:', req.userInstitution.nombre, req.userInstitution._id);
        
        // Filtrar coordinadores de esta cuenta
        query.account = req.userInstitution._id;
        console.log('üë• Filtrando coordinadores de la cuenta:', req.userInstitution._id);
      } else {
        console.log('‚ö†Ô∏è Usuario sin instituci√≥n asignada');
        query.account = null; // No mostrar coordinadores
      }
    }

    const coordinadorAssociations = await Shared.find(query).populate([
      {
        path: 'user',
        select: 'name email status createdAt'
      },
      {
        path: 'role',
        select: 'nombre descripcion'
      },
      {
        path: 'account',
        select: 'nombre razonSocial'
      },
      {
        path: 'division',
        select: 'nombre descripcion'
      }
    ]);

    // Filtrar solo los coordinadores
    const coordinadores = coordinadorAssociations.filter(association => 
      association.role?.nombre === 'coordinador'
    );

    console.log(`üìä Encontrados ${coordinadores.length} coordinadores totales`);

    res.json({
      success: true,
      data: {
        coordinadores: coordinadores.map(association => ({
          _id: association.user._id,
          nombre: association.user.name,
          email: association.user.email,
          activo: association.user.status === 'approved',
          asociacionId: association._id,
          fechaAsociacion: association.createdAt,
          division: association.division ? {
            _id: association.division._id,
            nombre: association.division.nombre,
            descripcion: association.division.descripcion
          } : null,
          account: association.account ? {
            _id: association.account._id,
            nombre: association.account.nombre,
            razonSocial: association.account.razonSocial
          } : null
        }))
      }
    });

  } catch (error) {
    console.error('Error obteniendo coordinadores:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Endpoint para obtener todos los tutores
app.get('/tutors', authenticateToken, getCognitoUserInstitution, async (req, res) => {
  try {
    console.log('üîç Obteniendo todos los tutores...');
    console.log('üîç [TUTORS] req.user:', req.user);
    console.log('üîç [TUTORS] req.userInstitution:', req.userInstitution);

    // Verificar permisos del usuario
    let currentUser;
    if (req.user.isCognitoUser) {
      // Para usuarios de Cognito, buscar por email
      console.log('üîç [TUTORS] Buscando usuario de Cognito por email:', req.user.email);
      currentUser = await User.findOne({ email: req.user.email }).populate('role');
      console.log('üîç [TUTORS] Usuario encontrado:', currentUser ? 'S√≠' : 'No');
    } else {
      // Para usuarios legacy, buscar por ID
      const { userId } = req.user;
      console.log('üîç [TUTORS] Buscando usuario legacy por ID:', userId);
      currentUser = await User.findById(userId).populate('role');
      console.log('üîç [TUTORS] Usuario encontrado:', currentUser ? 'S√≠' : 'No');
    }
    
    if (!currentUser) {
      console.log('‚ùå [TUTORS] Usuario no encontrado');
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    // Solo superadmin y adminaccount pueden ver tutores
    if (currentUser.role?.nombre !== 'superadmin' && currentUser.role?.nombre !== 'adminaccount') {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver tutores'
      });
    }

    // Buscar todas las asociaciones de tutores
    let query = {
      status: 'active'
    };

    // Si es adminaccount, filtrar solo por sus cuentas
    if (currentUser.role?.nombre === 'adminaccount') {
      // Usar el middleware global para obtener la instituci√≥n
      if (req.userInstitution) {
        console.log('üè¢ Instituci√≥n del usuario:', req.userInstitution.nombre, req.userInstitution._id);
        
        // Filtrar tutores de esta cuenta
        query.account = req.userInstitution._id;
        console.log('üë• Filtrando tutores de la cuenta:', req.userInstitution._id);
      } else {
        console.log('‚ö†Ô∏è Usuario sin instituci√≥n asignada');
        query.account = null; // No mostrar tutores
      }
    }

    const tutorAssociations = await Shared.find(query).populate([
      {
        path: 'user',
        select: 'name email status createdAt'
      },
      {
        path: 'role',
        select: 'nombre descripcion'
      },
      {
        path: 'account',
        select: 'nombre razonSocial'
      },
      {
        path: 'division',
        select: 'nombre descripcion'
      },
      {
        path: 'student',
        select: 'nombre apellido'
      }
    ]);

    // Filtrar solo los tutores (familyadmin) y que tengan usuario v√°lido
    const tutores = tutorAssociations.filter(association => 
      association.role?.nombre === 'familyadmin' && association.user
    );

    console.log(`üìä Encontrados ${tutores.length} tutores totales`);

    res.json({
      success: true,
      data: {
        tutores: tutores.map(association => ({
          _id: association.user?._id || null,
          nombre: association.user?.name || 'N/A',
          email: association.user?.email || 'N/A',
          activo: association.user?.status === 'approved',
          asociacionId: association._id,
          fechaAsociacion: association.createdAt,
          division: association.division ? {
            _id: association.division._id,
            nombre: association.division.nombre,
            descripcion: association.division.descripcion
          } : null,
          account: association.account ? {
            _id: association.account._id,
            nombre: association.account.nombre,
            razonSocial: association.account.razonSocial
          } : null,
          student: association.student ? {
            _id: association.student._id,
            nombre: association.student.nombre,
            apellido: association.student.apellido
          } : null
        }))
      }
    });

  } catch (error) {
    console.error('Error obteniendo tutores:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Endpoint para obtener tutores por divisi√≥n
app.get('/tutors/by-division/:divisionId', authenticateToken, getCognitoUserInstitution, async (req, res) => {
  try {
    const { divisionId } = req.params;
    const { userId } = req.user;

    console.log('üîç Obteniendo tutores para divisi√≥n:', divisionId);

    // Verificar que la divisi√≥n existe
    const division = await Grupo.findById(divisionId);
    if (!division) {
      return res.status(404).json({
        success: false,
        message: 'Divisi√≥n no encontrada'
      });
    }

    // Verificar permisos del usuario
    let currentUser;
    if (req.user.isCognitoUser) {
      // Para usuarios de Cognito, buscar por email
      currentUser = await User.findOne({ email: req.user.email }).populate('role');
    } else {
      // Para usuarios legacy, buscar por ID
      currentUser = await User.findById(userId).populate('role');
    }
    
    if (!currentUser) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    // Solo superadmin y adminaccount pueden ver tutores
    if (currentUser.role?.nombre !== 'superadmin' && currentUser.role?.nombre !== 'adminaccount') {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver tutores'
      });
    }

    // Si es adminaccount, verificar que pertenece a la cuenta de la divisi√≥n
    if (currentUser.role?.nombre === 'adminaccount') {
      // Verificar acceso a la divisi√≥n usando el middleware
      if (!await verifyDivisionAccess(req, divisionId)) {
        return res.status(403).json({
          success: false,
          message: 'No tienes permisos para ver tutores de esta divisi√≥n'
        });
      }
    }

    // Buscar todas las asociaciones de tutores para esta divisi√≥n
    const tutorAssociations = await Shared.find({
      division: divisionId,
      status: 'active'
    }).populate([
      {
        path: 'user',
        select: 'name email status createdAt'
      },
      {
        path: 'role',
        select: 'nombre descripcion'
      },
      {
        path: 'student',
        select: 'nombre apellido'
      }
    ]);

    // Filtrar solo los tutores (familyadmin) y que tengan usuario v√°lido
    const tutores = tutorAssociations.filter(association => 
      association.role?.nombre === 'familyadmin' && association.user
    );

    console.log(`üìä Encontrados ${tutores.length} tutores para la divisi√≥n ${division.nombre}`);

    res.json({
      success: true,
      data: {
        division: {
          _id: division._id,
          nombre: division.nombre,
          descripcion: division.descripcion
        },
        tutores: tutores.map(association => ({
          _id: association.user?._id || null,
          nombre: association.user?.name || 'N/A',
          email: association.user?.email || 'N/A',
          activo: association.user?.status === 'approved',
          asociacionId: association._id,
          fechaAsociacion: association.createdAt,
          student: association.student ? {
            _id: association.student._id,
            nombre: association.student.nombre,
            apellido: association.student.apellido
          } : null
        }))
      }
    });

  } catch (error) {
    console.error('Error obteniendo tutores por divisi√≥n:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Endpoint para eliminar alumno
app.delete('/students/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { userId } = req.user;

    // Verificar que el alumno existe
    const student = await Student.findById(id);

    if (!student) {
      return res.status(404).json({
        success: false,
        message: 'Alumno no encontrado'
      });
    }

    // Verificar permisos
    const user = await User.findById(userId).populate('role');
    const userAssociation = await Shared.findOne({
      user: userId,
      account: student.account,
      status: 'active'
    });

    if (!userAssociation && user.role?.nombre !== 'superadmin') {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para eliminar este alumno'
      });
    }

    // Eliminar el alumno completamente de la base de datos
    await Student.findByIdAndDelete(id);

    res.json({
      success: true,
      message: 'Alumno eliminado correctamente'
    });
  } catch (error) {
    console.error('Error eliminando alumno:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Endpoint para guardar asistencia
app.post('/asistencia', authenticateToken, async (req, res) => {
  try {
    console.log('üöÄ [ASISTENCIA] Iniciando endpoint de asistencia...');
    console.log('üì• Datos recibidos en /api/asistencia:', JSON.stringify(req.body, null, 2));
    console.log('üë§ Usuario:', req.user);
    
    const { accountId, divisionId, estudiantes, retiradas } = req.body;
    const { userId } = req.user;

    console.log('üîç [ASISTENCIA] Validando datos b√°sicos...');
    console.log('üîç [ASISTENCIA] accountId:', accountId);
    console.log('üîç [ASISTENCIA] divisionId:', divisionId);
    console.log('üîç [ASISTENCIA] estudiantes:', estudiantes);
    console.log('üîç [ASISTENCIA] retiradas:', retiradas);

    // Validaciones b√°sicas
    console.log('üîç [ASISTENCIA] Validaciones b√°sicas...');
    console.log('üîç [ASISTENCIA] accountId existe:', !!accountId);
    console.log('üîç [ASISTENCIA] divisionId existe:', !!divisionId);
    console.log('üîç [ASISTENCIA] estudiantes existe:', !!estudiantes);
    console.log('üîç [ASISTENCIA] estudiantes es array:', Array.isArray(estudiantes));
    
    if (!accountId || !divisionId || !estudiantes || !Array.isArray(estudiantes)) {
      console.log('‚ùå [ASISTENCIA] Validaci√≥n b√°sica fall√≥');
      return res.status(400).json({
        success: false,
        message: 'accountId, divisionId y estudiantes (array) son requeridos'
      });
    }
    
    console.log('‚úÖ [ASISTENCIA] Validaciones b√°sicas pasaron, continuando...');
    console.log('üîç [ASISTENCIA] Llegando a validaci√≥n de cuenta...');

    // Verificar que la cuenta existe
    console.log('üîç [ASISTENCIA] accountId recibido:', accountId, typeof accountId);
    console.log('üîç [ASISTENCIA] Modelo Account disponible:', !!Account);
    console.log('üîç [ASISTENCIA] Iniciando b√∫squeda de cuenta...');
    try {
      const account = await Account.findById(accountId);
      console.log('üîç [ASISTENCIA] Resultado de Account.findById:', account);
      if (!account) {
        console.log('‚ùå [ASISTENCIA] Cuenta no encontrada para ID:', accountId);
        return res.status(400).json({
          success: false,
          message: 'La cuenta especificada no existe'
        });
      }
      console.log('‚úÖ [ASISTENCIA] Cuenta encontrada:', account.nombre);
    } catch (e) {
      console.error('‚ùå [ASISTENCIA] Error en Account.findById:', e);
      return res.status(500).json({
        success: false,
        message: 'Error buscando la cuenta',
        error: e.message
      });
    }

    // Verificar que la divisi√≥n existe
    const division = await Grupo.findById(divisionId);
    if (!division) {
      return res.status(400).json({
        success: false,
        message: 'La divisi√≥n especificada no existe'
      });
    }

    // Verificar permisos del usuario
    const userAssociation = await Shared.findOne({
      user: userId,
      account: accountId,
      status: 'active'
    });

    if (!userAssociation) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para registrar asistencia en esta cuenta'
      });
    }

    // Verificar que todos los estudiantes existen y pertenecen a la divisi√≥n
    const studentIds = estudiantes.map(e => e.studentId);
    const students = await Student.find({
      _id: { $in: studentIds },
      account: accountId,
      division: divisionId
    });

    if (students.length !== estudiantes.length) {
      return res.status(400).json({
        success: false,
        message: 'Algunos estudiantes no existen o no pertenecen a la divisi√≥n especificada'
      });
    }

    // Crear fecha para el d√≠a actual (solo fecha, sin hora)
    const today = new Date();
    const yyyy = today.getFullYear();
    const mm = String(today.getMonth() + 1).padStart(2, '0');
    const dd = String(today.getDate()).padStart(2, '0');
    const fechaStr = `${yyyy}-${mm}-${dd}`;

    // Verificar si ya existe una asistencia para hoy
    const existingAsistencia = await Asistencia.findOne({
      account: accountId,
      division: divisionId,
      fecha: fechaStr
    });

    if (existingAsistencia) {
      // Actualizar la asistencia existente
      existingAsistencia.estudiantes = estudiantes.map(e => {
        const studentData = {
          student: e.studentId,
          presente: e.presente
        };
        
        // Agregar informaci√≥n de retirada si existe
        if (retiradas && retiradas[e.studentId]) {
          const retirada = retiradas[e.studentId];
          studentData.retirado = true;
          studentData.retiradoPor = retirada.withdrawnBy;
          studentData.retiradoPorNombre = retirada.withdrawnByName;
          studentData.retiradoEn = new Date();
        }
        
        return studentData;
      });
      
      await existingAsistencia.save();
      
      // Contar estudiantes presentes
      const presentes = estudiantes.filter(e => e.presente).length;
      const total = estudiantes.length;

      // return res.status(200).json({
        success: true,
        message: `Asistencia actualizada exitosamente. ${presentes} de ${total} estudiantes presentes.`,
        data: {
          id: existingAsistencia._id,
          fecha: existingAsistencia.fecha,
          total: total,
          presentes: presentes
        }
      });
    }

    // Crear el registro de asistencia
    const asistenciaData = {
      account: accountId,
      division: divisionId,
      fecha: fechaStr,
      estudiantes: estudiantes.map(e => {
        const studentData = {
          student: e.studentId,
          presente: e.presente
        };
        
        // Agregar informaci√≥n de retirada si existe
        if (retiradas && retiradas[e.studentId]) {
          const retirada = retiradas[e.studentId];
          studentData.retirado = true;
          studentData.retiradoPor = retirada.withdrawnBy;
          studentData.retiradoPorNombre = retirada.withdrawnByName;
          studentData.retiradoEn = new Date();
        }
        
        return studentData;
      }),
      creadoPor: userId
    };

    const asistencia = new Asistencia(asistenciaData);
    await asistencia.save();

    // Contar estudiantes presentes
    const presentes = estudiantes.filter(e => e.presente).length;
    const total = estudiantes.length;

    res.status(201).json({
      success: true,
      message: `Asistencia guardada exitosamente. ${presentes} de ${total} estudiantes presentes.`,
      data: {
        id: asistencia._id,
        fecha: asistencia.fecha,
        total: total,
        presentes: presentes
      }
    });

  } catch (error) {
    console.error('‚ùå [ASISTENCIA] Error general en endpoint:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Middleware de manejo de errores
app.use((err, req, res, next) => {
  console.error('Error:', err);
  res.status(500).json({
    success: false,
    message: 'Error interno del servidor'
  });
});

// Obtener asistencia por cuenta, divisi√≥n y fecha
app.get('/asistencia/by-date', authenticateToken, async (req, res) => {
  try {
    const { accountId, divisionId, date } = req.query;
    if (!accountId || !divisionId) {
      return res.status(400).json({ success: false, message: 'accountId y divisionId son requeridos' });
    }
    
    console.log('üîç [GET ASISTENCIA] Par√°metros recibidos:', { accountId, divisionId, date });
    
    const fechaStr = date || new Date().toISOString().split('T')[0];
    
    console.log('üîç [GET ASISTENCIA] fechaStr:', fechaStr);
    
    const asistencia = await Asistencia.findOne({
      account: accountId,
      division: divisionId,
      fecha: fechaStr
    });
    
    console.log('üîç [GET ASISTENCIA] Resultado de b√∫squeda:', asistencia);
    
    if (!asistencia) {
      console.log('üîç [GET ASISTENCIA] No se encontr√≥ asistencia');
      return res.json({ success: true, data: null });
    }
    
    console.log('üîç [GET ASISTENCIA] Asistencia encontrada:', asistencia);
    res.json({ success: true, data: asistencia });
  } catch (error) {
    console.error('‚ùå [GET ASISTENCIA] Error:', error);
    res.status(500).json({ success: false, message: 'Error interno', error: error.message });
  }
});

// ==================== ENDPOINTS DE RETIRADAS ====================

// Guardar retirada individual
app.post('/asistencia/retirada', authenticateToken, async (req, res) => {
  try {
    console.log('üöÄ [RETIRADA] Iniciando endpoint de retirada...');
    console.log('üì• Datos recibidos en /api/asistencia/retirada:', JSON.stringify(req.body, null, 2));
    
    const { accountId, divisionId, studentId, withdrawnBy, withdrawnByName } = req.body;
    const { userId } = req.user;

    console.log('üîç [RETIRADA] Validando datos b√°sicos...');
    console.log('üîç [RETIRADA] accountId:', accountId);
    console.log('üîç [RETIRADA] divisionId:', divisionId);
    console.log('üîç [RETIRADA] studentId:', studentId);
    console.log('üîç [RETIRADA] withdrawnBy:', withdrawnBy);
    console.log('üîç [RETIRADA] withdrawnByName:', withdrawnByName);

    // Validaciones b√°sicas
    if (!accountId || !divisionId || !studentId || !withdrawnBy || !withdrawnByName) {
      return res.status(400).json({
        success: false,
        message: 'accountId, divisionId, studentId, withdrawnBy y withdrawnByName son requeridos'
      });
    }

    // Verificar que la cuenta existe
    const account = await Account.findById(accountId);
    if (!account) {
      return res.status(400).json({
        success: false,
        message: 'La cuenta especificada no existe'
      });
    }

    // Verificar que la divisi√≥n existe
    const division = await Grupo.findById(divisionId);
    if (!division) {
      return res.status(400).json({
        success: false,
        message: 'La divisi√≥n especificada no existe'
      });
    }

    // Verificar que el estudiante existe y pertenece a la divisi√≥n
    const student = await Student.findOne({
      _id: studentId,
      account: accountId,
      division: divisionId
    });

    if (!student) {
      return res.status(400).json({
        success: false,
        message: 'El estudiante no existe o no pertenece a la divisi√≥n especificada'
      });
    }

    // Verificar permisos del usuario
    const userAssociation = await Shared.findOne({
      user: userId,
      account: accountId,
      status: 'active'
    });

    if (!userAssociation) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para registrar retiradas en esta cuenta'
      });
    }

    // Crear fecha para el d√≠a actual
    const today = new Date();
    const yyyy = today.getFullYear();
    const mm = String(today.getMonth() + 1).padStart(2, '0');
    const dd = String(today.getDate()).padStart(2, '0');
    const fechaStr = `${yyyy}-${mm}-${dd}`;

    // Buscar o crear asistencia para hoy
    let asistencia = await Asistencia.findOne({
      account: accountId,
      division: divisionId,
      fecha: fechaStr
    });

    if (!asistencia) {
      // Crear nueva asistencia
      asistencia = new Asistencia({
        account: accountId,
        division: divisionId,
        fecha: fechaStr,
        estudiantes: [],
        creadoPor: userId
      });
    }

    // Buscar el estudiante en la asistencia
    let studentIndex = asistencia.estudiantes.findIndex(
      e => e.student.toString() === studentId
    );

    if (studentIndex === -1) {
      // Agregar el estudiante a la asistencia
      asistencia.estudiantes.push({
        student: studentId,
        presente: true, // Asumimos que est√° presente si se est√° retirando
        retirado: true,
        retiradoPor: withdrawnBy,
        retiradoPorNombre: withdrawnByName,
        retiradoEn: new Date()
      });
    } else {
      // Actualizar el estudiante existente
      asistencia.estudiantes[studentIndex].retirado = true;
      asistencia.estudiantes[studentIndex].retiradoPor = withdrawnBy;
      asistencia.estudiantes[studentIndex].retiradoPorNombre = withdrawnByName;
      asistencia.estudiantes[studentIndex].retiradoEn = new Date();
    }

    await asistencia.save();

    console.log('‚úÖ [RETIRADA] Retirada guardada exitosamente');

    res.json({
      success: true,
      message: 'Retirada registrada exitosamente',
      data: {
        studentId,
        withdrawnBy,
        withdrawnByName,
        retiradoEn: new Date()
      }
    });

  } catch (error) {
    console.error('‚ùå [RETIRADA] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor',
      error: error.message
    });
  }
});

// ==================== ENDPOINTS DE ASISTENCIAS PARA FAMILIARES ====================

// Obtener asistencias de un alumno espec√≠fico para familiares
app.get('/asistencia/student-attendance', authenticateToken, async (req, res) => {
  try {
    console.log('üöÄ [STUDENT ATTENDANCE] Iniciando endpoint...');
    console.log('üì• Par√°metros recibidos:', req.query);
    
    const { studentId, accountId, startDate, endDate } = req.query;
    const { userId } = req.user;

    // Validaciones b√°sicas
    if (!studentId || !accountId || !startDate || !endDate) {
      return res.status(400).json({
        success: false,
        message: 'studentId, accountId, startDate y endDate son requeridos'
      });
    }

    // Verificar que el usuario tiene permisos para ver este alumno
    const userAssociation = await Shared.findOne({
      user: userId,
      student: studentId,
      account: accountId,
      status: 'active'
    });

    if (!userAssociation) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver las asistencias de este alumno'
      });
    }

    // Buscar asistencias en el rango de fechas
    const asistencias = await Asistencia.find({
      account: accountId,
      fecha: {
        $gte: startDate,
        $lte: endDate
      }
    }).populate('estudiantes.student', 'nombre apellido');

    // Filtrar solo las asistencias del alumno espec√≠fico
    const studentAttendances = [];
    
    asistencias.forEach(asistencia => {
      const studentAttendance = asistencia.estudiantes.find(
        e => e.student._id.toString() === studentId
      );
      
      if (studentAttendance) {
        studentAttendances.push({
          _id: asistencia._id,
          fecha: asistencia.fecha,
          presente: studentAttendance.presente,
          retirado: studentAttendance.retirado || false,
          retiradoPor: studentAttendance.retiradoPor || null,
          retiradoPorNombre: studentAttendance.retiradoPorNombre || null,
          retiradoEn: studentAttendance.retiradoEn || null,
          ingresoEn: studentAttendance.ingresoEn || asistencia.createdAt || null
        });
      }
    });

    // Obtener informaci√≥n del alumno
    const student = await Student.findById(studentId)
      .populate('account', 'nombre')
      .populate('division', 'nombre');

    if (!student) {
      return res.status(404).json({
        success: false,
        message: 'Alumno no encontrado'
      });
    }

    console.log('‚úÖ [STUDENT ATTENDANCE] Asistencias encontradas:', studentAttendances.length);

    res.json({
      success: true,
      data: {
        student: {
          _id: student._id,
          nombre: student.nombre,
          apellido: student.apellido
        },
        attendances: studentAttendances
      }
    });

  } catch (error) {
    console.error('‚ùå [STUDENT ATTENDANCE] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor',
      error: error.message
    });
  }
});

// ==================== ENDPOINTS DE C√ìDIGOS QR ====================

// Generar c√≥digos QR para estudiantes que no los tengan
app.post('/students/generate-qr-codes', authenticateToken, async (req, res) => {
  try {
    const { accountId, divisionId } = req.body;
    
    if (!accountId || !divisionId) {
      return res.status(400).json({ 
        success: false, 
        message: 'accountId y divisionId son requeridos' 
      });
    }

    // Buscar estudiantes sin c√≥digo QR
    const studentsWithoutQR = await Student.find({
      account: accountId,
      division: divisionId,
      $or: [
        { qrCode: { $exists: false } },
        { qrCode: null },
        { qrCode: '' }
      ]
    });

    console.log(`üîç [QR GENERATION] Estudiantes sin QR encontrados: ${studentsWithoutQR.length}`);

    let generatedCount = 0;
    const results = [];

    for (const student of studentsWithoutQR) {
      try {
        // Generar c√≥digo QR √∫nico
        let qrCode;
        let attempts = 0;
        const maxAttempts = 10;

        do {
          qrCode = student.generateQRCode();
          attempts++;
          
          // Verificar que no exista otro estudiante con el mismo c√≥digo
          const existingStudent = await Student.findOne({ qrCode });
          if (!existingStudent) {
            break;
          }
        } while (attempts < maxAttempts);

        if (attempts >= maxAttempts) {
          console.error(`‚ùå [QR GENERATION] No se pudo generar c√≥digo √∫nico para estudiante ${student._id}`);
          results.push({
            studentId: student._id,
            studentName: student.getFullName(),
            success: false,
            error: 'No se pudo generar c√≥digo √∫nico'
          });
          continue;
        }

        // Actualizar el estudiante con el c√≥digo QR
        student.qrCode = qrCode;
        await student.save();

        generatedCount++;
        results.push({
          studentId: student._id,
          studentName: student.getFullName(),
          qrCode: qrCode,
          success: true
        });

        console.log(`‚úÖ [QR GENERATION] C√≥digo generado para ${student.getFullName()}: ${qrCode}`);

      } catch (error) {
        console.error(`‚ùå [QR GENERATION] Error generando QR para estudiante ${student._id}:`, error);
        results.push({
          studentId: student._id,
          studentName: student.getFullName(),
          success: false,
          error: error.message
        });
      }
    }

    res.json({
      success: true,
      data: {
        totalProcessed: studentsWithoutQR.length,
        generatedCount: generatedCount,
        results: results
      }
    });

  } catch (error) {
    console.error('‚ùå [QR GENERATION] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor',
      error: error.message
    });
  }
});

// Buscar estudiante por c√≥digo QR
app.get('/students/by-qr/:qrCode', authenticateToken, async (req, res) => {
  try {
    const { qrCode } = req.params;
    
    if (!qrCode) {
      return res.status(400).json({ 
        success: false, 
        message: 'C√≥digo QR es requerido' 
      });
    }

    const student = await Student.findOne({ qrCode })
      .populate('account', 'nombre razonSocial')
      .populate('division', 'nombre descripcion');

    if (!student) {
      return res.status(404).json({
        success: false,
        message: 'Estudiante no encontrado'
      });
    }

    res.json({
      success: true,
      data: {
        _id: student._id,
        nombre: student.nombre,
        apellido: student.apellido,
        dni: student.dni,
        email: student.email,
        account: student.account,
        division: student.division,
        qrCode: student.qrCode
      }
    });

  } catch (error) {
    console.error('‚ùå [QR SEARCH] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor',
      error: error.message
    });
  }
});

// Obtener contactos autorizados para retirada de un estudiante
app.get('/pickups/by-student/:studentId', authenticateToken, async (req, res) => {
  try {
    const { studentId } = req.params;
    
    if (!studentId) {
      return res.status(400).json({ 
        success: false, 
        message: 'ID del estudiante es requerido' 
      });
    }

    // Buscar contactos autorizados para el estudiante
    const pickups = await Pickup.find({ student: studentId })
      .select('nombre telefono relacion activo')
      .sort({ nombre: 1 });

    // Filtrar solo los activos
    const activePickups = pickups.filter(pickup => pickup.activo !== false);

    res.json({
      success: true,
      data: activePickups.map(pickup => ({
        _id: pickup._id,
        nombre: pickup.nombre,
        telefono: pickup.telefono,
        relacion: pickup.relacion
      }))
    });

  } catch (error) {
    console.error('‚ùå [PICKUPS BY STUDENT] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor',
      error: error.message
    });
  }
});

// Obtener un estudiante espec√≠fico con informaci√≥n de tutores
app.get('/students/:studentId', authenticateToken, async (req, res) => {
  try {
    const { studentId } = req.params;
    
    if (!studentId) {
      return res.status(400).json({ 
        success: false, 
        message: 'ID del estudiante es requerido' 
      });
    }

    const student = await Student.findById(studentId)
      .populate('account', 'nombre razonSocial')
      .populate('division', 'nombre descripcion');

    if (!student) {
      return res.status(404).json({
        success: false,
        message: 'Estudiante no encontrado'
      });
    }

    // Buscar tutores asociados al estudiante
    const tutors = await Shared.find({
      student: studentId,
      status: 'active'
    })
    .populate('user', 'name email')
    .populate('role', 'nombre descripcion');

    // Organizar tutores por rol
    const tutorInfo = {
      familyadmin: null,
      familyviewer: null
    };

    tutors.forEach(tutor => {
      if (tutor.role && tutor.user) {
        if (tutor.role.nombre === 'familyadmin') {
          tutorInfo.familyadmin = {
            _id: tutor.user._id,
            name: tutor.user.name,
            email: tutor.user.email
          };
        } else if (tutor.role.nombre === 'familyviewer') {
          tutorInfo.familyviewer = {
            _id: tutor.user._id,
            name: tutor.user.name,
            email: tutor.user.email
          };
        }
      }
    });

    res.json({
      success: true,
      data: {
        _id: student._id,
        nombre: student.nombre,
        apellido: student.apellido,
        dni: student.dni,
        email: student.email,
        account: student.account,
        division: student.division,
        tutor: tutorInfo,
        qrCode: student.qrCode
      }
    });

  } catch (error) {
    console.error('‚ùå [STUDENT BY ID] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor',
      error: error.message
    });
  }
});

// ==================== FUNCIONES AUXILIARES PARA PUSH NOTIFICATIONS ====================

/**
 * Obtener usuarios familyadmin y familyviewer asociados a un estudiante
 * @param {string} studentId - ID del estudiante
 * @returns {Array} Array de usuarios con sus dispositivos
 */
async function getFamilyUsersForStudent(studentId) {
  try {
    console.log('üîî [FAMILY LOOKUP] Buscando familiares para estudiante:', studentId);
    
    // Buscar asociaciones activas del estudiante con roles familyadmin y familyviewer
    const associations = await Shared.find({
      student: studentId,
      status: 'active',
      'role.nombre': { $in: ['familyadmin', 'familyviewer'] }
    }).populate('user', 'name email').populate('role', 'nombre');
    
    console.log('üîî [FAMILY LOOKUP] Asociaciones encontradas:', associations.length);
    
    const familyUsers = [];
    
    for (const association of associations) {
      if (association.user && association.role) {
        // Obtener dispositivos activos del usuario
        const devices = await Device.getActiveDevicesForUser(association.user._id);
        
        if (devices.length > 0) {
          familyUsers.push({
            user: association.user,
            role: association.role,
            devices: devices
          });
          console.log('üîî [FAMILY LOOKUP] Usuario con dispositivos:', association.user.name, '- Dispositivos:', devices.length);
        } else {
          console.log('üîî [FAMILY LOOKUP] Usuario sin dispositivos activos:', association.user.name);
        }
      }
    }
    
    console.log('üîî [FAMILY LOOKUP] Total usuarios familiares con dispositivos:', familyUsers.length);
    return familyUsers;
    
  } catch (error) {
    console.error('‚ùå [FAMILY LOOKUP] Error:', error);
    return [];
  }
}

/**
 * Enviar push notifications a usuarios familiares de un estudiante
 * @param {string} studentId - ID del estudiante
 * @param {Object} notification - Datos de la notificaci√≥n
 */
async function sendPushNotificationToStudentFamily(studentId, notification) {
  try {
    console.log('üîî [PUSH SEND] Enviando push notification para estudiante:', studentId);
    
    // Obtener usuarios familiares
    const familyUsers = await getFamilyUsersForStudent(studentId);
    
    if (familyUsers.length === 0) {
      console.log('üîî [PUSH SEND] No se encontraron usuarios familiares con dispositivos');
      return { sent: 0, failed: 0 };
    }
    
    const pushNotificationService = require('./pushNotificationService');
    let sent = 0;
    let failed = 0;
    
    // Enviar a cada usuario familiar
    for (const familyUser of familyUsers) {
      for (const device of familyUser.devices) {
        try {
          const pushNotification = {
            title: notification.title,
            message: notification.message,
            data: {
              type: 'notification',
              notificationId: notification._id,
              studentId: studentId,
              priority: notification.priority || 'normal'
            }
          };
          
          await pushNotificationService.sendNotification(
            device.pushToken,
            device.platform,
            pushNotification
          );
          
          // Actualizar √∫ltimo uso del dispositivo
          await device.updateLastUsed();
          
          sent++;
          console.log('üîî [PUSH SEND] ‚úÖ Enviado a:', familyUser.user.name, '-', device.platform);
          
        } catch (error) {
          failed++;
          console.error('üîî [PUSH SEND] ‚ùå Error enviando a:', familyUser.user.name, '-', error.message);
          
          // Si el token es inv√°lido, desactivar el dispositivo
          if (error.message.includes('InvalidRegistration') || error.message.includes('NotRegistered')) {
            await device.deactivate();
            console.log('üîî [PUSH SEND] Dispositivo desactivado por token inv√°lido');
          }
        }
      }
    }
    
    console.log('üîî [PUSH SEND] Resumen - Enviados:', sent, 'Fallidos:', failed);
    return { sent, failed };
    
  } catch (error) {
    console.error('‚ùå [PUSH SEND] Error general:', error);
    return { sent: 0, failed: 1 };
  }
}

// ==================== ENDPOINTS DE PUSH NOTIFICATIONS ====================

// Registrar token de dispositivo para push notifications
app.post('/push/register-token', authenticateToken, async (req, res) => {
  try {
    const { token, platform, deviceId, appVersion, osVersion } = req.body;
    const userId = req.user.userId;

    console.log('üîî [PUSH REGISTER] Registrando token para usuario:', userId);

    // Validar campos requeridos
    if (!token || !platform) {
      return res.status(400).json({
        success: false,
        message: 'Token y platform son requeridos'
      });
    }

    // Validar plataforma
    if (!['ios', 'android'].includes(platform)) {
      return res.status(400).json({
        success: false,
        message: 'Platform debe ser "ios" o "android"'
      });
    }

    // Buscar o crear dispositivo
    const device = await Device.findOneAndUpdate(
      { 
        userId: userId,
        pushToken: token 
      },
      {
        userId: userId,
        pushToken: token,
        platform: platform,
        deviceId: deviceId || null,
        appVersion: appVersion || null,
        osVersion: osVersion || null,
        isActive: true,
        lastUsed: new Date()
      },
      { 
        upsert: true, 
        new: true 
      }
    );

    console.log('üîî [PUSH REGISTER] Token registrado exitosamente:', device._id);

    res.json({
      success: true,
      message: 'Token registrado exitosamente',
      data: {
        deviceId: device._id,
        platform: device.platform,
        isActive: device.isActive
      }
    });

  } catch (error) {
    console.error('‚ùå [PUSH REGISTER] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error registrando token de dispositivo'
    });
  }
});

// Desregistrar token de dispositivo
app.post('/push/unregister-token', authenticateToken, async (req, res) => {
  try {
    const { token } = req.body;
    const userId = req.user.userId;

    console.log('üîî [PUSH UNREGISTER] Desregistrando token para usuario:', userId);

    if (!token) {
      return res.status(400).json({
        success: false,
        message: 'Token es requerido'
      });
    }

    // Desactivar dispositivo
    const device = await Device.findOneAndUpdate(
      { 
        userId: userId,
        pushToken: token 
      },
      { 
        isActive: false,
        lastUsed: new Date()
      },
      { new: true }
    );

    if (!device) {
      return res.status(404).json({
        success: false,
        message: 'Token no encontrado'
      });
    }

    console.log('üîî [PUSH UNREGISTER] Token desregistrado exitosamente');

    res.json({
      success: true,
      message: 'Token desregistrado exitosamente'
    });

  } catch (error) {
    console.error('‚ùå [PUSH UNREGISTER] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error desregistrando token de dispositivo'
    });
  }
});

// ==================== ENDPOINTS DE NOTIFICACIONES ====================

// Obtener datos del calendario de notificaciones
app.get('/backoffice/notifications/calendar', authenticateToken, getCognitoUserInstitution, async (req, res) => {
  try {
    const { 
      divisionId,
      fechaInicio,
      fechaFin
    } = req.query;
    
    console.log('üìÖ [CALENDAR NOTIFICATIONS] Par√°metros:', { divisionId, fechaInicio, fechaFin });
    
    // Verificar permisos del usuario
    let currentUser;
    if (req.user.isCognitoUser) {
      currentUser = await User.findOne({ email: req.user.email }).populate('role');
    } else {
      const { userId } = req.user;
      currentUser = await User.findById(userId).populate('role');
    }
    
    if (!currentUser) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    console.log('üìÖ [CALENDAR NOTIFICATIONS] Rol del usuario:', currentUser.role?.nombre);
    
    // Construir query base
    let query = {};
    
    // L√≥gica seg√∫n el rol
    if (currentUser.role?.nombre === 'superadmin') {
      // Superadmin ve todas las notificaciones de todas las cuentas
      // No filtrar por cuenta espec√≠fica
    } else if (currentUser.role?.nombre === 'adminaccount') {
      // Adminaccount ve todas las notificaciones de su cuenta
      if (req.userInstitution) {
        query.account = req.userInstitution._id;
      } else {
        return res.status(403).json({
          success: false,
          message: 'No tienes una instituci√≥n asignada'
        });
      }
    } else {
      // Otros roles no tienen acceso al backoffice
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para acceder a esta secci√≥n'
      });
    }
    
    // Filtros adicionales
    if (divisionId) {
      query.division = divisionId;
    }
    
    if (fechaInicio && fechaFin) {
      // Crear fechas UTC para evitar problemas de zona horaria
      const startDate = new Date(fechaInicio + 'T00:00:00.000Z');
      const endDate = new Date(fechaFin + 'T23:59:59.999Z');
      
      query.sentAt = {
        $gte: startDate,
        $lte: endDate
      };
      
      console.log('üìÖ [CALENDAR NOTIFICATIONS] Filtro de fechas:', {
        fechaInicio: startDate.toISOString(),
        fechaFin: endDate.toISOString()
      });
    }
    
    console.log('üìÖ [CALENDAR NOTIFICATIONS] Query:', JSON.stringify(query, null, 2));
    
    // Buscar notificaciones
    const notifications = await Notification.find(query)
      .populate('account', 'nombre')
      .populate('division', 'nombre')
      .populate('sender', 'name email')
      .sort({ sentAt: -1 })
      .lean();
    
    console.log('üìÖ [CALENDAR NOTIFICATIONS] Notificaciones encontradas:', notifications.length);
    console.log('üìÖ [CALENDAR NOTIFICATIONS] Notificaciones detalladas:', notifications.map(n => ({
      id: n._id,
      title: n.title,
      sentAt: n.sentAt,
      division: n.division?.nombre || 'Sin divisi√≥n'
    })));
    
    // Agrupar notificaciones por fecha
    const calendarData = {};
    
    notifications.forEach(notification => {
      // Usar fecha local en lugar de UTC para evitar problemas de zona horaria
      const sentAtDate = new Date(notification.sentAt);
      const year = sentAtDate.getFullYear();
      const month = String(sentAtDate.getMonth() + 1).padStart(2, '0');
      const day = String(sentAtDate.getDate()).padStart(2, '0');
      const fecha = `${year}-${month}-${day}`;
      
      console.log('üìÖ [CALENDAR NOTIFICATIONS] Notificaci√≥n fecha original:', notification.sentAt);
      console.log('üìÖ [CALENDAR NOTIFICATIONS] Notificaci√≥n fecha local:', fecha);
      
      if (!calendarData[fecha]) {
        calendarData[fecha] = {
          fecha: fecha,
          totalNotificaciones: 0,
          notificaciones: []
        };
      }
      
      calendarData[fecha].totalNotificaciones++;
      calendarData[fecha].notificaciones.push(notification);
    });
    
    console.log('üìÖ [CALENDAR NOTIFICATIONS] Datos del calendario:', Object.keys(calendarData).length, 'd√≠as');
    
    res.json({
      success: true,
      data: calendarData
    });
    
  } catch (error) {
    console.error('‚ùå [CALENDAR NOTIFICATIONS] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener datos del calendario'
    });
  }
});

// Obtener notificaciones del usuario (endpoint general)
app.get('/notifications', authenticateToken, async (req, res) => {
  try {
    const userId = req.user._id;
    const { 
      limit = 20, 
      skip = 0, 
      unreadOnly = false,
      accountId,
      divisionId,
      userRole,
      isCoordinador
    } = req.query;
    
    console.log('üîî [GET NOTIFICATIONS] Usuario:', userId);
    console.log('üîî [GET NOTIFICATIONS] Par√°metros:', { accountId, divisionId, userRole, isCoordinador });
    
    // Obtener informaci√≥n del usuario para verificar su rol
    const user = await User.findById(userId).populate('role');
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    console.log('üîî [GET NOTIFICATIONS] Rol del usuario (base):', user.role?.nombre);

    // Usar rol de la asociaci√≥n activa si existe
    const activeAssociation = await ActiveAssociation.findOne({ user: userId }).populate('role');
    const effectiveRole = activeAssociation?.role?.nombre || user.role?.nombre;
    const effectiveIsCoordinador = effectiveRole === 'coordinador';
    console.log('üîî [GET NOTIFICATIONS] Rol efectivo:', effectiveRole);
    
    const options = {
      limit: parseInt(limit),
      skip: parseInt(skip),
      unreadOnly: unreadOnly === 'true',
      accountId,
      divisionId,
      userRole: effectiveRole,
      isCoordinador: effectiveIsCoordinador
    };
    
    const notifications = await Notification.getUserNotifications(userId, options);
    
    console.log('üîî [GET NOTIFICATIONS] Notificaciones encontradas:', notifications.length);
    
    res.json({
      success: true,
      data: notifications
    });
    
  } catch (error) {
    console.error('‚ùå [GET NOTIFICATIONS] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener notificaciones'
    });
  }
});

// Obtener notificaciones para usuarios familia (familyadmin/familyviewer)
app.get('/notifications/family', authenticateToken, async (req, res) => {
  try {
    const userId = req.user._id;
    const { 
      limit = 20, 
      skip = 0, 
      unreadOnly = false,
      accountId,
      divisionId
    } = req.query;
    
    console.log('üîî [GET FAMILY NOTIFICATIONS] Usuario:', userId);
    console.log('üîî [GET FAMILY NOTIFICATIONS] Par√°metros:', { accountId, divisionId, unreadOnly });
    
    // Obtener informaci√≥n del usuario para verificar su rol
    const user = await User.findById(userId).populate('role');
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    // Obtener la asociaci√≥n activa del usuario
    const activeAssociation = await ActiveAssociation.findOne({ user: userId }).populate('role');
    console.log('üîî [GET FAMILY NOTIFICATIONS] Buscando ActiveAssociation para userId:', userId);
    console.log('üîî [GET FAMILY NOTIFICATIONS] ActiveAssociation encontrada:', activeAssociation ? {
      id: activeAssociation._id,
      activeShared: activeAssociation.activeShared,
      role: activeAssociation.role?.nombre
    } : null);
    
    if (!activeAssociation) {
      console.log('‚ùå [GET FAMILY NOTIFICATIONS] No se encontr√≥ ActiveAssociation para userId:', userId);
      return res.status(404).json({
        success: false,
        message: 'No se encontr√≥ asociaci√≥n activa'
      });
    }
    
    // Verificar que el rol activo sea familyadmin o familyviewer
    if (!['familyadmin', 'familyviewer'].includes(activeAssociation.role?.nombre)) {
      console.log('‚ùå [GET FAMILY NOTIFICATIONS] Rol activo no es familyadmin/familyviewer:', activeAssociation.role?.nombre);
      return res.status(403).json({
        success: false,
        message: 'Este endpoint es solo para usuarios familia'
      });
    }
    
    console.log('üîî [GET FAMILY NOTIFICATIONS] Rol del usuario base:', user.role?.nombre);
    console.log('üîî [GET FAMILY NOTIFICATIONS] Rol activo:', activeAssociation.role?.nombre);
    
    // Buscar estudiantes asociados al usuario
    const associations = await Shared.find({
      user: userId,
      account: accountId,
      status: 'active'
    }).populate('student', 'nombre apellido');
    
    if (associations.length === 0) {
      console.log('üîî [GET FAMILY NOTIFICATIONS] No se encontraron estudiantes asociados');
      return res.json({
        success: true,
        data: []
      });
    }
    
    // Obtener IDs de estudiantes asociados
    const studentIds = associations
      .map(assoc => assoc.student?._id)
      .filter(id => id);
    
    console.log('üîî [GET FAMILY NOTIFICATIONS] Estudiantes asociados:', studentIds.length);
    console.log('üîî [GET FAMILY NOTIFICATIONS] IDs de estudiantes:', studentIds);
    
    if (studentIds.length === 0) {
      console.log('üîî [GET FAMILY NOTIFICATIONS] No hay estudiantes v√°lidos asociados');
      return res.json({
        success: true,
        data: []
      });
    }
    
    // Construir query para buscar notificaciones
    let query = {
      account: accountId,
      recipients: { $in: studentIds }
    };
    
    if (divisionId) {
      query.division = divisionId;
    }
    
    // Filtrar por no le√≠das si se solicita
    if (unreadOnly === 'true') {
      query['readBy.user'] = { $ne: userId };
    }
    
    console.log('üîî [GET FAMILY NOTIFICATIONS] Query final:', JSON.stringify(query, null, 2));
    
    // Buscar notificaciones
    const notifications = await Notification.find(query)
      .populate('sender', 'name email')
      .populate('account', 'nombre')
      .populate('division', 'nombre')
      .sort({ sentAt: -1 })
      .limit(parseInt(limit))
      .skip(parseInt(skip));
    
    console.log('üîî [GET FAMILY NOTIFICATIONS] Notificaciones encontradas:', notifications.length);
    
    res.json({
      success: true,
      data: notifications
    });
    
  } catch (error) {
    console.error('‚ùå [GET FAMILY NOTIFICATIONS] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener notificaciones familia'
    });
  }
});

// Obtener detalles completos de una notificaci√≥n espec√≠fica
app.get('/notifications/:id/details', authenticateToken, async (req, res) => {
  try {
    const notificationId = req.params.id;
    const userId = req.user._id;
    
    console.log('üîî [GET NOTIFICATION DETAILS] ID:', notificationId);
    console.log('üîî [GET NOTIFICATION DETAILS] Usuario:', userId);
    
    // Obtener informaci√≥n del usuario para verificar su rol
    const user = await User.findById(userId).populate('role');
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    // Buscar la notificaci√≥n con detalles b√°sicos
    const notification = await Notification.findById(notificationId)
      .populate('sender', 'name email')
      .populate('account', 'nombre')
      .populate('division', 'nombre')
      .populate('readBy.user', 'name email');
    
    if (!notification) {
      return res.status(404).json({
        success: false,
        message: 'Notificaci√≥n no encontrada'
      });
    }
    
    // Verificar que el usuario tenga acceso a esta notificaci√≥n
    // Usar rol efectivo de ActiveAssociation si existe
    const activeAssociation = await ActiveAssociation.findOne({ user: userId }).populate('role');
    const effectiveRole = activeAssociation?.role?.nombre || user.role?.nombre;
    const isCoordinador = effectiveRole === 'coordinador';
    const hasAccess = isCoordinador || 
                     notification.recipients.some(recipient => recipient.toString() === userId);
    
    if (!hasAccess) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver esta notificaci√≥n'
      });
    }
    
    // Poblar destinatarios manualmente (usuarios y estudiantes)
    let notificationObj = notification.toObject();
    
    if (notification.recipients && notification.recipients.length > 0) {
      const populatedRecipients = [];
      
      for (let recipientId of notification.recipients) {
        // Intentar buscar como usuario
        let recipient = await User.findById(recipientId).select('name email');
        
        // Si no es usuario, buscar como estudiante
        if (!recipient) {
          recipient = await Student.findById(recipientId).select('nombre apellido email');
        }
        
        if (recipient) {
          // Normalizar el nombre para usuarios y estudiantes
          const recipientObj = recipient.toObject();
          if (recipientObj.name) {
            // Es un usuario, usar 'name' como 'nombre'
            recipientObj.nombre = recipientObj.name;
          } else if (recipientObj.nombre && recipientObj.apellido) {
            // Es un estudiante, combinar nombre y apellido
            recipientObj.nombre = `${recipientObj.nombre} ${recipientObj.apellido}`;
          }
          populatedRecipients.push(recipientObj);
        }
      }
      
      notificationObj.recipients = populatedRecipients;
    }

    // Poblar readBy.user manualmente para asegurar que tenga el campo nombre
    if (notificationObj.readBy && notificationObj.readBy.length > 0) {
      const populatedReadBy = [];
      
      for (let readEntry of notificationObj.readBy) {
        if (readEntry.user && readEntry.user._id) {
          // Buscar el usuario completo
          const user = await User.findById(readEntry.user._id).select('name email');
          if (user) {
            populatedReadBy.push({
              user: {
                _id: user._id,
                nombre: user.name, // User model usa 'name', no 'nombre'
                email: user.email
              },
              readAt: readEntry.readAt,
              _id: readEntry._id
            });
          } else {
            // Si no se encuentra el usuario, mantener la entrada original
            populatedReadBy.push(readEntry);
          }
        } else {
          populatedReadBy.push(readEntry);
        }
      }
      
      notificationObj.readBy = populatedReadBy;
    }
    
    // Calcular estad√≠sticas corregidas
    const totalRecipients = notificationObj.recipients?.length || 0;
    
    // Filtrar readBy para excluir coordinadores
    const readByParents = notificationObj.readBy?.filter(readEntry => {
      if (!readEntry.user) return false;
      // Verificar si el usuario que ley√≥ es coordinador
      return readEntry.user.role?.nombre !== 'coordinador';
    }) || [];
    
    // Para la lista de pendientes, necesitamos encontrar qu√© estudiantes tienen padres que ya leyeron
    const studentsWithParentsRead = new Set();
    
    if (readByParents.length > 0) {
      // Buscar asociaciones de los usuarios que leyeron para encontrar sus estudiantes
      for (let readEntry of readByParents) {
        const associations = await Shared.find({
          user: readEntry.user._id,
          status: 'active'
        }).populate('student', '_id');
        
        associations.forEach(assoc => {
          if (assoc.student) {
            studentsWithParentsRead.add(assoc.student._id.toString());
          }
        });
      }
    }
    
    // Filtrar destinatarios pendientes (estudiantes cuyos padres NO han le√≠do)
    const pendingRecipients = [];
    
    if (notificationObj.recipients && notificationObj.recipients.length > 0) {
      for (let recipient of notificationObj.recipients) {
        // Si es un estudiante, verificar si sus padres ya leyeron
        if (recipient._id && !studentsWithParentsRead.has(recipient._id.toString())) {
          // Buscar el tutor (familyadmin) de este estudiante
          const tutorAssociation = await Shared.findOne({
            student: recipient._id,
            status: 'active'
          }).populate('user', 'name email').populate('role', 'nombre');
          
          // Solo incluir si el tutor es familyadmin
          if (tutorAssociation && tutorAssociation.role?.nombre === 'familyadmin') {
            pendingRecipients.push({
              ...recipient,
              tutor: {
                name: tutorAssociation.user?.name,
                email: tutorAssociation.user?.email
              }
            });
          } else {
            // Si no tiene tutor familyadmin, incluir sin tutor
            pendingRecipients.push({
              ...recipient,
              tutor: null
            });
          }
        }
      }
    }
    
    // Agregar estad√≠sticas corregidas al objeto de respuesta
    notificationObj.stats = {
      totalRecipients,
      readByParents: readByParents.length,
      pendingRecipients: pendingRecipients.length
    };
    
    // Agregar lista de pendientes corregida
    notificationObj.pendingRecipients = pendingRecipients;
    
    console.log('üîî [GET NOTIFICATION DETAILS] Notificaci√≥n encontrada:', notification.title);
    console.log('üîî [GET NOTIFICATION DETAILS] Total destinatarios:', totalRecipients);
    console.log('üîî [GET NOTIFICATION DETAILS] Le√≠das por padres:', readByParents.length);
    console.log('üîî [GET NOTIFICATION DETAILS] Pendientes:', pendingRecipients.length);
    
    res.json({
      success: true,
      data: notificationObj
    });
    
  } catch (error) {
    console.error('‚ùå [GET NOTIFICATION DETAILS] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener detalles de la notificaci√≥n'
    });
  }
});

// Marcar notificaci√≥n como le√≠da
app.put('/notifications/:id/read', authenticateToken, async (req, res) => {
  try {
    const userId = req.user._id;
    const notificationId = req.params.id;
    
    console.log('üîî [MARK READ] Usuario:', userId, 'Notificaci√≥n:', notificationId);
    
    const notification = await Notification.findById(notificationId);
    
    if (!notification) {
      return res.status(404).json({
        success: false,
        message: 'Notificaci√≥n no encontrada'
      });
    }
    
    await notification.markAsRead(userId);
    
    console.log('üîî [MARK READ] Notificaci√≥n marcada como le√≠da');
    
    res.json({
      success: true,
      message: 'Notificaci√≥n marcada como le√≠da'
    });
    
  } catch (error) {
    console.error('‚ùå [MARK READ] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al marcar notificaci√≥n como le√≠da'
    });
  }
});

// Eliminar notificaci√≥n
app.delete('/notifications/:id', authenticateToken, async (req, res) => {
  try {
    const userId = req.user._id;
    const notificationId = req.params.id;
    
    console.log('üîî [DELETE] Usuario:', userId, 'Notificaci√≥n:', notificationId);
    
    const notification = await Notification.findById(notificationId);
    
    if (!notification) {
      return res.status(404).json({
        success: false,
        message: 'Notificaci√≥n no encontrada'
      });
    }
    
    // Verificar permisos: remitente, superadmin, coordinador o adminaccount puede eliminar
    const user = await User.findById(userId).populate('role');
    const isSuperAdmin = user?.role?.nombre === 'superadmin';
    const isCoordinador = user?.role?.nombre === 'coordinador';
    const isAdminAccount = user?.role?.nombre === 'adminaccount';
    const isSender = notification.sender.toString() === userId;
    
    console.log('üîî [DELETE] Verificando permisos:', {
      userId,
      userRole: user?.role?.nombre,
      isSuperAdmin,
      isCoordinador,
      isAdminAccount,
      isSender,
      notificationSender: notification.sender.toString()
    });
    
    if (!isSuperAdmin && !isCoordinador && !isAdminAccount && !isSender) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para eliminar esta notificaci√≥n'
      });
    }
    
    await Notification.findByIdAndDelete(notificationId);
    
    console.log('üîî [DELETE] Notificaci√≥n eliminada');
    
    res.json({
      success: true,
      message: 'Notificaci√≥n eliminada correctamente'
    });
    
  } catch (error) {
    console.error('‚ùå [DELETE] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al eliminar notificaci√≥n'
    });
  }
});

// Endpoint de prueba para verificar que el servidor funciona
app.get('/test', (req, res) => {
  res.json({
    success: true,
    message: 'Servidor funcionando correctamente',
    timestamp: new Date().toISOString()
  });
});

// Endpoint para obtener datos de ejemplo del usuario (sin autenticaci√≥n)
app.get('/users/example', (req, res) => {
  const exampleUser = {
    _id: 'juan-perez-id',
    name: 'Juan P√©rez',
    email: 'juan.perez@test.com',
    telefono: '+54 9 11 5555-1234',
    avatar: undefined,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  };
  
  res.json({
    success: true,
    data: exampleUser
  });
});

// Endpoint para obtener datos del usuario actual
app.get('/users/me', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const user = await User.findById(userId).select('-password');
    
    if (!user) {
      return res.status(404).json({ success: false, message: 'Usuario no encontrado' });
    }

    res.json({
      success: true,
      data: user
    });
  } catch (error) {
    console.error('Error al obtener usuario:', error);
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// Endpoint para obtener un usuario por ID
app.get('/users/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    console.log('üîç [GET USER BY ID] Obteniendo usuario con ID:', id);
    
    // Buscar el usuario por ID
    const user = await User.findById(id).select('-password').populate('role');
    
    if (!user) {
      console.log('‚ùå [GET USER BY ID] Usuario no encontrado:', id);
      return res.status(404).json({ 
        success: false, 
        message: 'Usuario no encontrado' 
      });
    }

    console.log('‚úÖ [GET USER BY ID] Usuario encontrado:', user.name);
    
    res.json({
      success: true,
      data: user
    });
  } catch (error) {
    console.error('‚ùå [GET USER BY ID] Error al obtener usuario:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Error interno del servidor' 
    });
  }
});

// Endpoint para actualizar datos del usuario (sin autenticaci√≥n para testing)
app.put('/users/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const { name, phone, telefono } = req.body;

    // Log para debuggear qu√© datos llegan
    console.log('üîç [Server] Datos recibidos:', {
      userId,
      body: req.body,
      name,
      phone,
      telefono
    });

    // Para testing, simular actualizaci√≥n con datos de ejemplo
    const updatedUser = {
      _id: userId,
      name: name || 'Juan P√©rez',
      email: 'juan.perez@test.com',
      telefono: phone || telefono || '+54 9 11 5555-1234',
      avatar: undefined,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    console.log('üîç [Server] Usuario actualizado (simulado):', updatedUser);

    res.json({
      success: true,
      data: updatedUser
    });
  } catch (error) {
    console.error('Error al actualizar usuario:', error);
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// Endpoint para subir avatar del usuario (sin autenticaci√≥n para testing)
app.post('/users/:userId/avatar', upload.single('avatar'), async (req, res) => {
  try {
    const { userId } = req.params;
    
    if (!req.file) {
      return res.status(400).json({ success: false, message: 'No se proporcion√≥ imagen' });
    }

    // Para testing, simular subida a S3
    const avatarUrl = `https://s3.amazonaws.com/ki-bucket/avatars/${userId}/${Date.now()}-${req.file.originalname}`;
    
    console.log('üîç [Server] Avatar simulado:', avatarUrl);

    res.json({
      success: true,
      avatarUrl: avatarUrl,
      message: 'Avatar actualizado correctamente'
    });
  } catch (error) {
    console.error('Error al subir avatar:', error);
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// Endpoint para eliminar avatar del usuario
app.delete('/users/:userId/avatar', authenticateToken, async (req, res) => {
  try {
    const { userId } = req.params;

    // Verificar que el usuario solo puede eliminar su propio avatar
    if (req.user.userId !== userId) {
      return res.status(403).json({ success: false, message: 'No tienes permisos para actualizar este usuario' });
    }

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ success: false, message: 'Usuario no encontrado' });
    }

    // Eliminar avatar anterior de S3 si existe
    if (user.avatar) {
      const key = user.avatar.split('/').pop();
      try {
        await s3.deleteObject({
          Bucket: S3_BUCKET_NAME,
          Key: `avatars/${userId}/${key}`
        }).promise();
      } catch (s3Error) {
        console.error('Error al eliminar archivo de S3:', s3Error);
      }
    }

    // Limpiar avatar del usuario
    user.avatar = undefined;
    await user.save();

    res.json({
      success: true,
      message: 'Avatar eliminado correctamente'
    });
  } catch (error) {
    console.error('Error al eliminar avatar:', error);
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// Obtener conteo de notificaciones sin leer
app.get('/notifications/unread-count', authenticateToken, async (req, res) => {
  try {
    const userId = req.user._id;
    
    console.log('üîî [UNREAD COUNT] Usuario:', userId);
    
    // Obtener informaci√≥n del usuario para verificar su rol
    const user = await User.findById(userId).populate('role');
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    // Solo familyadmin y familyviewer pueden ver notificaciones
    if (!['familyadmin', 'familyviewer'].includes(user.role?.nombre)) {
      return res.json({
        success: true,
        data: { count: 0 }
      });
    }
    
    console.log('üîî [UNREAD COUNT] Rol del usuario:', user.role?.nombre);
    
    // Para familyadmin/familyviewer: buscar estudiantes asociados y obtener sus notificaciones
    console.log('üîî [UNREAD COUNT] Usuario es familyadmin/familyviewer - buscando notificaciones de estudiantes asociados');
    
    // Obtener todas las asociaciones del usuario
    const userAssociations = await Shared.find({ 
      user: userId, 
      status: 'active' 
    }).populate('account division student');
    
    if (userAssociations.length === 0) {
      console.log('üîî [UNREAD COUNT] No se encontraron asociaciones activas');
      return res.json({
        success: true,
        data: { count: 0 }
      });
    }
    
    // Obtener IDs de estudiantes asociados
    const studentIds = userAssociations
      .map(assoc => assoc.student?._id)
      .filter(id => id); // Filtrar IDs v√°lidos
    
    console.log('üîî [UNREAD COUNT] Estudiantes asociados:', studentIds);
    
    if (studentIds.length === 0) {
      console.log('üîî [UNREAD COUNT] No hay estudiantes v√°lidos asociados');
      return res.json({
        success: true,
        data: { count: 0 }
      });
    }
    
    // Obtener IDs de cuentas del usuario
    const accountIds = userAssociations.map(assoc => assoc.account._id);
    
    console.log('üîî [UNREAD COUNT] Cuentas del usuario:', accountIds);
    
    // Construir query para notificaciones
    const query = {
      account: { $in: accountIds },
      recipients: { $in: studentIds }, // Notificaciones dirigidas a los estudiantes asociados
      'readBy.user': { $ne: userId } // Excluir las que ya fueron le√≠das por este usuario
    };
    
    console.log('üîî [UNREAD COUNT] Query:', JSON.stringify(query, null, 2));
    
    // Contar notificaciones sin leer
    const unreadCount = await Notification.countDocuments(query);
    
    console.log('üîî [UNREAD COUNT] Conteo sin leer:', unreadCount);
    
    res.json({
      success: true,
      data: { count: unreadCount }
    });
    
  } catch (error) {
    console.error('‚ùå [UNREAD COUNT] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Obtener conteo de notificaciones sin leer para usuarios familia (endpoint espec√≠fico)
app.get('/notifications/family/unread-count', authenticateToken, async (req, res) => {
  try {
    const userId = req.user._id;
    const { accountId } = req.query;
    
    console.log('üîî [FAMILY UNREAD COUNT] Usuario:', userId);
    console.log('üîî [FAMILY UNREAD COUNT] AccountId:', accountId);
    
    // Obtener informaci√≥n del usuario para verificar su rol
    const user = await User.findById(userId).populate('role');
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    // Obtener la asociaci√≥n activa del usuario
    const activeAssociation = await ActiveAssociation.findOne({ user: userId });
    if (!activeAssociation) {
      return res.status(404).json({
        success: false,
        message: 'No se encontr√≥ asociaci√≥n activa'
      });
    }
    
    // Verificar que el rol activo sea familyadmin o familyviewer
    if (!['familyadmin', 'familyviewer'].includes(activeAssociation.role?.nombre)) {
      return res.status(403).json({
        success: false,
        message: 'Este endpoint es solo para usuarios familia'
      });
    }
    
    console.log('üîî [FAMILY UNREAD COUNT] Rol del usuario:', user.role?.nombre);
    
    // Buscar estudiantes asociados al usuario en la cuenta espec√≠fica
    const associations = await Shared.find({
      user: userId,
      account: accountId,
      status: 'active'
    }).populate('student', 'nombre apellido');
    
    if (associations.length === 0) {
      console.log('üîî [FAMILY UNREAD COUNT] No se encontraron estudiantes asociados');
      return res.json({
        success: true,
        data: { count: 0 }
      });
    }
    
    // Obtener IDs de estudiantes asociados
    const studentIds = associations
      .map(assoc => assoc.student?._id)
      .filter(id => id);
    
    console.log('üîî [FAMILY UNREAD COUNT] Estudiantes asociados:', studentIds.length);
    console.log('üîî [FAMILY UNREAD COUNT] IDs de estudiantes:', studentIds);
    
    if (studentIds.length === 0) {
      console.log('üîî [FAMILY UNREAD COUNT] No hay estudiantes v√°lidos asociados');
      return res.json({
        success: true,
        data: { count: 0 }
      });
    }
    
    // Buscar notificaciones no le√≠das para estos estudiantes
    const unreadCount = await Notification.countDocuments({
      account: accountId,
      recipients: { $in: studentIds },
      'readBy.user': { $ne: userId }
    });
    
    console.log('üîî [FAMILY UNREAD COUNT] Notificaciones no le√≠das:', unreadCount);
    
    res.json({
      success: true,
      data: { count: unreadCount }
    });
    
  } catch (error) {
    console.error('‚ùå [FAMILY UNREAD COUNT] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener conteo de notificaciones familia'
    });
  }
});

// Obtener notificaciones para el backoffice (servicio espec√≠fico)
app.get('/backoffice/notifications', authenticateToken, getCognitoUserInstitution, async (req, res) => {
  try {
    // Verificar permisos del usuario
    let currentUser;
    if (req.user.isCognitoUser) {
      currentUser = await User.findOne({ email: req.user.email }).populate('role');
    } else {
      const { userId } = req.user;
      currentUser = await User.findById(userId).populate('role');
    }
    
    if (!currentUser) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    const userId = currentUser._id;
    const { 
      limit = 100, 
      skip = 0, 
      accountId,
      divisionId,
      type,
      search
    } = req.query;
    
    console.log('üîî [BACKOFFICE NOTIFICATIONS] Usuario:', userId);
    console.log('üîî [BACKOFFICE NOTIFICATIONS] Par√°metros:', { accountId, divisionId, type, search });
    
    // Obtener informaci√≥n del usuario para verificar su rol
    const user = await User.findById(userId).populate('role');
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    console.log('üîî [BACKOFFICE NOTIFICATIONS] Rol del usuario:', user.role?.nombre);
    
    // Construir query base
    let query = {};
    
    // L√≥gica seg√∫n el rol
    if (user.role?.nombre === 'superadmin') {
      // Superadmin ve todas las notificaciones de todas las cuentas
      if (accountId) {
        query.account = accountId;
      }
    } else if (user.role?.nombre === 'adminaccount') {
      // Adminaccount ve todas las notificaciones de su cuenta
      query.account = user.account?._id;
    } else {
      // Otros roles no tienen acceso al backoffice
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para acceder a esta secci√≥n'
      });
    }
    
    // Filtros adicionales
    if (divisionId) {
      query.division = divisionId;
    }
    
    if (type && type !== 'all') {
      query.type = type;
    }
    
    if (search) {
      query.$or = [
        { title: { $regex: search, $options: 'i' } },
        { message: { $regex: search, $options: 'i' } }
      ];
    }
    
    console.log('üîî [BACKOFFICE NOTIFICATIONS] Query final:', JSON.stringify(query, null, 2));
    
    // Obtener total de notificaciones para la paginaci√≥n
    const total = await Notification.countDocuments(query);
    
    // Obtener notificaciones con paginaci√≥n
    const notifications = await Notification.find(query)
      .populate('sender', 'nombre email')
      .populate('account', 'nombre')
      .populate('division', 'nombre')
      .sort({ sentAt: -1 })
      .limit(parseInt(limit))
      .skip(parseInt(skip));

    // Poblar destinatarios manualmente (usuarios y estudiantes)
    const populatedNotifications = [];
    
    for (let notification of notifications) {
      // Convertir a objeto plano primero
      let notificationObj = notification.toObject();
      
      if (notification.recipients && notification.recipients.length > 0) {
        const populatedRecipients = [];
        
        for (let recipientId of notification.recipients) {
          // Intentar buscar como usuario
          let recipient = await User.findById(recipientId).select('name email');
          
          // Si no es usuario, buscar como estudiante
          if (!recipient) {
            recipient = await Student.findById(recipientId).select('nombre apellido email');
          }
          
          if (recipient) {
            // Normalizar el nombre para usuarios y estudiantes
            const recipientObj = recipient.toObject();
            if (recipientObj.name) {
              // Es un usuario, usar 'name' como 'nombre'
              recipientObj.nombre = recipientObj.name;
            } else if (recipientObj.nombre && recipientObj.apellido) {
              // Es un estudiante, combinar nombre y apellido
              recipientObj.nombre = `${recipientObj.nombre} ${recipientObj.apellido}`;
            }
            populatedRecipients.push(recipientObj);
          }
        }
        
        notificationObj.recipients = populatedRecipients;
      }
      
      populatedNotifications.push(notificationObj);
    }
    
    // Calcular informaci√≥n de paginaci√≥n
    const currentPage = Math.floor(parseInt(skip) / parseInt(limit)) + 1;
    const totalPages = Math.ceil(total / parseInt(limit));
    const hasNextPage = currentPage < totalPages;
    const hasPrevPage = currentPage > 1;
    
    console.log('üîî [BACKOFFICE NOTIFICATIONS] Notificaciones encontradas:', populatedNotifications.length);
    console.log('üîî [BACKOFFICE NOTIFICATIONS] Paginaci√≥n:', { currentPage, totalPages, total });
    
    res.json({
      success: true,
      data: populatedNotifications,
      pagination: {
        currentPage,
        totalPages,
        totalItems: total,
        itemsPerPage: parseInt(limit),
        hasNextPage,
        hasPrevPage
      }
    });
    
  } catch (error) {
    console.error('‚ùå [BACKOFFICE NOTIFICATIONS] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener notificaciones'
    });
  }
});

// Enviar nueva notificaci√≥n
app.post('/notifications', authenticateToken, async (req, res) => {
  try {
    console.log('üîî [SEND NOTIFICATION] Iniciando...');
    const { title, message, type, accountId, divisionId, recipients = [] } = req.body;
    const userId = req.user._id;

    console.log('üîî [SEND NOTIFICATION] Datos recibidos:', { title, message, type, accountId, divisionId, recipients });

    // Validar campos requeridos
    if (!title || !message || !type || !accountId) {
      console.log('‚ùå [SEND NOTIFICATION] Campos faltantes');
      return res.status(400).json({
        success: false,
        message: 'Faltan campos requeridos: t√≠tulo, mensaje, tipo y cuenta'
      });
    }

    // Validar tipo de notificaci√≥n
    if (!['informacion', 'comunicacion', 'institucion', 'coordinador'].includes(type)) {
      console.log('‚ùå [SEND NOTIFICATION] Tipo inv√°lido:', type);
      return res.status(400).json({
        success: false,
        message: 'Tipo de notificaci√≥n inv√°lido. Debe ser "informacion", "comunicacion", "institucion" o "coordinador"'
      });
    }

    // Verificar que el usuario tiene permisos para la cuenta
    console.log('üîî [SEND NOTIFICATION] Verificando permisos...');
    
    // Obtener informaci√≥n del usuario para verificar su rol
    const user = await User.findById(userId).populate('role');
    if (!user) {
      console.log('‚ùå [SEND NOTIFICATION] Usuario no encontrado');
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    console.log('üîî [SEND NOTIFICATION] Usuario:', user.email, 'Rol:', user.role?.nombre);
    
    // Verificar permisos seg√∫n el rol
    if (user.role?.nombre === 'adminaccount') {
      // Adminaccount puede enviar notificaciones a su cuenta
      if (user.account?._id?.toString() !== accountId) {
        // Si no tiene cuenta asignada directamente, verificar asociaci√≥n en Shared
        console.log('üîî [SEND NOTIFICATION] Adminaccount sin cuenta directa, verificando asociaci√≥n en Shared...');
        const userAssociation = await Shared.findOne({
          user: userId,
          account: accountId,
          status: 'active'
        });

        if (!userAssociation) {
          console.log('‚ùå [SEND NOTIFICATION] Adminaccount no tiene permisos para esta cuenta');
          return res.status(403).json({
            success: false,
            message: 'No tienes permisos para enviar notificaciones a esta cuenta'
          });
        }
        console.log('‚úÖ [SEND NOTIFICATION] Adminaccount tiene asociaci√≥n activa en Shared');
      } else {
        console.log('‚úÖ [SEND NOTIFICATION] Adminaccount tiene cuenta asignada directamente');
      }
    } else if (user.role?.nombre === 'superadmin') {
      // Superadmin puede enviar a cualquier cuenta
      console.log('üîî [SEND NOTIFICATION] Superadmin - permisos otorgados');
    } else {
      // Para otros roles, verificar asociaci√≥n en Shared
      const userAssociation = await Shared.findOne({
        user: userId,
        account: accountId,
        status: 'active'
      });

      if (!userAssociation) {
        console.log('‚ùå [SEND NOTIFICATION] Sin permisos - no hay asociaci√≥n activa');
        return res.status(403).json({
          success: false,
          message: 'No tienes permisos para enviar notificaciones a esta cuenta'
        });
      }
    }

    console.log('üîî [SEND NOTIFICATION] Creando notificaci√≥n...');
    // Crear la notificaci√≥n
    const notification = new Notification({
      title,
      message,
      type,
      sender: userId,
      account: accountId,
      division: divisionId,
      recipients,
      status: 'sent',
      priority: 'normal',
      readBy: [],
      sentAt: new Date()
    });

    await notification.save();
    console.log('üîî [SEND NOTIFICATION] Notificaci√≥n guardada:', notification._id);

    // Enviar push notifications a usuarios familiares de estudiantes
    if (recipients && recipients.length > 0) {
      console.log('üîî [SEND NOTIFICATION] Enviando push notifications a familiares...');
      
      // Verificar si los destinatarios son estudiantes
      const students = await Student.find({ _id: { $in: recipients } });
      
      if (students.length > 0) {
        console.log('üîî [SEND NOTIFICATION] Encontrados', students.length, 'estudiantes destinatarios');
        
        // Enviar push notification a cada estudiante
        for (const student of students) {
          try {
            const pushResult = await sendPushNotificationToStudentFamily(student._id, notification);
            console.log('üîî [SEND NOTIFICATION] Push para estudiante', student.nombre, '- Enviados:', pushResult.sent, 'Fallidos:', pushResult.failed);
          } catch (pushError) {
            console.error('üîî [SEND NOTIFICATION] Error enviando push para estudiante', student.nombre, ':', pushError.message);
          }
        }
      } else {
        console.log('üîî [SEND NOTIFICATION] No se encontraron estudiantes en los destinatarios');
      }
    }

    // Populate sender info
    await notification.populate('sender', 'nombre email');
    await notification.populate('account', 'nombre');
    await notification.populate('division', 'nombre');
    await notification.populate('recipients', 'nombre email');

    const responseData = {
      success: true,
      message: 'Notificaci√≥n enviada exitosamente',
      data: {
        _id: notification._id,
        title: notification.title,
        message: notification.message,
        type: notification.type,
        sender: notification.sender,
        account: notification.account,
        division: notification.division,
        recipients: notification.recipients,
        readBy: notification.readBy,
        status: notification.status,
        priority: notification.priority,
        sentAt: notification.sentAt,
        createdAt: notification.createdAt,
        updatedAt: notification.updatedAt
      }
    };

    console.log('üîî [SEND NOTIFICATION] Respuesta exitosa:', JSON.stringify(responseData, null, 2));
    res.status(201).json(responseData);

  } catch (error) {
    console.error('‚ùå [SEND NOTIFICATION] Error completo:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor al enviar notificaci√≥n'
    });
  }
});

// Obtener usuarios disponibles para enviar notificaciones
app.get('/notifications/recipients', authenticateToken, async (req, res) => {
  try {
    const { accountId, divisionId } = req.query;
    
    console.log('üîî [GET RECIPIENTS] Par√°metros:', { accountId, divisionId });
    
    if (!accountId) {
      return res.status(400).json({
        success: false,
        message: 'accountId es requerido'
      });
    }
    
    // Buscar usuarios asociados a la cuenta/divisi√≥n
    let query = { account: accountId };
    
    if (divisionId) {
      query.division = divisionId;
    }
    
    const associations = await Shared.find(query)
      .populate('user', 'nombre email')
      .populate('account', 'nombre')
      .populate('division', 'nombre')
      .populate('role', 'nombre');
    
    const recipients = associations.map(assoc => ({
      _id: assoc.user._id,
      nombre: assoc.user.nombre,
      email: assoc.user.email,
      role: {
        nombre: assoc.role.nombre
      },
      account: assoc.account.nombre,
      division: assoc.division?.nombre || 'Sin divisi√≥n'
    }));
    
    console.log('üîî [GET RECIPIENTS] Destinatarios encontrados:', recipients.length);
    
    res.json({
      success: true,
      data: recipients
    });
    
  } catch (error) {
    console.error('‚ùå [GET RECIPIENTS] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener destinatarios'
    });
  }
});

// ===== NUEVOS ENDPOINTS DE EVENTOS =====

// Crear evento desde backoffice (adminaccount y superadmin)
app.post('/api/events', authenticateToken, async (req, res) => {
  try {
    const { titulo, descripcion, fecha, hora, lugar, institucion, division, estado, requiereAutorizacion } = req.body;
    const currentUser = req.user;

    console.log('üìÖ [CREATE EVENT BACKOFFICE] Datos recibidos:', { titulo, descripcion, fecha, hora, lugar, institucion, division, requiereAutorizacion });
    console.log('üë§ [CREATE EVENT BACKOFFICE] Usuario:', currentUser._id, currentUser.role?.nombre);

    // Verificar que el usuario tiene permisos para crear eventos
    if (!['adminaccount', 'superadmin'].includes(currentUser.role?.nombre)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para crear eventos'
      });
    }

    // Validar campos requeridos
    if (!titulo || !descripcion || !fecha || !hora || !institucion || !division) {
      return res.status(400).json({
        success: false,
        message: 'T√≠tulo, descripci√≥n, fecha, hora, instituci√≥n y divisi√≥n son requeridos'
      });
    }

    // Verificar que la instituci√≥n existe
    const institutionExists = await Account.findById(institucion);
    if (!institutionExists) {
      return res.status(404).json({
        success: false,
        message: 'La instituci√≥n especificada no existe'
      });
    }

    // Verificar que la divisi√≥n existe
    const divisionExists = await Group.findById(division);
    if (!divisionExists) {
      return res.status(404).json({
        success: false,
        message: 'La divisi√≥n especificada no existe'
      });
    }

    // Crear el evento
    const newEvent = new Event({
      titulo,
      descripcion,
      fecha: new Date(fecha),
      hora,
      lugar: lugar || '',
      creador: currentUser._id,
      institucion: institucion,
      division: division,
      estado: estado || 'activo',
      requiereAutorizacion: requiereAutorizacion || false
    });

    await newEvent.save();
    console.log('üìÖ [CREATE EVENT BACKOFFICE] Evento creado:', newEvent._id);

    // Populate para la respuesta
    await newEvent.populate('creador', 'name email');
    await newEvent.populate('institucion', 'nombre');
    await newEvent.populate('division', 'nombre');

    res.status(201).json({
      success: true,
      message: 'Evento creado exitosamente',
      data: {
        event: {
          _id: newEvent._id,
          titulo: newEvent.titulo,
          descripcion: newEvent.descripcion,
          fecha: newEvent.fecha,
          hora: newEvent.hora,
          lugar: newEvent.lugar,
          estado: newEvent.estado,
          requiereAutorizacion: newEvent.requiereAutorizacion,
          creador: newEvent.creador,
          institucion: newEvent.institucion,
          division: newEvent.division,
          createdAt: newEvent.createdAt
        }
      }
    });

  } catch (error) {
    console.error('‚ùå [CREATE EVENT BACKOFFICE] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor al crear evento'
    });
  }
});

// Crear evento (solo coordinadores)
app.post('/events/create', authenticateToken, async (req, res) => {
  try {
    const { titulo, descripcion, fecha, hora, lugar, institutionId, divisionId, requiereAutorizacion } = req.body;
    const currentUser = req.user;

    console.log('üìÖ [CREATE EVENT] Datos recibidos:', { titulo, descripcion, fecha, hora, lugar, institutionId, divisionId, requiereAutorizacion });
    console.log('üë§ [CREATE EVENT] Usuario:', currentUser._id, currentUser.role?.nombre);

    // Verificar que el usuario tiene permisos para crear eventos (usar rol efectivo)
    const activeAssociation = await ActiveAssociation.findOne({ user: currentUser._id }).populate('role');
    const effectiveRole = activeAssociation?.role?.nombre || currentUser.role?.nombre;
    console.log('üîç [CREATE EVENT] Rol efectivo:', effectiveRole);

    if (!['coordinador', 'adminaccount', 'superadmin'].includes(effectiveRole)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para crear eventos'
      });
    }

    // Validar campos requeridos
    if (!titulo || !descripcion || !fecha || !hora) {
      return res.status(400).json({
        success: false,
        message: 'T√≠tulo, descripci√≥n, fecha y hora son requeridos'
      });
    }

    // Para adminaccount, verificar que tenga acceso a la cuenta
    let userAssociation;
    let targetAccount;
    let targetDivision;

    console.log('üîç [CREATE EVENT] Verificando permisos...');
    console.log('üîç [CREATE EVENT] Rol del usuario:', currentUser.role?.nombre);
    console.log('üîç [CREATE EVENT] InstitutionId recibido:', institutionId);
    console.log('üîç [CREATE EVENT] DivisionId recibido:', divisionId);

    if (currentUser.role?.nombre === 'adminaccount') {
      console.log('üîç [CREATE EVENT] Usuario es adminaccount, verificando acceso a cuenta:', institutionId);
      
      // Para adminaccount, buscar cualquier asociaci√≥n activa con la cuenta
      userAssociation = await Shared.findOne({
        user: currentUser._id,
        account: institutionId,
        status: { $in: ['active', 'pending'] }
      }).populate('account division');

      console.log('üîç [CREATE EVENT] Asociaci√≥n encontrada:', userAssociation ? 'S√≠' : 'No');
      if (userAssociation) {
        console.log('üîç [CREATE EVENT] Asociaci√≥n details:', {
          account: userAssociation.account?._id,
          division: userAssociation.division?._id,
          status: userAssociation.status
        });
      }

      if (!userAssociation) {
        console.log('‚ùå [CREATE EVENT] No se encontr√≥ asociaci√≥n para adminaccount');
        return res.status(403).json({
          success: false,
          message: 'No tienes acceso a la instituci√≥n indicada'
        });
      }

      targetAccount = userAssociation.account._id;
      targetDivision = divisionId || null;
      console.log('‚úÖ [CREATE EVENT] Adminaccount autorizado. TargetAccount:', targetAccount, 'TargetDivision:', targetDivision);
    } else {
      // Para coordinadores, verificar asociaci√≥n espec√≠fica
      const assocFilter = {
        user: currentUser._id,
        status: { $in: ['active', 'pending'] }
      };
      if (institutionId) {
        assocFilter.account = institutionId;
      }
      if (divisionId) {
        assocFilter.division = divisionId;
      }

      userAssociation = await Shared.findOne(assocFilter).populate('account division');

      if (!userAssociation) {
        return res.status(403).json({
          success: false,
          message: institutionId || divisionId
            ? 'No tienes acceso a la instituci√≥n/divisi√≥n indicada'
            : 'Usuario no tiene asociaciones activas'
        });
      }

      targetAccount = userAssociation.account._id;
      targetDivision = userAssociation.division?._id || null;
    }

    // Crear el evento
    const newEvent = new Event({
      titulo,
      descripcion,
      fecha: new Date(fecha),
      hora,
      lugar: lugar || '',
      creador: currentUser._id,
      institucion: targetAccount,
      division: targetDivision,
      estado: 'activo',
      requiereAutorizacion: requiereAutorizacion || false
    });

    await newEvent.save();
    console.log('üìÖ [CREATE EVENT] Evento creado:', newEvent._id);

    // Si el evento requiere autorizaci√≥n, generar notificaciones para todos los estudiantes de la divisi√≥n
    if (newEvent.requiereAutorizacion && targetDivision) {
      try {
        console.log('üì¢ [CREATE EVENT] Generando notificaciones para evento que requiere autorizaci√≥n');
        
        // Obtener todos los estudiantes de la divisi√≥n
        const students = await Student.find({
          division: targetDivision,
          activo: true
        });

        console.log('üì¢ [CREATE EVENT] Estudiantes encontrados para notificar:', students.length);

        // Crear una sola notificaci√≥n para todos los estudiantes
        const studentIds = students.map(student => student._id);
        const notification = new Notification({
          title: `Nuevo evento: ${newEvent.titulo}`,
          message: `${newEvent.descripcion}\n\nüìÖ Fecha: ${new Date(newEvent.fecha).toLocaleDateString('es-ES', { 
            weekday: 'long', 
            day: 'numeric', 
            month: 'long' 
          })} a las ${newEvent.hora}${newEvent.lugar ? `\nüìç Lugar: ${newEvent.lugar}` : ''}\n\n‚ö†Ô∏è Este evento requiere tu autorizaci√≥n. Por favor, autoriza o rechaza la participaci√≥n de tu hijo.`,
          type: 'informacion',
          sender: currentUser._id,
          account: newEvent.institucion,
          division: newEvent.division,
          recipients: studentIds, // Todos los estudiantes en una sola notificaci√≥n
          status: 'sent',
          priority: 'high'
        });

        // Guardar la notificaci√≥n
        await notification.save();
        console.log('üì¢ [CREATE EVENT] Notificaci√≥n √∫nica creada para', studentIds.length, 'estudiantes');
        
        // Enviar push notifications a usuarios familiares de todos los estudiantes
        console.log('üì¢ [CREATE EVENT] Enviando push notifications a familiares...');
        let totalSent = 0;
        let totalFailed = 0;
        
        for (const studentId of studentIds) {
          try {
            const pushResult = await sendPushNotificationToStudentFamily(studentId, notification);
            totalSent += pushResult.sent;
            totalFailed += pushResult.failed;
            console.log('üì¢ [CREATE EVENT] Push para estudiante', studentId, '- Enviados:', pushResult.sent, 'Fallidos:', pushResult.failed);
          } catch (pushError) {
            console.error('üì¢ [CREATE EVENT] Error enviando push para estudiante', studentId, ':', pushError.message);
            totalFailed++;
          }
        }
        
        console.log('üì¢ [CREATE EVENT] Resumen push notifications - Total enviados:', totalSent, 'Total fallidos:', totalFailed);

      } catch (notificationError) {
        console.error('‚ùå [CREATE EVENT] Error creando notificaciones:', notificationError);
        // No fallar la creaci√≥n del evento si fallan las notificaciones
      }
    }

    // Populate para la respuesta
    await newEvent.populate('creador', 'name email');
    await newEvent.populate('institucion', 'nombre');
    await newEvent.populate('division', 'nombre');

    const responseMessage = newEvent.requiereAutorizacion 
      ? 'Evento creado exitosamente. Se han enviado notificaciones a los padres para autorizaci√≥n.'
      : 'Evento creado exitosamente';

    res.status(201).json({
      success: true,
      message: responseMessage,
      data: {
        _id: newEvent._id,
        titulo: newEvent.titulo,
        descripcion: newEvent.descripcion,
        fecha: newEvent.fecha,
        hora: newEvent.hora,
        lugar: newEvent.lugar,
        estado: newEvent.estado,
        requiereAutorizacion: newEvent.requiereAutorizacion,
        creador: newEvent.creador,
        institucion: newEvent.institucion,
        division: newEvent.division,
        createdAt: newEvent.createdAt
      }
    });

  } catch (error) {
    console.error('‚ùå [CREATE EVENT] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor al crear evento'
    });
  }
});

// Obtener eventos por instituci√≥n (para todos los roles)
app.get('/events/institution/:institutionId', authenticateToken, async (req, res) => {
  try {
    const { institutionId } = req.params;
    const { page = 1, limit = 20, divisionId } = req.query;
    const currentUser = req.user;

    console.log('üìÖ [GET EVENTS] Instituci√≥n:', institutionId);
    if (divisionId) console.log('üìö [GET EVENTS] Divisi√≥n:', divisionId);
    console.log('üë§ [GET EVENTS] Usuario:', currentUser._id, currentUser.role?.nombre);

    // Verificar que el usuario tiene acceso a la instituci√≥n
    const assocFilter = {
      user: currentUser._id,
      account: institutionId,
      status: { $in: ['active', 'pending'] }
    };
    if (divisionId) {
      // Si se solicita una divisi√≥n espec√≠fica, validar acceso a esa divisi√≥n
      assocFilter.division = divisionId;
    }
    const userAssociation = await Shared.findOne(assocFilter);

    if (!userAssociation) {
      // Requerimiento: no retornar 404/403 cuando no hay acceso o no hay datos.
      // Responder 200 con lista vac√≠a para mantener idempotencia del GET.
      return res.json({
        success: true,
        data: {
          events: [],
          total: 0,
          page: parseInt(page),
          limit: parseInt(limit)
        }
      });
    }

    // Obtener eventos
    const query = { institucion: institutionId };
    if (divisionId) {
      query.division = divisionId;
    }
    const total = await Event.countDocuments(query);
    const events = await Event.find(query)
      .populate('creador', 'name email')
      .populate('institucion', 'nombre')
      .populate('division', 'nombre')
      .skip((page - 1) * limit)
      .limit(limit)
      .sort({ fecha: 1 });

    console.log('üìÖ [GET EVENTS] Eventos encontrados:', events.length);
    
    res.json({
      success: true,
      data: {
        events: events.map(event => ({
          _id: event._id,
          titulo: event.titulo,
          descripcion: event.descripcion,
          fecha: event.fecha,
          hora: event.hora,
          lugar: event.lugar,
          estado: event.estado,
          requiereAutorizacion: event.requiereAutorizacion,
          creador: event.creador,
          institucion: event.institucion,
          division: event.division,
          createdAt: event.createdAt
        })),
        total,
        page: parseInt(page),
        limit: parseInt(limit)
      }
    });

  } catch (error) {
    console.error('‚ùå [GET EVENTS] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor al obtener eventos'
    });
  }
});

// ===== ENDPOINTS DE AUTORIZACI√ìN DE EVENTOS =====

// Autorizar evento (solo familyadmin)
app.post('/events/:eventId/authorize', authenticateToken, async (req, res) => {
  try {
    const { eventId } = req.params;
    const { studentId, autorizado, comentarios } = req.body;
    const currentUser = req.user;

    console.log('‚úÖ [AUTHORIZE EVENT] Evento:', eventId);
    console.log('üë§ [AUTHORIZE EVENT] Usuario:', currentUser._id, currentUser.role?.nombre);
    console.log('üë®‚Äçüéì [AUTHORIZE EVENT] Estudiante:', studentId);
    console.log('‚úÖ [AUTHORIZE EVENT] Autorizado:', autorizado);

    // Verificar que el usuario tiene asociaci√≥n activa como familyadmin
    const activeAssociation = await ActiveAssociation.getActiveAssociation(currentUser._id);
    
    if (!activeAssociation) {
      return res.status(403).json({
        success: false,
        message: 'No tienes una asociaci√≥n activa'
      });
    }

    // Obtener los detalles de la asociaci√≥n activa
    const activeShared = await Shared.findById(activeAssociation.activeShared).populate('role');
    
    if (activeShared.role?.nombre !== 'familyadmin') {
      return res.status(403).json({
        success: false,
        message: 'Solo los tutores principales pueden autorizar eventos'
      });
    }

    // Verificar que el evento existe y requiere autorizaci√≥n
    const event = await Event.findById(eventId);
    if (!event) {
      return res.status(404).json({
        success: false,
        message: 'Evento no encontrado'
      });
    }

    if (!event.requiereAutorizacion) {
      return res.status(400).json({
        success: false,
        message: 'Este evento no requiere autorizaci√≥n'
      });
    }

    // Verificar que el usuario tiene acceso al estudiante
    const studentAssociation = await Shared.findOne({
      user: currentUser._id,
      student: studentId,
      status: 'active'
    });

    if (!studentAssociation) {
      return res.status(403).json({
        success: false,
        message: 'No tienes acceso a este estudiante'
      });
    }

    // Buscar o crear la autorizaci√≥n
    let authorization = await EventAuthorization.findOne({
      event: eventId,
      student: studentId
    });

    if (authorization) {
      // Actualizar autorizaci√≥n existente
      authorization.autorizado = autorizado;
      authorization.fechaAutorizacion = autorizado ? new Date() : null;
      authorization.comentarios = comentarios || '';
    } else {
      // Crear nueva autorizaci√≥n
      authorization = new EventAuthorization({
        event: eventId,
        student: studentId,
        familyadmin: currentUser._id,
        autorizado: autorizado,
        fechaAutorizacion: autorizado ? new Date() : null,
        comentarios: comentarios || ''
      });
    }

    await authorization.save();

    console.log('‚úÖ [AUTHORIZE EVENT] Autorizaci√≥n guardada:', authorization._id);

    res.json({
      success: true,
      message: autorizado ? 'Evento autorizado exitosamente' : 'Autorizaci√≥n revocada exitosamente',
      data: {
        _id: authorization._id,
        event: eventId,
        student: studentId,
        autorizado: authorization.autorizado,
        fechaAutorizacion: authorization.fechaAutorizacion,
        comentarios: authorization.comentarios
      }
    });

  } catch (error) {
    console.error('‚ùå [AUTHORIZE EVENT] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor al autorizar evento'
    });
  }
});

// Obtener autorizaciones de un evento (solo coordinadores)
app.get('/events/:eventId/authorizations', authenticateToken, async (req, res) => {
  try {
    const { eventId } = req.params;
    const currentUser = req.user;

    console.log('üìã [GET AUTHORIZATIONS] Evento:', eventId);
    console.log('üë§ [GET AUTHORIZATIONS] Usuario:', currentUser._id, currentUser.role?.nombre);
    console.log('üë§ [GET AUTHORIZATIONS] Role completo:', currentUser.role);
    console.log('üë§ [GET AUTHORIZATIONS] ¬øEs coordinador?', currentUser.role?.nombre === 'coordinador');

    // Verificar que el usuario es coordinador
    if (currentUser.role?.nombre !== 'coordinador') {
      console.log('üìã [GET AUTHORIZATIONS] ERROR: Usuario no es coordinador');
      console.log('üìã [GET AUTHORIZATIONS] Role actual:', currentUser.role?.nombre);
      return res.status(403).json({
        success: false,
        message: 'Solo los coordinadores pueden ver las autorizaciones'
      });
    }

    // Verificar que el evento existe
    const event = await Event.findById(eventId).populate('institucion division');
    if (!event) {
      return res.status(404).json({
        success: false,
        message: 'Evento no encontrado'
      });
    }

    // Verificar que el usuario tiene acceso al evento
    const userAssociation = await Shared.findOne({
      user: currentUser._id,
      account: event.institucion._id,
      status: { $in: ['active', 'pending'] }
    }).populate('division');

    console.log('üìã [GET AUTHORIZATIONS] Evento institucion:', event.institucion._id);
    console.log('üìã [GET AUTHORIZATIONS] Usuario asociaciones:', userAssociation);
    console.log('üìã [GET AUTHORIZATIONS] ¬øTiene acceso?', !!userAssociation);

    if (!userAssociation) {
      console.log('üìã [GET AUTHORIZATIONS] ERROR: No tiene acceso al evento');
      return res.status(403).json({
        success: false,
        message: 'No tienes acceso a este evento'
      });
    }

    console.log('üìã [GET AUTHORIZATIONS] Asociaci√≥n del coordinador:', {
      account: userAssociation.account,
      division: userAssociation.division?._id,
      divisionName: userAssociation.division?.nombre
    });

    // Obtener todas las autorizaciones del evento
    const authorizations = await EventAuthorization.find({ event: eventId })
      .populate('student', 'nombre apellido')
      .populate('familyadmin', 'name email')
      .sort({ createdAt: 1 });

    // Obtener todos los estudiantes de la divisi√≥n del coordinador
    let allStudents = [];
    if (userAssociation.division) {
      allStudents = await Student.find({ 
        division: userAssociation.division._id,
        activo: true 
      }).select('nombre apellido');
      console.log('üìã [GET AUTHORIZATIONS] Divisi√≥n del coordinador:', userAssociation.division._id);
      console.log('üìã [GET AUTHORIZATIONS] Estudiantes encontrados en divisi√≥n del coordinador:', allStudents.length);
    } else {
      console.log('üìã [GET AUTHORIZATIONS] Coordinador sin divisi√≥n espec√≠fica');
    }

    // Separar estudiantes con y sin autorizaci√≥n
    const studentsWithAuth = authorizations.map(auth => auth.student._id.toString());
    const studentsWithoutAuth = allStudents.filter(student => 
      !studentsWithAuth.includes(student._id.toString())
    );

    // Crear lista completa de estudiantes pendientes (todos los de la divisi√≥n)
    const allStudentsForPending = allStudents.map(student => {
      const existingAuth = authorizations.find(auth => 
        auth.student._id.toString() === student._id.toString()
      );
      
      return {
        _id: student._id,
        nombre: student.nombre,
        apellido: student.apellido,
        hasResponse: !!existingAuth,
        autorizado: existingAuth?.autorizado || false
      };
    });

    const autorizados = authorizations.filter(auth => auth.autorizado).length;
    const rechazados = authorizations.filter(auth => !auth.autorizado).length;
    const sinRespuesta = allStudents.length - authorizations.length;
    const pendientes = allStudents.length - autorizados;

    console.log('üìã [GET AUTHORIZATIONS] Autorizaciones encontradas:', authorizations.length);
    console.log('üìã [GET AUTHORIZATIONS] Estudiantes sin autorizaci√≥n:', studentsWithoutAuth.length);
    console.log('üìã [GET AUTHORIZATIONS] Total estudiantes en divisi√≥n:', allStudents.length);
    console.log('üìã [GET AUTHORIZATIONS] Autorizaciones aprobadas:', autorizados);
    console.log('üìã [GET AUTHORIZATIONS] Autorizaciones rechazadas:', rechazados);
    console.log('üìã [GET AUTHORIZATIONS] Sin respuesta:', sinRespuesta);
    console.log('üìã [GET AUTHORIZATIONS] Pendientes (total - autorizados):', pendientes);
    console.log('üìã [GET AUTHORIZATIONS] Verificaci√≥n: autorizados + rechazados + sinRespuesta =', autorizados + rechazados + sinRespuesta, 'vs total =', allStudents.length);

    res.json({
      success: true,
      data: {
        event: {
          _id: event._id,
          titulo: event.titulo,
          fecha: event.fecha,
          hora: event.hora,
          institucion: event.institucion,
          division: event.division
        },
        authorizations: authorizations.map(auth => ({
          _id: auth._id,
          student: {
            _id: auth.student._id,
            nombre: auth.student.nombre,
            apellido: auth.student.apellido
          },
          familyadmin: {
            _id: auth.familyadmin._id,
            name: auth.familyadmin.name,
            email: auth.familyadmin.email
          },
          autorizado: auth.autorizado,
          fechaAutorizacion: auth.fechaAutorizacion,
          comentarios: auth.comentarios
        })),
        studentsWithoutAuth: studentsWithoutAuth.map(student => ({
          _id: student._id,
          nombre: student.nombre,
          apellido: student.apellido
        })),
        allStudentsPending: allStudentsForPending,
        summary: {
          total: allStudents.length,
          autorizados: autorizados,
          rechazados: rechazados,
          sinRespuesta: sinRespuesta,
          pendientes: pendientes
        }
      }
    });

  } catch (error) {
    console.error('‚ùå [GET AUTHORIZATIONS] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor al obtener autorizaciones'
    });
  }
});

// Verificar autorizaci√≥n de un evento para un estudiante (para familyadmin)
app.get('/events/:eventId/authorization/:studentId', authenticateToken, async (req, res) => {
  try {
    const { eventId, studentId } = req.params;
    const currentUser = req.user;

    console.log('üîç [CHECK AUTHORIZATION] Evento:', eventId);
    console.log('üë®‚Äçüéì [CHECK AUTHORIZATION] Estudiante:', studentId);
    console.log('üë§ [CHECK AUTHORIZATION] Usuario:', currentUser._id, currentUser.role?.nombre);

    // Verificar que el usuario tiene asociaci√≥n activa como familyadmin
    const activeAssociation = await ActiveAssociation.getActiveAssociation(currentUser._id);
    
    if (!activeAssociation) {
      return res.status(403).json({
        success: false,
        message: 'No tienes una asociaci√≥n activa'
      });
    }

    // Obtener los detalles de la asociaci√≥n activa
    const activeShared = await Shared.findById(activeAssociation.activeShared).populate('role');
    
    if (activeShared.role?.nombre !== 'familyadmin') {
      return res.status(403).json({
        success: false,
        message: 'Solo los tutores principales pueden verificar autorizaciones'
      });
    }

    // Verificar que el evento existe
    const event = await Event.findById(eventId);
    if (!event) {
      return res.status(404).json({
        success: false,
        message: 'Evento no encontrado'
      });
    }

    // Verificar que el usuario tiene acceso al estudiante
    const studentAssociation = await Shared.findOne({
      user: currentUser._id,
      student: studentId,
      status: 'active'
    });

    if (!studentAssociation) {
      return res.status(403).json({
        success: false,
        message: 'No tienes acceso a este estudiante'
      });
    }

    // Buscar la autorizaci√≥n
    const authorization = await EventAuthorization.findOne({
      event: eventId,
      student: studentId
    });

    res.json({
      success: true,
      data: {
        event: {
          _id: event._id,
          titulo: event.titulo,
          requiereAutorizacion: event.requiereAutorizacion
        },
        authorization: authorization ? {
          _id: authorization._id,
          autorizado: authorization.autorizado,
          fechaAutorizacion: authorization.fechaAutorizacion,
          comentarios: authorization.comentarios
        } : null
      }
    });

  } catch (error) {
    console.error('‚ùå [CHECK AUTHORIZATION] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor al verificar autorizaci√≥n'
    });
  }
});

// ===== ENDPOINTS PARA LOGOS DE CUENTAS =====

// Actualizar logo de una cuenta
app.put('/accounts/:accountId/logo', authenticateToken, async (req, res) => {
  try {
    const { accountId } = req.params;
    const { imageKey } = req.body;
    const currentUser = req.user;

    console.log('üñºÔ∏è [UPDATE LOGO] Cuenta:', accountId);
    console.log('üñºÔ∏è [UPDATE LOGO] Image Key:', imageKey);
    console.log('üë§ [UPDATE LOGO] Usuario:', currentUser._id, currentUser.role?.nombre);

    // Verificar que el usuario tiene permisos para actualizar la cuenta
    if (currentUser.role?.nombre !== 'superadmin' && currentUser.role?.nombre !== 'adminaccount') {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para actualizar logos de cuentas'
      });
    }

    // Verificar que la cuenta existe
    const account = await Account.findById(accountId);
    if (!account) {
      return res.status(404).json({
        success: false,
        message: 'Cuenta no encontrada'
      });
    }

    // Si el usuario es adminaccount, verificar que pertenece a esa cuenta
    if (currentUser.role?.nombre === 'adminaccount') {
      const userAssociation = await Shared.findOne({
        user: currentUser._id,
        account: accountId,
        status: 'active'
      });

      if (!userAssociation) {
        return res.status(403).json({
          success: false,
          message: 'No tienes permisos para actualizar esta cuenta'
        });
      }
    }

    // Actualizar el logo de la cuenta
    account.logo = imageKey;
    await account.save();

    console.log('üñºÔ∏è [UPDATE LOGO] Logo actualizado exitosamente');

    res.json({
      success: true,
      message: 'Logo actualizado exitosamente',
      data: {
        accountId: account._id,
        logo: account.logo,
        logoUrl: `https://${process.env.AWS_S3_BUCKET_NAME}.s3.${process.env.AWS_REGION || 'us-east-1'}.amazonaws.com/${imageKey}`
      }
    });

  } catch (error) {
    console.error('‚ùå [UPDATE LOGO] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor al actualizar el logo'
    });
  }
});

// Obtener logo de una cuenta
app.get('/accounts/:accountId/logo', authenticateToken, async (req, res) => {
  try {
    const { accountId } = req.params;
    const currentUser = req.user;

    console.log('üñºÔ∏è [GET LOGO] Cuenta:', accountId);
    console.log('üë§ [GET LOGO] Usuario:', currentUser._id);

    // Verificar que la cuenta existe
    const account = await Account.findById(accountId);
    if (!account) {
      return res.status(404).json({
        success: false,
        message: 'Cuenta no encontrada'
      });
    }

    // Verificar que el usuario tiene acceso a la cuenta
    const userAssociation = await Shared.findOne({
      user: currentUser._id,
      account: accountId,
      status: { $in: ['active', 'pending'] }
    });

    if (!userAssociation && currentUser.role?.nombre !== 'superadmin') {
      return res.status(403).json({
        success: false,
        message: 'No tienes acceso a esta cuenta'
      });
    }

    const logoUrl = account.logo 
      ? `https://${process.env.AWS_S3_BUCKET_NAME}.s3.${process.env.AWS_REGION || 'us-east-1'}.amazonaws.com/${account.logo}`
      : null;

    res.json({
      success: true,
      data: {
        accountId: account._id,
        logo: account.logo,
        logoUrl: logoUrl
      }
    });

  } catch (error) {
    console.error('‚ùå [GET LOGO] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor al obtener el logo'
    });
  }
});

// ===== ENDPOINTS DE ASISTENCIAS PARA BACKOFFICE =====

// Obtener resumen de asistencias para calendario (solo fechas con asistencias)
app.get('/backoffice/asistencias/calendar', authenticateToken, getCognitoUserInstitution, async (req, res) => {
  try {
    const { 
      grupoId,
      fechaInicio,
      fechaFin
    } = req.query;
    
    console.log('üìÖ [CALENDAR ASISTENCIAS] Par√°metros:', { grupoId, fechaInicio, fechaFin });
    
    // Verificar permisos del usuario
    let currentUser;
    if (req.user.isCognitoUser) {
      currentUser = await User.findOne({ email: req.user.email }).populate('role');
    } else {
      const { userId } = req.user;
      currentUser = await User.findById(userId).populate('role');
    }
    
    if (!currentUser) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    // Construir query base
    let query = {};
    
    // L√≥gica seg√∫n el rol
    if (currentUser.role?.nombre === 'superadmin') {
      // Superadmin ve todas las asistencias
    } else if (currentUser.role?.nombre === 'adminaccount') {
      // Adminaccount ve todas las asistencias de su cuenta
      if (req.userInstitution) {
        query.account = req.userInstitution._id;
      } else {
        return res.status(403).json({
          success: false,
          message: 'No tienes una instituci√≥n asignada'
        });
      }
    } else {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para acceder a esta secci√≥n'
      });
    }
    
    // Filtros adicionales
    if (grupoId) {
      query.division = grupoId;
    }
    
    if (fechaInicio && fechaFin) {
      query.fecha = {
        $gte: fechaInicio,
        $lte: fechaFin
      };
    }
    
    console.log('üìÖ [CALENDAR ASISTENCIAS] Query:', JSON.stringify(query, null, 2));
    
    // Obtener solo fechas y conteos (sin populate para mejor rendimiento)
    const asistencias = await Asistencia.find(query)
      .select('fecha estudiantes')
      .sort({ fecha: -1 });
    
    // Crear mapa de fechas con conteos
    const calendarData = {};
    asistencias.forEach(asistencia => {
      calendarData[asistencia.fecha] = {
        fecha: asistencia.fecha,
        totalEstudiantes: asistencia.estudiantes.length,
        presentes: asistencia.estudiantes.filter(e => e.presente).length,
        ausentes: asistencia.estudiantes.filter(e => !e.presente).length
      };
    });
    
    console.log('üìÖ [CALENDAR ASISTENCIAS] Datos del calendario:', Object.keys(calendarData).length, 'd√≠as');
    
    res.json({
      success: true,
      data: calendarData
    });

  } catch (error) {
    console.error('‚ùå [CALENDAR ASISTENCIAS] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener datos del calendario'
    });
  }
});

// Obtener asistencias detalladas para un d√≠a espec√≠fico
app.get('/backoffice/asistencias/day/:fecha', authenticateToken, getCognitoUserInstitution, async (req, res) => {
  try {
    const { fecha } = req.params;
    const { grupoId } = req.query;
    
    console.log('üìã [DAY ASISTENCIAS] Fecha:', fecha);
    console.log('üìã [DAY ASISTENCIAS] GrupoId:', grupoId);
    
    // Verificar permisos del usuario
    let currentUser;
    if (req.user.isCognitoUser) {
      currentUser = await User.findOne({ email: req.user.email }).populate('role');
    } else {
      const { userId } = req.user;
      currentUser = await User.findById(userId).populate('role');
    }
    
    if (!currentUser) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    const userId = currentUser._id;
    console.log('üìã [DAY ASISTENCIAS] Usuario:', userId);
    
    // Obtener informaci√≥n del usuario para verificar su rol
    const user = await User.findById(userId).populate('role');
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    // Construir query base
    let query = { fecha };
    
    // L√≥gica seg√∫n el rol
    if (user.role?.nombre === 'superadmin') {
      // Superadmin ve todas las asistencias
    } else if (user.role?.nombre === 'adminaccount') {
      // Adminaccount ve todas las asistencias de su cuenta
      query.account = user.account?._id;
    } else {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para acceder a esta secci√≥n'
      });
    }
    
    // Filtros adicionales
    if (grupoId) {
      query.division = grupoId;
    }
    
    console.log('üìã [DAY ASISTENCIAS] Query:', JSON.stringify(query, null, 2));
    
    // Obtener asistencias con todos los datos poblados
    const asistencias = await Asistencia.find(query)
      .populate('account', 'nombre')
      .populate('division', 'nombre')
      .populate('creadoPor', 'nombre email')
      .populate({
        path: 'estudiantes.student',
        select: 'nombre apellido email avatar'
      })
      .sort({ createdAt: -1 })
      .lean(); // Usar lean() para obtener objetos planos
    
    // Hacer populate manual de los estudiantes ya que hay inconsistencia entre modelo y datos
    for (let asistencia of asistencias) {
      for (let estudiante of asistencia.estudiantes) {
        // El campo en los datos reales se llama 'estudiante', no 'student'
        const studentId = estudiante.estudiante || estudiante.student;
        
        if (studentId && mongoose.Types.ObjectId.isValid(studentId)) {
          const studentData = await Student.findById(studentId).select('nombre apellido email avatar');
          if (studentData) {
            // Reemplazar el ID con los datos del estudiante
            estudiante.student = studentData;
          }
        }
      }
    }
    
    console.log('üìã [DAY ASISTENCIAS] Asistencias encontradas:', asistencias.length);
    
    res.json({
      success: true,
      data: asistencias
    });

  } catch (error) {
    console.error('‚ùå [DAY ASISTENCIAS] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener asistencias del d√≠a'
    });
  }
});

// Obtener asistencias del backoffice con paginaci√≥n
app.get('/backoffice/asistencias', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const { 
      page = 1, 
      limit = 10, 
      accountId,
      grupoId,
      alumnoId,
      fechaInicio,
      fechaFin,
      estado,
      search
    } = req.query;
    
    console.log('üìä [BACKOFFICE ASISTENCIAS] Usuario:', userId);
    console.log('üìä [BACKOFFICE ASISTENCIAS] Par√°metros:', { accountId, grupoId, alumnoId, fechaInicio, fechaFin, estado, search });
    
    // Obtener informaci√≥n del usuario para verificar su rol
    const user = await User.findById(userId).populate('role');
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    console.log('üìä [BACKOFFICE ASISTENCIAS] Rol del usuario:', user.role?.nombre);
    
    // Construir query base
    let query = {};
    
    // L√≥gica seg√∫n el rol
    if (user.role?.nombre === 'superadmin') {
      // Superadmin ve todas las asistencias de todas las cuentas
      if (accountId) {
        query.account = accountId;
      }
    } else if (user.role?.nombre === 'adminaccount') {
      // Adminaccount ve todas las asistencias de su cuenta
      query.account = user.account?._id;
    } else {
      // Otros roles no tienen acceso al backoffice
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para acceder a esta secci√≥n'
      });
    }
    
    // Filtros adicionales
    if (grupoId) {
      query.division = grupoId;
    }
    
    if (alumnoId) {
      query.alumno = alumnoId;
    }
    
    if (fechaInicio && fechaFin) {
      // El campo fecha es String en formato YYYY-MM-DD, no Date
      console.log('üìä [BACKOFFICE ASISTENCIAS] Aplicando filtro de fechas:', { fechaInicio, fechaFin });
      query.fecha = {
        $gte: fechaInicio,
        $lte: fechaFin
      };
    } else if (fechaInicio) {
      console.log('üìä [BACKOFFICE ASISTENCIAS] Aplicando filtro fecha inicio:', fechaInicio);
      query.fecha = { $gte: fechaInicio };
    } else if (fechaFin) {
      console.log('üìä [BACKOFFICE ASISTENCIAS] Aplicando filtro fecha fin:', fechaFin);
      query.fecha = { $lte: fechaFin };
    }
    
    if (estado && estado !== 'all') {
      query.estado = estado;
    }
    
    if (search) {
      query.$or = [
        { 'alumno.nombre': { $regex: search, $options: 'i' } },
        { 'alumno.email': { $regex: search, $options: 'i' } },
        { observaciones: { $regex: search, $options: 'i' } }
      ];
    }
    
    console.log('üìä [BACKOFFICE ASISTENCIAS] Query final:', JSON.stringify(query, null, 2));
    console.log('üìä [BACKOFFICE ASISTENCIAS] Query fecha espec√≠fico:', JSON.stringify(query.fecha, null, 2));
    
    // Obtener total de asistencias para la paginaci√≥n
    const total = await Asistencia.countDocuments(query);
    
    // Calcular skip para paginaci√≥n
    const skip = (parseInt(page) - 1) * parseInt(limit);
    
    // Obtener asistencias con paginaci√≥n
    const asistencias = await Asistencia.find(query)
      .populate('account', 'nombre')
      .populate('division', 'nombre')
      .populate('creadoPor', 'nombre email')
      .populate({
        path: 'estudiantes.student',
        select: 'nombre apellido email avatar',
        populate: {
          path: 'avatar',
          select: 'url'
        }
      })
      .sort({ fecha: -1, createdAt: -1 })
      .skip(skip)
      .limit(parseInt(limit));
    
    console.log('üìä [BACKOFFICE ASISTENCIAS] Asistencias encontradas:', asistencias.length);
    if (asistencias.length > 0) {
      console.log('üìä [BACKOFFICE ASISTENCIAS] Primera asistencia:', JSON.stringify(asistencias[0], null, 2));
      if (asistencias[0].estudiantes && asistencias[0].estudiantes.length > 0) {
        console.log('üìä [BACKOFFICE ASISTENCIAS] Primer estudiante:', JSON.stringify(asistencias[0].estudiantes[0], null, 2));
      }
    }
    
    // Calcular informaci√≥n de paginaci√≥n
    const currentPage = parseInt(page);
    const totalPages = Math.ceil(total / parseInt(limit));
    const hasNextPage = currentPage < totalPages;
    const hasPrevPage = currentPage > 1;
    
    console.log('üìä [BACKOFFICE ASISTENCIAS] Asistencias encontradas:', asistencias.length);
    console.log('üìä [BACKOFFICE ASISTENCIAS] Paginaci√≥n:', { currentPage, totalPages, total });
    
    res.json({
      success: true,
      data: asistencias,
      pagination: {
        currentPage,
        totalPages,
        totalItems: total,
        itemsPerPage: parseInt(limit),
        hasNextPage,
        hasPrevPage
      }
    });
    
  } catch (error) {
    console.error('‚ùå [BACKOFFICE ASISTENCIAS] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener asistencias'
    });
  }
});

// Crear asistencia desde el backoffice
app.post('/backoffice/asistencias', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const { alumnoId, accountId, grupoId, fecha, estado, horaLlegada, horaSalida, observaciones } = req.body;
    
    console.log('üìä [BACKOFFICE ASISTENCIAS CREATE] Usuario:', userId);
    console.log('üìä [BACKOFFICE ASISTENCIAS CREATE] Datos:', { alumnoId, accountId, grupoId, fecha, estado });
    
    // Obtener informaci√≥n del usuario para verificar su rol
    const user = await User.findById(userId).populate('role');
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    // Verificar permisos
    if (user.role?.nombre !== 'superadmin' && user.role?.nombre !== 'adminaccount') {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para crear asistencias'
      });
    }
    
    // Para adminaccount, verificar que la cuenta pertenece al usuario
    if (user.role?.nombre === 'adminaccount' && accountId !== user.account?._id?.toString()) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para crear asistencias en esta cuenta'
      });
    }
    
    // Verificar que el alumno existe y pertenece a la cuenta
    const alumno = await User.findById(alumnoId);
    if (!alumno) {
      return res.status(404).json({
        success: false,
        message: 'Alumno no encontrado'
      });
    }
    
    // Verificar que el grupo existe y pertenece a la cuenta (si se proporciona)
    if (grupoId) {
      const grupo = await Group.findById(grupoId);
      if (!grupo || grupo.account.toString() !== accountId) {
        return res.status(404).json({
          success: false,
          message: 'Grupo no encontrado o no pertenece a la cuenta'
        });
      }
    }
    
    // Crear la asistencia
    const nuevaAsistencia = new Asistencia({
      account: accountId,
      division: grupoId,
      fecha: fecha,
      estudiantes: [{
        student: alumnoId,
        presente: estado === 'presente'
      }],
      creadoPor: userId
    });
    
    await nuevaAsistencia.save();
    
    // Poblar los datos para la respuesta
    await nuevaAsistencia.populate('account', 'nombre');
    await nuevaAsistencia.populate('division', 'nombre');
    await nuevaAsistencia.populate('creadoPor', 'nombre email');
    await nuevaAsistencia.populate('estudiantes.student', 'nombre apellido email');
    
    console.log('üìä [BACKOFFICE ASISTENCIAS CREATE] Asistencia creada exitosamente');
    
    res.status(201).json({
      success: true,
      message: 'Asistencia registrada exitosamente',
      data: nuevaAsistencia
    });
    
  } catch (error) {
    console.error('‚ùå [BACKOFFICE ASISTENCIAS CREATE] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al crear asistencia'
    });
  }
});

// Actualizar asistencia desde el backoffice
app.put('/backoffice/asistencias/:asistenciaId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const { asistenciaId } = req.params;
    const { estado, horaLlegada, horaSalida, observaciones } = req.body;
    
    console.log('üìä [BACKOFFICE ASISTENCIAS UPDATE] Usuario:', userId);
    console.log('üìä [BACKOFFICE ASISTENCIAS UPDATE] Asistencia:', asistenciaId);
    
    // Obtener informaci√≥n del usuario para verificar su rol
    const user = await User.findById(userId).populate('role');
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    // Verificar permisos
    if (user.role?.nombre !== 'superadmin' && user.role?.nombre !== 'adminaccount') {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para actualizar asistencias'
      });
    }
    
    // Buscar la asistencia
    const asistencia = await Asistencia.findById(asistenciaId);
    if (!asistencia) {
      return res.status(404).json({
        success: false,
        message: 'Asistencia no encontrada'
      });
    }
    
    // Para adminaccount, verificar que la asistencia pertenece a su cuenta
    if (user.role?.nombre === 'adminaccount' && asistencia.account.toString() !== user.account?._id?.toString()) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para actualizar esta asistencia'
      });
    }
    
    // Actualizar la asistencia
    const updateData = {};
    if (estado) {
      // Actualizar el estado del estudiante en el array
      updateData.$set = {
        'estudiantes.$.presente': estado === 'presente'
      };
    }
    
    const asistenciaActualizada = await Asistencia.findByIdAndUpdate(
      asistenciaId,
      updateData,
      { new: true }
    ).populate('account', 'nombre')
     .populate('division', 'nombre')
     .populate('creadoPor', 'nombre email')
     .populate('estudiantes.student', 'nombre apellido email');
    
    console.log('üìä [BACKOFFICE ASISTENCIAS UPDATE] Asistencia actualizada exitosamente');
    
    res.json({
      success: true,
      message: 'Asistencia actualizada exitosamente',
      data: asistenciaActualizada
    });
    
  } catch (error) {
    console.error('‚ùå [BACKOFFICE ASISTENCIAS UPDATE] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al actualizar asistencia'
    });
  }
});

// Eliminar asistencia desde el backoffice
app.delete('/backoffice/asistencias/:asistenciaId', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const { asistenciaId } = req.params;
    
    console.log('üìä [BACKOFFICE ASISTENCIAS DELETE] Usuario:', userId);
    console.log('üìä [BACKOFFICE ASISTENCIAS DELETE] Asistencia:', asistenciaId);
    
    // Obtener informaci√≥n del usuario para verificar su rol
    const user = await User.findById(userId).populate('role');
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    // Verificar permisos
    if (user.role?.nombre !== 'superadmin' && user.role?.nombre !== 'adminaccount') {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para eliminar asistencias'
      });
    }
    
    // Buscar la asistencia
    const asistencia = await Asistencia.findById(asistenciaId);
    if (!asistencia) {
      return res.status(404).json({
        success: false,
        message: 'Asistencia no encontrada'
      });
    }
    
    // Para adminaccount, verificar que la asistencia pertenece a su cuenta
    if (user.role?.nombre === 'adminaccount' && asistencia.account.toString() !== user.account?._id?.toString()) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para eliminar esta asistencia'
      });
    }
    
    // Eliminar la asistencia
    await Asistencia.findByIdAndDelete(asistenciaId);
    
    console.log('üìä [BACKOFFICE ASISTENCIAS DELETE] Asistencia eliminada exitosamente');
    
    res.json({
      success: true,
      message: 'Asistencia eliminada exitosamente'
    });
    
  } catch (error) {
    console.error('‚ùå [BACKOFFICE ASISTENCIAS DELETE] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al eliminar asistencia'
    });
  }
});

// Obtener estad√≠sticas de asistencias
app.get('/backoffice/asistencias/stats', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const { accountId, fechaInicio, fechaFin } = req.query;
    
    console.log('üìä [BACKOFFICE ASISTENCIAS STATS] Usuario:', userId);
    console.log('üìä [BACKOFFICE ASISTENCIAS STATS] Par√°metros:', { accountId, fechaInicio, fechaFin });
    
    // Obtener informaci√≥n del usuario para verificar su rol
    const user = await User.findById(userId).populate('role');
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    // Verificar permisos
    if (user.role?.nombre !== 'superadmin' && user.role?.nombre !== 'adminaccount') {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver estad√≠sticas'
      });
    }
    
    // Construir query base
    let query = {};
    
    // L√≥gica seg√∫n el rol
    if (user.role?.nombre === 'superadmin') {
      if (accountId) {
        query.account = accountId;
      }
    } else if (user.role?.nombre === 'adminaccount') {
      query.account = user.account?._id;
    }
    
    // Filtros de fecha
    if (fechaInicio && fechaFin) {
      query.fecha = {
        $gte: fechaInicio,
        $lte: fechaFin
      };
    } else if (fechaInicio) {
      query.fecha = { $gte: new Date(fechaInicio) };
    } else if (fechaFin) {
      query.fecha = { $lte: fechaFin };
    }
    
    // Obtener estad√≠sticas
    const totalAsistencias = await Asistencia.countDocuments(query);
    
    const statsPorEstado = await Asistencia.aggregate([
      { $match: query },
      {
        $group: {
          _id: '$estado',
          count: { $sum: 1 }
        }
      }
    ]);
    
    const statsPorDia = await Asistencia.aggregate([
      { $match: query },
      {
        $group: {
          _id: { $dateToString: { format: '%Y-%m-%d', date: '$fecha' } },
          count: { $sum: 1 }
        }
      },
      { $sort: { _id: -1 } },
      { $limit: 30 }
    ]);
    
    console.log('üìä [BACKOFFICE ASISTENCIAS STATS] Estad√≠sticas calculadas exitosamente');
    
    res.json({
      success: true,
      data: {
        totalAsistencias,
        statsPorEstado,
        statsPorDia
      }
    });
    
  } catch (error) {
    console.error('‚ùå [BACKOFFICE ASISTENCIAS STATS] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al obtener estad√≠sticas'
    });
  }
});

// Exportar asistencias a CSV
app.get('/backoffice/asistencias/export', authenticateToken, async (req, res) => {
  try {
    const userId = req.user.userId;
    const { accountId, grupoId, fechaInicio, fechaFin, estado } = req.query;
    
    console.log('üìä [BACKOFFICE ASISTENCIAS EXPORT] Usuario:', userId);
    console.log('üìä [BACKOFFICE ASISTENCIAS EXPORT] Par√°metros:', { accountId, grupoId, fechaInicio, fechaFin, estado });
    
    // Obtener informaci√≥n del usuario para verificar su rol
    const user = await User.findById(userId).populate('role');
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }
    
    // Verificar permisos
    if (user.role?.nombre !== 'superadmin' && user.role?.nombre !== 'adminaccount') {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para exportar asistencias'
      });
    }
    
    // Construir query base
    let query = {};
    
    // L√≥gica seg√∫n el rol
    if (user.role?.nombre === 'superadmin') {
      if (accountId) {
        query.account = accountId;
      }
    } else if (user.role?.nombre === 'adminaccount') {
      query.account = user.account?._id;
    }
    
    // Filtros adicionales
    if (grupoId) {
      query.division = grupoId;
    }
    
    if (fechaInicio && fechaFin) {
      query.fecha = {
        $gte: fechaInicio,
        $lte: fechaFin
      };
    } else if (fechaInicio) {
      query.fecha = { $gte: new Date(fechaInicio) };
    } else if (fechaFin) {
      query.fecha = { $lte: fechaFin };
    }
    
    if (estado && estado !== 'all') {
      query.estado = estado;
    }
    
    // Obtener asistencias
    const asistencias = await Asistencia.find(query)
      .populate('account', 'nombre')
      .populate('division', 'nombre')
      .populate('creadoPor', 'nombre email')
      .populate('estudiantes.student', 'nombre apellido email')
      .sort({ fecha: -1, createdAt: -1 });
    
    // Generar CSV
    const csvHeader = 'Fecha,Alumno,Email,Cuenta,Grupo,Estado,Hora Llegada,Hora Salida,Observaciones,Registrado Por\n';
    
    const csvRows = asistencias.flatMap(asistencia => {
      const fecha = new Date(asistencia.fecha).toLocaleDateString('es-ES');
      const cuenta = asistencia.account?.nombre || 'N/A';
      const grupo = asistencia.division?.nombre || 'N/A';
      const registradoPor = asistencia.creadoPor?.nombre || 'N/A';
      
      return asistencia.estudiantes.map(estudiante => {
        const alumno = estudiante.student ? `${estudiante.student.nombre} ${estudiante.student.apellido}` : 'N/A';
        const email = estudiante.student?.email || 'N/A';
        const estado = estudiante.presente ? 'presente' : 'ausente';
        
        return `"${fecha}","${alumno}","${email}","${cuenta}","${grupo}","${estado}","N/A","N/A","N/A","${registradoPor}"`;
      });
    }).join('\n');
    
    const csvContent = csvHeader + csvRows;
    
    console.log('üìä [BACKOFFICE ASISTENCIAS EXPORT] CSV generado exitosamente');
    
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', `attachment; filename="asistencias_${new Date().toISOString().split('T')[0]}.csv"`);
    res.send(csvContent);
    
  } catch (error) {
    console.error('‚ùå [BACKOFFICE ASISTENCIAS EXPORT] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error al exportar asistencias'
    });
  }
});

// ========================================
// ENDPOINTS CRUD PARA PICKUP (QUI√âN RETIRA)
// ========================================

// Obtener todas las personas autorizadas por cuenta (para backoffice)
app.get('/pickup/account/:accountId', async (req, res) => {
  try {
    const { accountId } = req.params;
    const { page = 1, limit = 20, division, student } = req.query;
    
    let query = { account: accountId, status: 'active' };
    
    if (division) {
      query.division = division;
    }
    
    if (student) {
      query.student = student;
    }
    
    const skip = (page - 1) * limit;
    
    const pickups = await Pickup.find(query)
      .populate('division', 'nombre')
      .populate('student', 'nombre apellido')
      .populate('createdBy', 'name')
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(parseInt(limit));
    
    const total = await Pickup.countDocuments(query);
    
    res.json({
      success: true,
      data: pickups,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    console.error('Error al obtener personas autorizadas:', error);
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// Obtener personas autorizadas por estudiante (para mobile)
app.get('/pickup/student/:studentId', async (req, res) => {
  try {
    const { studentId } = req.params;
    
    const pickups = await Pickup.find({ student: studentId, status: 'active' })
      .populate('account', 'nombre')
      .populate('division', 'nombre')
      .populate('student', 'nombre apellido')
      .populate('createdBy', 'name')
      .sort({ createdAt: -1 });
    
    res.json({
      success: true,
      data: pickups
    });
  } catch (error) {
    console.error('Error al obtener personas autorizadas por estudiante:', error);
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// Crear nueva persona autorizada
app.post('/pickup', async (req, res) => {
  try {
    const { account, division, student, nombre, apellido, dni, createdBy } = req.body;
    
    // Validar que no exista una persona con el mismo DNI para el mismo estudiante
    const existingPickup = await Pickup.findOne({ 
      student, 
      dni, 
      status: 'active' 
    });
    
    if (existingPickup) {
      return res.status(400).json({
        success: false,
        message: 'Ya existe una persona autorizada con este DNI para este estudiante'
      });
    }
    
    const pickup = new Pickup({
      account,
      division,
      student,
      nombre,
      apellido,
      dni,
      createdBy
    });
    
    await pickup.save();
    
    const populatedPickup = await Pickup.findById(pickup._id)
      .populate('account', 'nombre')
      .populate('division', 'nombre')
      .populate('student', 'nombre apellido')
      .populate('createdBy', 'name');
    
    res.status(201).json({
      success: true,
      data: populatedPickup,
      message: 'Persona autorizada creada correctamente'
    });
  } catch (error) {
    console.error('Error al crear persona autorizada:', error);
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// Actualizar persona autorizada
app.put('/pickup/:pickupId', async (req, res) => {
  try {
    const { pickupId } = req.params;
    const { nombre, apellido, dni } = req.body;
    
    const pickup = await Pickup.findById(pickupId);
    if (!pickup) {
      return res.status(404).json({ success: false, message: 'Persona autorizada no encontrada' });
    }
    
    // Validar que no exista otra persona con el mismo DNI para el mismo estudiante
    if (dni && dni !== pickup.dni) {
      const existingPickup = await Pickup.findOne({ 
        student: pickup.student, 
        dni, 
        status: 'active',
        _id: { $ne: pickupId }
      });
      
      if (existingPickup) {
        return res.status(400).json({
          success: false,
          message: 'Ya existe una persona autorizada con este DNI para este estudiante'
        });
      }
    }
    
    if (nombre) pickup.nombre = nombre;
    if (apellido) pickup.apellido = apellido;
    if (dni) pickup.dni = dni;
    
    await pickup.save();
    
    const updatedPickup = await Pickup.findById(pickupId)
      .populate('account', 'nombre')
      .populate('division', 'nombre')
      .populate('student', 'nombre apellido')
      .populate('createdBy', 'name');
    
    res.json({
      success: true,
      data: updatedPickup,
      message: 'Persona autorizada actualizada correctamente'
    });
  } catch (error) {
    console.error('Error al actualizar persona autorizada:', error);
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// Eliminar persona autorizada (soft delete)
app.delete('/pickup/:pickupId', async (req, res) => {
  try {
    const { pickupId } = req.params;
    
    const pickup = await Pickup.findById(pickupId);
    if (!pickup) {
      return res.status(404).json({ success: false, message: 'Persona autorizada no encontrada' });
    }
    
    pickup.status = 'inactive';
    await pickup.save();
    
    res.json({
      success: true,
      message: 'Persona autorizada eliminada correctamente'
    });
  } catch (error) {
    console.error('Error al eliminar persona autorizada:', error);
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// ========================================
// ENDPOINTS ADICIONALES PARA PICKUP SECTION
// ========================================

// Obtener divisiones por cuenta (para el frontend de pickup)
app.get('/divisions/account/:accountId', async (req, res) => {
  try {
    const { accountId } = req.params;
    
    // Buscar grupos que pertenecen a esta cuenta
    const grupos = await Grupo.find({ cuenta: accountId, activo: true })
      .populate('cuenta', 'nombre')
      .sort({ nombre: 1 });
    
    // Transformar grupos a formato de divisiones
    const divisions = grupos.map(grupo => ({
      _id: grupo._id,
      nombre: grupo.nombre
    }));
    
    res.json({
      success: true,
      data: divisions
    });
  } catch (error) {
    console.error('Error al obtener divisiones por cuenta:', error);
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// Obtener estudiantes por divisi√≥n (para el frontend de pickup)
app.get('/students/division/:divisionId', async (req, res) => {
  try {
    const { divisionId } = req.params;
    
    // Buscar estudiantes que pertenecen a esta divisi√≥n (grupo)
    const students = await Student.find({ division: divisionId })
      .populate('account', 'nombre')
      .populate('division', 'nombre')
      .sort({ apellido: 1, nombre: 1 });
    
    res.json({
      success: true,
      data: students
    });
  } catch (error) {
    console.error('Error al obtener estudiantes por divisi√≥n:', error);
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// ========================================
// ENDPOINTS ESPEC√çFICOS PARA MOBILE APP
// ========================================

// Obtener pickups para familyadmin por instituci√≥n + divisi√≥n
app.get('/pickups/familyadmin', authenticateToken, async (req, res) => {
  try {
    console.log('üéØ [PICKUP FAMILYADMIN GET] Obteniendo pickups');
    const { userId } = req.user;
    const { division, student, page = 1, limit = 20 } = req.query;
    
    console.log('üë§ [PICKUP FAMILYADMIN GET] Usuario:', userId);
    console.log('üìã [PICKUP FAMILYADMIN GET] Query params:', { division, student, page, limit });
    
    // Verificar que el usuario tiene una asociaci√≥n activa con rol familyadmin
    const activeAssociation = await ActiveAssociation.getActiveAssociation(userId);
    if (!activeAssociation || activeAssociation.role.nombre !== 'familyadmin') {
      return res.status(403).json({
        success: false,
        message: 'Solo los administradores familiares pueden acceder a esta informaci√≥n'
      });
    }
    
    // Obtener todas las asociaciones del usuario
    const userAssociations = await Shared.find({
      user: userId,
      status: 'active'
    }).populate('account division student');
    
    console.log('üîç [PICKUP FAMILYADMIN GET] Asociaciones encontradas:', userAssociations.length);
    console.log('üë• [PICKUP FAMILYADMIN GET] Asociaciones:', userAssociations.map(assoc => ({
      account: assoc.account?.nombre,
      division: assoc.division?.nombre,
      student: assoc.student ? `${assoc.student.nombre} ${assoc.student.apellido}` : 'Sin estudiante'
    })));
    
    if (userAssociations.length === 0) {
      console.log('‚ùå [PICKUP FAMILYADMIN GET] No hay asociaciones activas');
      return res.json({
        success: true,
        data: {
          pickups: [],
          total: 0,
          page: parseInt(page),
          limit: parseInt(limit)
        }
      });
    }
    
    // Construir query para buscar pickups de los estudiantes asociados al usuario
    const studentIds = userAssociations
      .filter(assoc => assoc.student)
      .map(assoc => assoc.student._id);
    
    console.log('üéì [PICKUP FAMILYADMIN GET] Student IDs:', studentIds);
    
    let query = {
      status: 'active'
    };
    
    // Filtrar por divisi√≥n si se especifica
    if (division && division !== 'all') {
      query.division = division;
      console.log('üîç [PICKUP FAMILYADMIN GET] Filtrando por divisi√≥n:', division);
    }
    
    // Filtrar por estudiante si se especifica
    if (student && student !== 'all') {
      query.student = student;
      console.log('üîç [PICKUP FAMILYADMIN GET] Filtrando por estudiante:', student);
    } else if (studentIds.length > 0) {
      // Solo buscar por student si no se especifica un estudiante espec√≠fico
      query.student = { $in: studentIds };
      console.log('üîç [PICKUP FAMILYADMIN GET] Filtrando por studentIds:', studentIds);
    }
    
    const skip = (parseInt(page) - 1) * parseInt(limit);
    
    console.log('üîç [PICKUP FAMILYADMIN GET] Query final:', JSON.stringify(query, null, 2));
    
    const pickups = await Pickup.find(query)
      .populate('account', 'nombre')
      .populate('student', 'nombre apellido')
      .populate('createdBy', 'name')
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(parseInt(limit));
    
    const total = await Pickup.countDocuments(query);
    
    console.log('üì¶ [PICKUP FAMILYADMIN GET] Pickups encontrados:', pickups.length);
    console.log('üìä [PICKUP FAMILYADMIN GET] Total en BD:', total);
    
    res.json({
      success: true,
      data: {
        pickups,
        total,
        page: parseInt(page),
        limit: parseInt(limit)
      }
    });
  } catch (error) {
    console.error('Error al obtener pickups para familyadmin:', error);
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// Crear pickup para familyadmin
app.post('/pickups/familyadmin', authenticateToken, async (req, res) => {
  try {
    console.log('üéØ [PICKUP FAMILYADMIN] Iniciando creaci√≥n de pickup');
    const { userId } = req.user;
    const { nombre, apellido, dni, divisionId } = req.body;
    
    console.log('üë§ [PICKUP FAMILYADMIN] Usuario:', userId);
    console.log('üìù [PICKUP FAMILYADMIN] Datos recibidos:', {
      nombre, apellido, dni, divisionId
    });
    
    // Verificar que el usuario es familyadmin
    const user = await User.findById(userId).populate('role');
    if (user.role?.nombre !== 'familyadmin') {
      return res.status(403).json({
        success: false,
        message: 'Solo los administradores familiares pueden crear personas autorizadas'
      });
    }
    
    // Buscar la asociaci√≥n del usuario para obtener la instituci√≥n y estudiante
    const userAssociation = await Shared.findOne({
      user: userId,
      status: 'active'
    }).populate('account student');
    
    if (!userAssociation) {
      return res.status(403).json({
        success: false,
        message: 'No tienes asociaciones activas'
      });
    }
    
    // Verificar que el usuario tiene un estudiante asociado
    if (!userAssociation.student) {
      return res.status(404).json({
        success: false,
        message: 'No tienes estudiantes asociados'
      });
    }
    
    // Validar que no exista una persona con el mismo DNI para el mismo estudiante
    const existingPickup = await Pickup.findOne({ 
      student: userAssociation.student._id, 
      dni, 
      status: 'active' 
    });
    
    if (existingPickup) {
      return res.status(400).json({
        success: false,
        message: 'Ya existe una persona autorizada con este DNI para este estudiante'
      });
    }
    
    const pickup = new Pickup({
      account: userAssociation.account._id,
      division: divisionId,
      student: userAssociation.student._id,
      nombre,
      apellido,
      dni,
      createdBy: userId
    });
    
    await pickup.save();
    
    const populatedPickup = await Pickup.findById(pickup._id)
      .populate('account', 'nombre')
      .populate('student', 'nombre apellido')
      .populate('createdBy', 'name');
    
    res.status(201).json({
      success: true,
      data: {
        pickup: populatedPickup
      },
      message: 'Persona autorizada creada correctamente'
    });
  } catch (error) {
    console.error('Error al crear pickup para familyadmin:', error);
    
    // Manejar errores de validaci√≥n de Mongoose
    if (error.name === 'ValidationError') {
      const validationErrors = Object.values(error.errors).map(err => err.message);
      return res.status(400).json({ 
        success: false, 
        message: 'Error de validaci√≥n',
        errors: validationErrors
      });
    }
    
    // Manejar otros errores
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// Eliminar pickup
app.delete('/pickup/:id', authenticateToken, async (req, res) => {
  try {
    console.log('üóëÔ∏è [PICKUP DELETE] Eliminando pickup:', req.params.id);
    const { userId } = req.user;
    const { id } = req.params;
    
    // Verificar que el usuario es familyadmin
    const user = await User.findById(userId).populate('role');
    if (user.role?.nombre !== 'familyadmin') {
      return res.status(403).json({
        success: false,
        message: 'Solo los administradores familiares pueden eliminar personas autorizadas'
      });
    }
    
    // Buscar el pickup
    const pickup = await Pickup.findById(id);
    if (!pickup) {
      return res.status(404).json({
        success: false,
        message: 'Persona autorizada no encontrada'
      });
    }
    
    // Verificar que el usuario tiene permisos para eliminar este pickup
    const userAssociation = await Shared.findOne({
      user: userId,
      student: pickup.student,
      status: 'active'
    });
    
    if (!userAssociation) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para eliminar esta persona autorizada'
      });
    }
    
    // Eliminar el pickup (soft delete)
    pickup.status = 'inactive';
    await pickup.save();
    
    console.log('‚úÖ [PICKUP DELETE] Pickup eliminado correctamente');
    
    res.json({
      success: true,
      message: 'Persona autorizada eliminada correctamente'
    });
  } catch (error) {
    console.error('Error al eliminar pickup:', error);
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// Obtener asociaciones del usuario
app.get('/shared/user', authenticateToken, async (req, res) => {
  try {
    console.log('üéØ [SHARED GET] Obteniendo asociaciones del usuario');
    const { userId } = req.user;
    
    console.log('üë§ [SHARED GET] Usuario:', userId);
    
    // Obtener todas las asociaciones del usuario
    const userAssociations = await Shared.find({
      user: userId,
      status: 'active'
    }).populate('account', 'nombre')
      .populate('division', 'nombre')
      .populate('student', 'nombre apellido avatar')
      .populate('role', 'nombre')
      .populate('createdBy', 'name')
      .sort({ createdAt: -1 });

    // Generar URLs firmadas para los avatares de estudiantes
    console.log('üîç [SHARED GET] ===== PROCESANDO AVATARES DE ESTUDIANTES =====');
    console.log('üîç [SHARED GET] Total de asociaciones:', userAssociations.length);
    
    const associationsWithSignedUrls = await Promise.all(userAssociations.map(async (association, index) => {
      console.log(`üîç [SHARED GET] Procesando asociaci√≥n ${index + 1}/${userAssociations.length}:`, {
        id: association._id,
        studentId: association.student?._id,
        studentName: association.student?.nombre,
        studentAvatar: association.student?.avatar,
        hasAvatar: !!association.student?.avatar
      });
      
      if (association.student && association.student.avatar) {
        try {
          console.log('üîç [SHARED GET] Procesando avatar del estudiante:', association.student._id);
          console.log('üîç [SHARED GET] Avatar original:', association.student.avatar);
          
          // Verificar si es una key de S3 o una URL local
          if (association.student.avatar.startsWith('http')) {
            console.log('üîç [SHARED GET] Es una URL completa, usando tal como est√°');
            // Es una URL completa (puede ser local o S3), no hacer nada
          } else if (association.student.avatar.includes('students/')) {
            // Es una key de S3 para estudiantes, generar URL firmada
            console.log('üîç [SHARED GET] Es una key de S3 para estudiantes, generando URL firmada');
            console.log('üîç [SHARED GET] Key original:', association.student.avatar);
            
            try {
              const { generateSignedUrl } = require('./config/s3.config');
              console.log('üîç [SHARED GET] Funci√≥n generateSignedUrl importada correctamente');
              
              const signedUrl = await generateSignedUrl(association.student.avatar, 172800); // 2 d√≠as
              console.log('üîç [SHARED GET] URL firmada generada exitosamente:', signedUrl);
              console.log('üîç [SHARED GET] Tipo de URL firmada:', typeof signedUrl);
              console.log('üîç [SHARED GET] Longitud de URL firmada:', signedUrl ? signedUrl.length : 'null');
              
              association.student.avatar = signedUrl;
              console.log('üîç [SHARED GET] Avatar actualizado en la asociaci√≥n');
            } catch (s3Error) {
              console.error('‚ùå [SHARED GET] Error generando URL firmada:', s3Error);
              console.error('‚ùå [SHARED GET] Error details:', {
                message: s3Error.message,
                stack: s3Error.stack,
                name: s3Error.name
              });
              // Mantener la key original si falla
              console.log('üîç [SHARED GET] Manteniendo key original:', association.student.avatar);
            }
          } else {
            // Es una key local, generar URL local
            const localUrl = `${req.protocol}://${req.get('host')}/uploads/${association.student.avatar.split('/').pop()}`;
            console.log('üîç [SHARED GET] URL local generada:', localUrl);
            association.student.avatar = localUrl;
          }
        } catch (error) {
          console.error('‚ùå [SHARED GET] Error procesando avatar del estudiante:', association.student._id, error);
          // Si falla, usar URL directa
          const fallbackUrl = `${req.protocol}://${req.get('host')}/uploads/${association.student.avatar.split('/').pop()}`;
          console.log('üîç [SHARED GET] Usando URL de fallback:', fallbackUrl);
          association.student.avatar = fallbackUrl;
        }
      } else {
        console.log('üîç [SHARED GET] Estudiante sin avatar:', association.student?._id);
      }
      return association;
    }));
    
    console.log('üì¶ [SHARED GET] ===== RESULTADO FINAL =====');
    console.log('üì¶ [SHARED GET] Asociaciones encontradas:', associationsWithSignedUrls.length);
    
    // Log de las asociaciones procesadas
    associationsWithSignedUrls.forEach((assoc, index) => {
      console.log(`üì¶ [SHARED GET] Asociaci√≥n ${index + 1} final:`, {
        id: assoc._id,
        studentId: assoc.student?._id,
        studentName: assoc.student?.nombre,
        studentAvatar: assoc.student?.avatar,
        hasAvatar: !!assoc.student?.avatar
      });
    });
    
    console.log('üì§ [SHARED GET] ===== ENVIANDO RESPUESTA AL CLIENTE =====');
    console.log('üì§ [SHARED GET] Total de asociaciones a enviar:', associationsWithSignedUrls.length);
    
    associationsWithSignedUrls.forEach((assoc, index) => {
      console.log(`üì§ [SHARED GET] Asociaci√≥n ${index + 1} en respuesta:`, {
        id: assoc._id,
        studentId: assoc.student?._id,
        studentName: assoc.student?.nombre,
        studentAvatar: assoc.student?.avatar,
        hasAvatar: !!assoc.student?.avatar,
        avatarType: assoc.student?.avatar ? (assoc.student.avatar.startsWith('http') ? 'URL completa' : 'Key de S3') : 'Sin avatar'
      });
    });
    
    res.json({
      success: true,
      data: {
        associations: associationsWithSignedUrls
      }
    });
  } catch (error) {
    console.error('Error al obtener asociaciones del usuario:', error);
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// Endpoint para obtener asociaciones del usuario (con prefijo /api)
app.get('/api/shared/user', authenticateToken, async (req, res) => {
  try {
    console.log('üéØ [API SHARED GET] Obteniendo asociaciones del usuario');
    const { userId } = req.user;
    
    console.log('üë§ [API SHARED GET] Usuario:', userId);
    
    // Obtener las asociaciones del usuario
    const userAssociations = await Shared.find({ user: userId })
      .populate('account')
      .populate('division')
      .populate({
        path: 'student',
        select: 'nombre apellido avatar'
      });
    
    console.log('üîç [API SHARED GET] ===== PROCESANDO AVATARES DE ESTUDIANTES =====');
    console.log('üîç [API SHARED GET] Total de asociaciones:', userAssociations.length);
    
    const associationsWithSignedUrls = await Promise.all(userAssociations.map(async (association, index) => {
      console.log(`üîç [API SHARED GET] Procesando asociaci√≥n ${index + 1}/${userAssociations.length}:`, {
        id: association._id,
        studentId: association.student?._id,
        studentName: association.student?.nombre,
        studentAvatar: association.student?.avatar,
        hasAvatar: !!association.student?.avatar
      });
      
      if (association.student && association.student.avatar) {
        try {
          console.log('üîç [API SHARED GET] Procesando avatar del estudiante:', association.student._id);
          console.log('üîç [API SHARED GET] Avatar original:', association.student.avatar);
          
          // Verificar si es una key de S3 o una URL local
          if (association.student.avatar.startsWith('http')) {
            console.log('üîç [API SHARED GET] Es una URL completa, usando tal como est√°');
            // Es una URL completa (puede ser local o S3), no hacer nada
          } else if (association.student.avatar.includes('students/')) {
            // Es una key de S3 para estudiantes, generar URL firmada
            console.log('üîç [API SHARED GET] Es una key de S3 para estudiantes, generando URL firmada');
            console.log('üîç [API SHARED GET] Key original:', association.student.avatar);
            
            try {
              const { generateSignedUrl } = require('./config/s3.config');
              console.log('üîç [API SHARED GET] Funci√≥n generateSignedUrl importada correctamente');
              
              const signedUrl = await generateSignedUrl(association.student.avatar, 172800); // 2 d√≠as
              console.log('üîç [API SHARED GET] URL firmada generada exitosamente:', signedUrl);
              console.log('üîç [API SHARED GET] Tipo de URL firmada:', typeof signedUrl);
              console.log('üîç [API SHARED GET] Longitud de URL firmada:', signedUrl ? signedUrl.length : 'null');
              
              association.student.avatar = signedUrl;
              console.log('üîç [API SHARED GET] Avatar actualizado en la asociaci√≥n');
            } catch (s3Error) {
              console.error('‚ùå [API SHARED GET] Error generando URL firmada:', s3Error);
              console.error('‚ùå [API SHARED GET] Error details:', {
                message: s3Error.message,
                stack: s3Error.stack,
                name: s3Error.name
              });
              // Mantener la key original si falla
              console.log('üîç [API SHARED GET] Manteniendo key original:', association.student.avatar);
            }
          } else {
            // Es una key local, generar URL local
            const localUrl = `${req.protocol}://${req.get('host')}/uploads/${association.student.avatar.split('/').pop()}`;
            console.log('üîç [API SHARED GET] URL local generada:', localUrl);
            association.student.avatar = localUrl;
          }
        } catch (error) {
          console.error('‚ùå [API SHARED GET] Error procesando avatar del estudiante:', association.student._id, error);
          // Si falla, usar URL directa
          const fallbackUrl = `${req.protocol}://${req.get('host')}/uploads/${association.student.avatar.split('/').pop()}`;
          console.log('üîç [API SHARED GET] Usando URL de fallback:', fallbackUrl);
          association.student.avatar = fallbackUrl;
        }
      } else {
        console.log('üîç [API SHARED GET] Estudiante sin avatar:', association.student?._id);
      }
      return association;
    }));
    
    console.log('üì¶ [API SHARED GET] ===== RESULTADO FINAL =====');
    console.log('üì¶ [API SHARED GET] Asociaciones encontradas:', associationsWithSignedUrls.length);
    
    associationsWithSignedUrls.forEach((assoc, index) => {
      console.log(`üì¶ [API SHARED GET] Asociaci√≥n ${index + 1} final:`, {
        id: assoc._id,
        studentId: assoc.student?._id,
        studentName: assoc.student?.nombre,
        studentAvatar: assoc.student?.avatar,
        hasAvatar: !!assoc.student?.avatar
      });
    });
    
    res.json({
      success: true,
      data: {
        associations: associationsWithSignedUrls
      }
    });
  } catch (error) {
    console.error('Error al obtener asociaciones del usuario:', error);
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// Endpoint para obtener asociaciones de un estudiante espec√≠fico
app.get('/shared/student/:studentId', authenticateToken, async (req, res) => {
  try {
    const { studentId } = req.params;
    const { userId } = req.user;

    console.log('üîç [SHARED STUDENT] Buscando asociaciones para estudiante:', studentId);
    console.log('üë§ [SHARED STUDENT] Usuario solicitante:', userId);

    // Verificar que el usuario tiene permisos para ver este estudiante
    // (solo superadmin, adminaccount, coordinador pueden ver)
    const user = await User.findById(userId).populate('role');
    const userRole = user?.role?.nombre;

    console.log('üé≠ [SHARED STUDENT] Rol del usuario:', userRole);

    if (!['superadmin', 'adminaccount', 'coordinador'].includes(userRole)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para ver las vinculaciones de estudiantes'
      });
    }

    // Buscar todas las asociaciones donde este estudiante est√© vinculado
    const associations = await Shared.find({
      student: studentId,
      status: { $in: ['active', 'inactive'] } // Mostrar tanto activas como inactivas
    }).populate('user account division role createdBy');

    console.log('üìä [SHARED STUDENT] Asociaciones encontradas:', associations.length);

    res.json({
      success: true,
      data: {
        associations
      }
    });
  } catch (error) {
    console.error('Error obteniendo asociaciones del estudiante:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Crear nueva asociaci√≥n (solo familyadmin)
app.post('/shared', authenticateToken, async (req, res) => {
  try {
    console.log('üéØ [SHARED POST] Creando nueva asociaci√≥n');
    const { userId } = req.user;
    const { accountId, divisionId, studentId, roleName } = req.body;
    
    console.log('üë§ [SHARED POST] Usuario:', userId);
    console.log('üìù [SHARED POST] Datos recibidos:', {
      accountId, divisionId, studentId, roleName
    });
    
    // Verificar que el usuario es familyadmin
    const user = await User.findById(userId).populate('role');
    if (user.role?.nombre !== 'familyadmin') {
      return res.status(403).json({
        success: false,
        message: 'Solo los administradores familiares pueden crear asociaciones'
      });
    }
    
    // Verificar que la cuenta existe
    const account = await Account.findById(accountId);
    if (!account) {
      return res.status(404).json({
        success: false,
        message: 'Instituci√≥n no encontrada'
      });
    }
    
    // Verificar que el rol existe
    const role = await Role.findOne({ nombre: roleName });
    if (!role) {
      return res.status(404).json({
        success: false,
        message: 'Rol no encontrado'
      });
    }
    
    // Verificar que la divisi√≥n existe si se proporciona
    if (divisionId) {
      const division = await Grupo.findById(divisionId);
      if (!division) {
        return res.status(404).json({
          success: false,
          message: 'Divisi√≥n no encontrada'
        });
      }
    }
    
    // Verificar que el estudiante existe si se proporciona
    if (studentId) {
      const student = await Student.findById(studentId);
      if (!student) {
        return res.status(404).json({
          success: false,
          message: 'Estudiante no encontrado'
        });
      }
    }
    
    // Crear la asociaci√≥n
    const association = new Shared({
      user: userId,
      account: accountId,
      division: divisionId,
      student: studentId,
      role: role._id,
      status: 'active',
      createdBy: userId
    });
    
    await association.save();
    
    // Verificar si el usuario ya tiene una asociaci√≥n activa
    const existingActiveAssociation = await ActiveAssociation.getActiveAssociation(userId);
    
    if (!existingActiveAssociation) {
      // Si no tiene asociaci√≥n activa, establecer esta como activa autom√°ticamente
      try {
        await ActiveAssociation.setActiveAssociation(userId, association._id);
        console.log(`üéØ [AUTO-ACTIVE] Asociaci√≥n autom√°ticamente establecida como activa para usuario ${userId}`);
      } catch (error) {
        console.error('‚ùå [AUTO-ACTIVE] Error estableciendo asociaci√≥n activa autom√°ticamente:', error);
      }
    } else {
      console.log(`‚ÑπÔ∏è [AUTO-ACTIVE] Usuario ${userId} ya tiene una asociaci√≥n activa, no se cambia autom√°ticamente`);
    }
    
    // Enviar email de notificaci√≥n de asociaci√≥n
    try {
      const user = await User.findById(userId);
      const account = await Account.findById(accountId);
      const role = await Role.findById(role._id);
      
      if (user && account) {
        await sendNotificationEmail(
          user.email,
          'Asociaci√≥n a Instituci√≥n',
          `Has sido asociado a la instituci√≥n <strong>${account.nombre}</strong> con el rol <strong>${role.nombre}</strong>. Ya puedes acceder a la aplicaci√≥n con tus credenciales.`
        );
        console.log('‚úÖ [SHARED POST] Email de notificaci√≥n enviado exitosamente a:', user.email);
      }
    } catch (emailError) {
      console.error('‚ùå [SHARED POST] Error enviando email de notificaci√≥n:', emailError);
      // No fallar la operaci√≥n si el email falla, solo loguear el error
    }
    
    // Populate para la respuesta
    const populatedAssociation = await Shared.findById(association._id)
      .populate('account', 'nombre')
      .populate('division', 'nombre')
      .populate('student', 'nombre apellido')
      .populate('role', 'nombre')
      .populate('createdBy', 'name');
    
    console.log('‚úÖ [SHARED POST] Asociaci√≥n creada correctamente');
    
    res.status(201).json({
      success: true,
      data: {
        association: populatedAssociation
      },
      message: 'Asociaci√≥n creada correctamente'
    });
  } catch (error) {
    console.error('Error al crear asociaci√≥n:', error);
    
    // Manejar errores de validaci√≥n de Mongoose
    if (error.name === 'ValidationError') {
      const validationErrors = Object.values(error.errors).map(err => err.message);
      return res.status(400).json({ 
        success: false, 
        message: 'Error de validaci√≥n',
        errors: validationErrors
      });
    }
    
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// Eliminar asociaci√≥n (solo familyadmin)
app.delete('/shared/:id', authenticateToken, async (req, res) => {
  try {
    console.log('üóëÔ∏è [SHARED DELETE] Eliminando asociaci√≥n:', req.params.id);
    const { userId } = req.user;
    const { id } = req.params;
    
    // Verificar que el usuario es familyadmin
    const user = await User.findById(userId).populate('role');
    if (user.role?.nombre !== 'familyadmin') {
      return res.status(403).json({
        success: false,
        message: 'Solo los administradores familiares pueden eliminar asociaciones'
      });
    }
    
    // Buscar la asociaci√≥n
    const association = await Shared.findById(id);
    if (!association) {
      return res.status(404).json({
        success: false,
        message: 'Asociaci√≥n no encontrada'
      });
    }
    
    // Verificar que el usuario es el propietario de la asociaci√≥n
    if (association.user.toString() !== userId) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para eliminar esta asociaci√≥n'
      });
    }
    
    // Eliminar la asociaci√≥n (soft delete)
    association.status = 'inactive';
    await association.save();
    
    console.log('‚úÖ [SHARED DELETE] Asociaci√≥n eliminada correctamente');
    
    res.json({
      success: true,
      message: 'Asociaci√≥n eliminada correctamente'
    });
  } catch (error) {
    console.error('Error al eliminar asociaci√≥n:', error);
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// Solicitar asociaci√≥n por email
app.post('/shared/request', authenticateToken, async (req, res) => {
  try {
    console.log('üéØ [SHARED REQUEST] Agregando familiar al estudiante');
    const { userId } = req.user;
    const { email, nombre, apellido, studentId } = req.body;
    
    console.log('üë§ [SHARED REQUEST] Usuario solicitante:', userId);
    console.log('üìß [SHARED REQUEST] Email:', email);
    console.log('üë§ [SHARED REQUEST] Nombre:', nombre);
    console.log('üë§ [SHARED REQUEST] Apellido:', apellido);
    console.log('üéì [SHARED REQUEST] Student ID:', studentId);
    console.log('üîç [SHARED REQUEST] Body completo:', JSON.stringify(req.body, null, 2));
    
    // Verificar que el usuario tiene una asociaci√≥n activa como familyadmin
    const activeAssociation = await ActiveAssociation.getActiveAssociation(userId);
    if (!activeAssociation) {
      return res.status(403).json({
        success: false,
        message: 'No tienes una asociaci√≥n activa'
      });
    }
    
    const activeShared = await Shared.findById(activeAssociation.activeShared).populate('role');
    if (activeShared.role?.nombre !== 'familyadmin') {
      return res.status(403).json({
        success: false,
        message: 'Solo los administradores familiares pueden agregar familiares'
      });
    }
    
    // Usar la asociaci√≥n activa ya obtenida
    const userAssociation = await Shared.findById(activeAssociation.activeShared)
      .populate('account division student role');
    
    // Verificar que el estudiante pertenece al familyadmin
    if (userAssociation.student?._id.toString() !== studentId) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para agregar familiares a este estudiante'
      });
    }
    
    // Verificar si el email ya existe en users
    const existingUser = await User.findOne({ email: email.toLowerCase() });
    
    if (existingUser) {
      console.log('‚úÖ [SHARED REQUEST] Usuario encontrado, creando asociaci√≥n directa');
      
      // Verificar si ya existe una asociaci√≥n para este usuario en la misma cuenta
      const existingShared = await Shared.findOne({
        user: existingUser._id,
        account: userAssociation.account._id,
        status: 'active'
      });
      
      if (existingShared) {
        return res.status(400).json({
          success: false,
          message: 'El usuario ya tiene una asociaci√≥n activa en esta instituci√≥n'
        });
      }
      
      // Obtener el rol familyviewer
      const familyviewerRole = await Role.findOne({ nombre: 'familyviewer' });
      if (!familyviewerRole) {
        return res.status(500).json({
          success: false,
          message: 'Rol familyviewer no encontrado'
        });
      }
      
      // Crear la asociaci√≥n directamente
      const newShared = new Shared({
        user: existingUser._id,
        account: userAssociation.account._id,
        division: userAssociation.division?._id,
        student: studentId,
        role: familyviewerRole._id,
        status: 'active',
        createdBy: userId
      });
      
      await newShared.save();
      
      // Verificar si el usuario ya tiene una asociaci√≥n activa
      const existingActiveAssociation = await ActiveAssociation.getActiveAssociation(existingUser._id);
      
      if (!existingActiveAssociation) {
        // Si no tiene asociaci√≥n activa, establecer esta como activa autom√°ticamente
        try {
          await ActiveAssociation.setActiveAssociation(existingUser._id, newShared._id);
          console.log(`üéØ [AUTO-ACTIVE] Asociaci√≥n autom√°ticamente establecida como activa para usuario ${existingUser._id}`);
        } catch (error) {
          console.error('‚ùå [AUTO-ACTIVE] Error estableciendo asociaci√≥n activa autom√°ticamente:', error);
        }
      } else {
        console.log(`‚ÑπÔ∏è [AUTO-ACTIVE] Usuario ${existingUser._id} ya tiene una asociaci√≥n activa, no se cambia autom√°ticamente`);
      }
      
      console.log('‚úÖ [SHARED REQUEST] Asociaci√≥n creada exitosamente');
      
      res.status(201).json({
        success: true,
        message: 'Asociaci√≥n creada exitosamente',
        data: {
          user: {
            _id: existingUser._id,
            name: existingUser.name,
            email: existingUser.email
          },
          association: newShared
        }
      });
      
    } else {
      console.log('‚è≥ [SHARED REQUEST] Usuario no encontrado');
      
      // Si el rol activo es familyadmin, crear el usuario autom√°ticamente
      if (activeShared.role.nombre === 'familyadmin') {
        console.log('üîß [SHARED REQUEST] Rol activo es familyadmin, creando usuario autom√°ticamente');
        
        try {
          // Generar contrase√±a aleatoria de 8 caracteres
          const generateRandomPassword = () => {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let password = '';
            for (let i = 0; i < 8; i++) {
              password += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return password;
          };
          
          const randomPassword = generateRandomPassword();
          console.log('üîë [SHARED REQUEST] Contrase√±a generada:', randomPassword);
          
          // Obtener el rol familyviewer
          const familyviewerRole = await Role.findOne({ nombre: 'familyviewer' });
          if (!familyviewerRole) {
            return res.status(500).json({
              success: false,
              message: 'Rol familyviewer no encontrado'
            });
          }
          
          // Crear el nuevo usuario
          const newUser = new User({
            name: `${nombre} ${apellido}`,
            email: email.toLowerCase(),
            password: randomPassword,
            role: familyviewerRole._id,
            status: 'approved', // Aprobar autom√°ticamente usuarios familyviewer
            isFirstLogin: true // Marcar como primer login
          });
          
          await newUser.save();
          console.log('‚úÖ [SHARED REQUEST] Usuario creado exitosamente:', newUser._id);
          
          // Crear la asociaci√≥n inmediatamente
          const newShared = new Shared({
            user: newUser._id,
            account: userAssociation.account._id,
            division: userAssociation.division?._id,
            student: studentId,
            role: familyviewerRole._id,
            status: 'active',
            createdBy: userId
          });
          
          await newShared.save();
          
          // Verificar si el usuario ya tiene una asociaci√≥n activa
          const existingActiveAssociation = await ActiveAssociation.getActiveAssociation(newUser._id);
          
          if (!existingActiveAssociation) {
            // Si no tiene asociaci√≥n activa, establecer esta como activa autom√°ticamente
            try {
              await ActiveAssociation.setActiveAssociation(newUser._id, newShared._id);
              console.log(`üéØ [AUTO-ACTIVE] Asociaci√≥n autom√°ticamente establecida como activa para usuario ${newUser._id}`);
            } catch (error) {
              console.error('‚ùå [AUTO-ACTIVE] Error estableciendo asociaci√≥n activa autom√°ticamente:', error);
            }
          } else {
            console.log(`‚ÑπÔ∏è [AUTO-ACTIVE] Usuario ${newUser._id} ya tiene una asociaci√≥n activa, no se cambia autom√°ticamente`);
          }
          
          console.log('‚úÖ [SHARED REQUEST] Asociaci√≥n creada exitosamente');
          
          // Enviar email de invitaci√≥n con las credenciales (as√≠ncrono)
          sendEmailAsync(sendFamilyInvitationEmail, null, newUser.email, newUser.name, randomPassword);
          console.log('üìß [SHARED REQUEST] Email de invitaci√≥n familiar programado para env√≠o as√≠ncrono a:', email);
          
          res.status(201).json({
            success: true,
            message: 'Familiar agregado exitosamente. Se envi√≥ un email con las credenciales de acceso.',
            data: {
              user: {
                _id: newUser._id,
                name: newUser.name,
                email: newUser.email
              },
              association: newShared,
              password: randomPassword // Temporalmente incluir la contrase√±a en la respuesta para testing
            }
          });
          
        } catch (userCreationError) {
          console.error('‚ùå [SHARED REQUEST] Error creando usuario:', userCreationError);
          
          // Si falla la creaci√≥n del usuario, guardar como solicitud pendiente
          const requestedShared = new RequestedShared({
            requestedBy: userId,
            requestedEmail: email.toLowerCase(),
            account: userAssociation.account._id,
            division: userAssociation.division?._id,
            student: userAssociation.student?._id,
            role: userAssociation.role._id,
            status: 'pending'
          });
          
          await requestedShared.save();
          
          res.status(201).json({
            success: true,
            message: 'Error al crear usuario autom√°ticamente. Se guard√≥ como solicitud pendiente.',
            data: {
              request: requestedShared
            }
          });
        }
        
      } else {
        console.log('‚è≥ [SHARED REQUEST] Rol activo no es familyadmin, guardando solicitud pendiente');
        
        // Verificar si ya existe una solicitud pendiente para este email
        const existingRequest = await RequestedShared.findOne({
          requestedEmail: email.toLowerCase(),
          status: 'pending'
        });
        
        if (existingRequest) {
          return res.status(400).json({
            success: false,
            message: 'Ya existe una solicitud pendiente para este email'
          });
        }
        
        // Crear solicitud pendiente
        const requestedShared = new RequestedShared({
          requestedBy: userId,
          requestedEmail: email.toLowerCase(),
          account: userAssociation.account._id,
          division: userAssociation.division?._id,
          student: userAssociation.student?._id,
          role: userAssociation.role._id,
          status: 'pending'
        });
        
        await requestedShared.save();
        
        console.log('‚úÖ [SHARED REQUEST] Solicitud pendiente guardada exitosamente');
        
        res.status(201).json({
          success: true,
          message: 'Solicitud enviada. La asociaci√≥n se crear√° cuando el usuario se registre',
          data: {
            request: requestedShared
          }
        });
      }
    }
    
  } catch (error) {
    console.error('Error al solicitar asociaci√≥n:', error);
    
    // Manejar errores de validaci√≥n de Mongoose
    if (error.name === 'ValidationError') {
      const validationErrors = Object.values(error.errors).map(err => err.message);
      return res.status(400).json({ 
        success: false, 
        message: 'Error de validaci√≥n',
        errors: validationErrors
      });
    }
    
    res.status(500).json({ success: false, message: 'Error interno del servidor' });
  }
});

// ========================================
// ENDPOINTS DE ASOCIACI√ìN ACTIVA
// ========================================

// Obtener la asociaci√≥n activa del usuario
app.get('/active-association', authenticateToken, async (req, res) => {
  try {
    console.log('üéØ [ACTIVE ASSOCIATION GET] Obteniendo asociaci√≥n activa del usuario');
    const { userId } = req.user;

    const activeAssociation = await ActiveAssociation.getActiveAssociation(userId);

    if (!activeAssociation) {
      return res.json({
        success: true,
        data: null,
        message: 'No hay asociaci√≥n activa'
      });
    }

    // Debug: Log del avatar del estudiante en asociaci√≥n activa
    if (activeAssociation.student) {
      console.log('üéì [ACTIVE ASSOCIATION GET] Estudiante activo:', {
        id: activeAssociation.student._id,
        nombre: activeAssociation.student.nombre,
        apellido: activeAssociation.student.apellido,
        avatar: activeAssociation.student.avatar,
        hasAvatar: !!activeAssociation.student.avatar
      });
    }

    // Procesar avatar del estudiante para generar URL firmada
    let studentWithSignedUrl = null;
    if (activeAssociation.student) {
      studentWithSignedUrl = {
        _id: activeAssociation.student._id,
        nombre: activeAssociation.student.nombre,
        apellido: activeAssociation.student.apellido,
        avatar: activeAssociation.student.avatar
      };
      
      // Procesar avatar del estudiante para generar URL firmada
      if (activeAssociation.student.avatar) {
        try {
          console.log('üéì [ACTIVE ASSOCIATION GET] Procesando avatar del estudiante:', activeAssociation.student._id);
          console.log('üéì [ACTIVE ASSOCIATION GET] Avatar original:', activeAssociation.student.avatar);
          
          // Verificar si es una key de S3 o una URL local
          if (activeAssociation.student.avatar.startsWith('http')) {
            console.log('üéì [ACTIVE ASSOCIATION GET] Es una URL completa, usando tal como est√°');
            // Es una URL completa (puede ser local o S3), no hacer nada
          } else if (activeAssociation.student.avatar.includes('students/')) {
            // Es una key de S3 para estudiantes, generar URL firmada
            console.log('üéì [ACTIVE ASSOCIATION GET] Es una key de S3 para estudiantes, generando URL firmada');
            const { generateSignedUrl } = require('./config/s3.config');
            const signedUrl = await generateSignedUrl(activeAssociation.student.avatar, 172800); // 2 d√≠as
            console.log('üéì [ACTIVE ASSOCIATION GET] URL firmada generada:', signedUrl);
            studentWithSignedUrl.avatar = signedUrl;
          } else {
            // Es una key local, generar URL local
            const localUrl = `${req.protocol}://${req.get('host')}/uploads/${activeAssociation.student.avatar.split('/').pop()}`;
            console.log('üéì [ACTIVE ASSOCIATION GET] URL local generada:', localUrl);
            studentWithSignedUrl.avatar = localUrl;
          }
        } catch (error) {
          console.error('üéì [ACTIVE ASSOCIATION GET] Error procesando avatar del estudiante:', activeAssociation.student._id, error);
          // En caso de error, mantener el avatar original
        }
      }
    }

    res.json({
      success: true,
      data: {
        _id: activeAssociation._id,
        activeShared: activeAssociation.activeShared,
        account: activeAssociation.account,
        role: activeAssociation.role,
        division: activeAssociation.division,
        student: studentWithSignedUrl,
        activatedAt: activeAssociation.activatedAt
      }
    });

  } catch (error) {
    console.error('‚ùå [ACTIVE ASSOCIATION GET] Error:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Error al obtener asociaci√≥n activa' 
    });
  }
});

// Obtener todas las asociaciones disponibles del usuario
app.get('/active-association/available', authenticateToken, async (req, res) => {
  try {
    console.log('üéØ [ACTIVE ASSOCIATION AVAILABLE] Obteniendo asociaciones disponibles');
    const { userId } = req.user;

    // Obtener la asociaci√≥n activa actual para comparar
    const currentActive = await ActiveAssociation.findOne({ user: userId });
    console.log('üéØ [ACTIVE ASSOCIATION AVAILABLE] Asociaci√≥n activa actual:', currentActive ? {
      id: currentActive._id,
      activeShared: currentActive.activeShared,
      account: currentActive.account?.nombre,
      role: currentActive.role?.nombre
    } : null);

    const associations = await ActiveAssociation.getUserAvailableAssociations(userId);
    console.log('üéØ [ACTIVE ASSOCIATION AVAILABLE] Asociaciones disponibles:', associations.length);

    // Procesar URLs de avatares para cada asociaci√≥n
    const formattedAssociations = await Promise.all(associations.map(async (assoc) => {
      const isActive = currentActive ? assoc._id.toString() === currentActive.activeShared.toString() : false;
      
      // Debug: Log del avatar del estudiante
      if (assoc.student) {
        console.log('üéì [ACTIVE ASSOCIATION AVAILABLE] Estudiante:', {
          id: assoc.student._id,
          nombre: assoc.student.nombre,
          apellido: assoc.student.apellido,
          avatar: assoc.student.avatar,
          hasAvatar: !!assoc.student.avatar
        });
      }
      
      let studentWithSignedUrl = null;
      if (assoc.student) {
        studentWithSignedUrl = {
          _id: assoc.student._id,
          nombre: assoc.student.nombre,
          apellido: assoc.student.apellido,
          avatar: assoc.student.avatar
        };
        
        // Procesar avatar del estudiante para generar URL firmada
        if (assoc.student.avatar) {
          try {
            console.log('üéì [ACTIVE ASSOCIATION AVAILABLE] Procesando avatar del estudiante:', assoc.student._id);
            console.log('üéì [ACTIVE ASSOCIATION AVAILABLE] Avatar original:', assoc.student.avatar);
            
            // Verificar si es una key de S3 o una URL local
            if (assoc.student.avatar.startsWith('http')) {
              console.log('üéì [ACTIVE ASSOCIATION AVAILABLE] Es una URL completa, usando tal como est√°');
              // Es una URL completa (puede ser local o S3), no hacer nada
            } else if (assoc.student.avatar.includes('students/')) {
              // Es una key de S3 para estudiantes, generar URL firmada
              console.log('üéì [ACTIVE ASSOCIATION AVAILABLE] Es una key de S3 para estudiantes, generando URL firmada');
              const { generateSignedUrl } = require('./config/s3.config');
              const signedUrl = await generateSignedUrl(assoc.student.avatar, 172800); // 2 d√≠as
              console.log('üéì [ACTIVE ASSOCIATION AVAILABLE] URL firmada generada:', signedUrl);
              studentWithSignedUrl.avatar = signedUrl;
            } else {
              // Es una key local, generar URL local
              const localUrl = `${req.protocol}://${req.get('host')}/uploads/${assoc.student.avatar.split('/').pop()}`;
              console.log('üéì [ACTIVE ASSOCIATION AVAILABLE] URL local generada:', localUrl);
              studentWithSignedUrl.avatar = localUrl;
            }
          } catch (error) {
            console.error('üéì [ACTIVE ASSOCIATION AVAILABLE] Error procesando avatar del estudiante:', assoc.student._id, error);
            // En caso de error, mantener el avatar original
          }
        }
      }
      
      return {
        _id: assoc._id,
        account: {
          _id: assoc.account._id,
          nombre: assoc.account.nombre,
          razonSocial: assoc.account.razonSocial
        },
        role: {
          _id: assoc.role._id,
          nombre: assoc.role.nombre,
          descripcion: assoc.role.descripcion
        },
        division: assoc.division ? {
          _id: assoc.division._id,
          nombre: assoc.division.nombre,
          descripcion: assoc.division.descripcion
        } : null,
        student: studentWithSignedUrl,
        createdAt: assoc.createdAt,
        isActive: isActive
      };
    }));

    res.json({
      success: true,
      data: formattedAssociations
    });

  } catch (error) {
    console.error('‚ùå [ACTIVE ASSOCIATION AVAILABLE] Error:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Error al obtener asociaciones disponibles' 
    });
  }
});

// Establecer una asociaci√≥n como activa
app.post('/active-association/set', authenticateToken, async (req, res) => {
  try {
    console.log('üéØ [ACTIVE ASSOCIATION SET] Estableciendo asociaci√≥n activa');
    const { userId } = req.user;
    const { sharedId } = req.body;

    if (!sharedId) {
      return res.status(400).json({
        success: false,
        message: 'ID de asociaci√≥n es requerido'
      });
    }

    const activeAssociation = await ActiveAssociation.setActiveAssociation(userId, sharedId);

    res.json({
      success: true,
      message: 'Asociaci√≥n activa establecida exitosamente',
      data: {
        _id: activeAssociation._id,
        activeShared: activeAssociation.activeShared,
        account: activeAssociation.account,
        role: activeAssociation.role,
        division: activeAssociation.division,
        student: activeAssociation.student,
        activatedAt: activeAssociation.activatedAt
      }
    });

  } catch (error) {
    console.error('‚ùå [ACTIVE ASSOCIATION SET] Error:', error);
    
    if (error.message.includes('no encontrada') || 
        error.message.includes('no est√° activa') || 
        error.message.includes('no pertenece')) {
      return res.status(400).json({
        success: false,
        message: error.message
      });
    }

    res.status(500).json({ 
      success: false, 
      message: 'Error al establecer asociaci√≥n activa' 
    });
  }
});

// Limpiar asociaciones activas inv√°lidas (endpoint administrativo)
app.post('/active-association/cleanup', authenticateToken, async (req, res) => {
  try {
    console.log('üéØ [ACTIVE ASSOCIATION CLEANUP] Limpiando asociaciones activas inv√°lidas');
    
    // Verificar que el usuario sea admin o superadmin
    const user = await User.findById(req.user.userId).populate('role');
    if (!user || !['admin', 'superadmin'].includes(user.role?.nombre)) {
      return res.status(403).json({
        success: false,
        message: 'No tienes permisos para realizar esta acci√≥n'
      });
    }

    await ActiveAssociation.cleanupInvalidAssociations();

    res.json({
      success: true,
      message: 'Limpieza de asociaciones activas completada'
    });

  } catch (error) {
    console.error('‚ùå [ACTIVE ASSOCIATION CLEANUP] Error:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Error al limpiar asociaciones activas' 
    });
  }
});

// ========================================
// ENDPOINTS DE RECUPERACI√ìN DE CONTRASE√ëA
// ========================================

// Generar c√≥digo de recuperaci√≥n y enviar email
app.post('/users/forgot-password', async (req, res) => {
  try {
    console.log('üéØ [FORGOT PASSWORD] Solicitando recuperaci√≥n de contrase√±a');
    const { email } = req.body;

    if (!email) {
      return res.status(400).json({
        success: false,
        message: 'El email es requerido'
      });
    }

    console.log('üìß [FORGOT PASSWORD] Email solicitado:', email);

    // Verificar si el usuario existe
    const user = await User.findOne({ email: email.toLowerCase() });
    console.log('üîç [FORGOT PASSWORD] Usuario encontrado:', user ? 'S√≠' : 'No');
    
    if (!user) {
      console.log('‚ùå [FORGOT PASSWORD] Usuario no encontrado para email:', email);
      return res.status(404).json({
        success: false,
        message: 'No se encontr√≥ un usuario con ese email'
      });
    }

    console.log('‚úÖ [FORGOT PASSWORD] Usuario encontrado:', {
      id: user._id,
      name: user.name,
      email: user.email,
      status: user.status
    });

    // Generar c√≥digo de 6 d√≠gitos
    const code = Math.floor(100000 + Math.random() * 900000).toString();
    console.log('üîë [FORGOT PASSWORD] C√≥digo generado:', code);
    
    // El c√≥digo expira en 10 minutos
    const expiresAt = new Date(Date.now() + 10 * 60 * 1000);
    
    // Eliminar c√≥digos anteriores para este email
    await PasswordReset.deleteMany({ email: email.toLowerCase() });
    console.log('üóëÔ∏è [FORGOT PASSWORD] C√≥digos anteriores eliminados');

    // Crear nuevo c√≥digo de recuperaci√≥n
    const passwordReset = new PasswordReset({
      email: email.toLowerCase(),
      code,
      expiresAt
    });

    await passwordReset.save();
    console.log('üíæ [FORGOT PASSWORD] Nuevo c√≥digo guardado en base de datos');

    // Enviar email con el c√≥digo usando el servicio existente
    try {
      await sendPasswordResetEmail(email, code, user.name);
      console.log('‚úÖ [FORGOT PASSWORD] Email enviado exitosamente a:', email);
      
      res.json({
        success: true,
        message: 'Se ha enviado un c√≥digo de recuperaci√≥n a tu email',
        data: {
          email: email.toLowerCase()
        }
      });
    } catch (emailError) {
      console.error('‚ùå [FORGOT PASSWORD] Error enviando email:', emailError);
      
      // Si falla el env√≠o de email, eliminar el c√≥digo y devolver error
      await PasswordReset.deleteOne({ email: email.toLowerCase() });
      console.log('üóëÔ∏è [FORGOT PASSWORD] C√≥digo eliminado por fallo en email');
      
      res.status(500).json({
        success: false,
        message: 'Error enviando el email. Por favor, intenta nuevamente.'
      });
    }

  } catch (error) {
    console.error('‚ùå [FORGOT PASSWORD] Error interno:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Verificar c√≥digo de recuperaci√≥n
app.post('/users/verify-reset-code', async (req, res) => {
  try {
    const { email, code } = req.body;

    if (!email || !code) {
      return res.status(400).json({
        success: false,
        message: 'Email y c√≥digo son requeridos'
      });
    }

    // Buscar el c√≥digo de recuperaci√≥n
    const passwordReset = await PasswordReset.findOne({
      email: email.toLowerCase(),
      code
    });

    if (!passwordReset) {
      return res.status(400).json({
        success: false,
        message: 'C√≥digo inv√°lido'
      });
    }

    // Verificar si el c√≥digo es v√°lido
    if (!passwordReset.isValid()) {
      return res.status(400).json({
        success: false,
        message: 'C√≥digo expirado o ya utilizado'
      });
    }

    res.json({
      success: true,
      message: 'C√≥digo verificado correctamente'
    });

  } catch (error) {
    console.error('Error en verify-reset-code:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

// Resetear contrase√±a
app.post('/users/reset-password', async (req, res) => {
  try {
    const { email, code, newPassword } = req.body;

    if (!email || !code || !newPassword) {
      return res.status(400).json({
        success: false,
        message: 'Email, c√≥digo y nueva contrase√±a son requeridos'
      });
    }

    if (newPassword.length < 6) {
      return res.status(400).json({
        success: false,
        message: 'La contrase√±a debe tener al menos 6 caracteres'
      });
    }

    // Buscar el c√≥digo de recuperaci√≥n
    const passwordReset = await PasswordReset.findOne({
      email: email.toLowerCase(),
      code
    });

    if (!passwordReset) {
      return res.status(400).json({
        success: false,
        message: 'C√≥digo inv√°lido'
      });
    }

    // Verificar si el c√≥digo es v√°lido
    if (!passwordReset.isValid()) {
      return res.status(400).json({
        success: false,
        message: 'C√≥digo expirado o ya utilizado'
      });
    }

    // Buscar el usuario
    const user = await User.findOne({ email: email.toLowerCase() });
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Usuario no encontrado'
      });
    }

    // Actualizar la contrase√±a del usuario (el middleware pre-save se encargar√° del hashing)
    user.password = newPassword;
    await user.save();

    // Marcar el c√≥digo como usado
    await passwordReset.markAsUsed();

    console.log(`‚úÖ [PASSWORD RESET] Contrase√±a actualizada para ${email}`);

    res.json({
      success: true,
      message: 'Contrase√±a actualizada correctamente'
    });

  } catch (error) {
    console.error('Error en reset-password:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor'
    });
  }
});

const PORT = config.GATEWAY_PORT || 3000;

// ===== SERVICIOS DE FAVORITOS =====

// Endpoint para agregar/quitar favorito de actividad
app.post('/activities/:activityId/favorite', authenticateToken, async (req, res) => {
  try {
    console.log('‚ù§Ô∏è [FAVORITE] Agregando/quitando favorito');
    const { activityId } = req.params;
    const { userId } = req.user;
    const { studentId, isFavorite } = req.body;

    if (!studentId) {
      return res.status(400).json({
        success: false,
        message: 'ID del estudiante es requerido'
      });
    }

    // Verificar que la actividad existe
    const activity = await Activity.findById(activityId);
    if (!activity) {
      return res.status(404).json({
        success: false,
        message: 'Actividad no encontrada'
      });
    }

    // Verificar que el estudiante existe
    const student = await Student.findById(studentId);
    if (!student) {
      return res.status(404).json({
        success: false,
        message: 'Estudiante no encontrado'
      });
    }

    // Verificar que el usuario tiene acceso al estudiante
    // Para usuarios familiares, verificar a trav√©s de la asociaci√≥n en Shared
    const userAssociation = await Shared.findOne({
      user: userId,
      student: studentId,
      status: 'active'
    });

    if (!userAssociation) {
      return res.status(403).json({
        success: false,
        message: 'No tienes acceso a este estudiante'
      });
    }

    if (isFavorite) {
      // Agregar a favoritos
      const existingFavorite = await ActivityFavorite.findOne({
        user: userId,
        student: studentId,
        activity: activityId
      });

      if (!existingFavorite) {
        await ActivityFavorite.create({
          user: userId,
          student: studentId,
          activity: activityId,
          addedAt: new Date()
        });
        console.log('‚úÖ [FAVORITE] Favorito agregado');
      }
    } else {
      // Quitar de favoritos
      await ActivityFavorite.deleteOne({
        user: userId,
        student: studentId,
        activity: activityId
      });
      console.log('‚úÖ [FAVORITE] Favorito eliminado');
    }

    res.json({
      success: true,
      message: isFavorite ? 'Agregado a favoritos' : 'Eliminado de favoritos'
    });

  } catch (error) {
    console.error('‚ùå [FAVORITE] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor',
      error: error.message
    });
  }
});

// Endpoint para obtener favoritos de un estudiante
app.get('/students/:studentId/favorites', authenticateToken, async (req, res) => {
  try {
    console.log('‚ù§Ô∏è [FAVORITES] Obteniendo favoritos del estudiante');
    const { studentId } = req.params;
    const { userId } = req.user;

    // Verificar que el usuario tiene acceso al estudiante
    const userAssociation = await Shared.findOne({
      user: userId,
      student: studentId,
      status: 'active'
    });

    if (!userAssociation) {
      return res.status(403).json({
        success: false,
        message: 'No tienes acceso a este estudiante'
      });
    }

    // Obtener favoritos con detalles de la actividad
    const favorites = await ActivityFavorite.find({
      user: userId,
      student: studentId
    })
    .populate({
      path: 'activity',
      populate: [
        { path: 'account', select: 'nombre' },
        { path: 'division', select: 'nombre' },
        { path: 'usuario', select: 'name email' }
      ]
    })
    .sort({ addedAt: -1 });

    console.log('üîç [FAVORITES] Favoritos encontrados:', favorites.length);
    if (favorites.length > 0) {
      console.log('üîç [FAVORITES] Primer favorito:', JSON.stringify(favorites[0], null, 2));
      console.log('üîç [FAVORITES] Fecha de la actividad (createdAt):', favorites[0].activity?.createdAt);
      console.log('üîç [FAVORITES] Tipo de fecha:', typeof favorites[0].activity?.createdAt);
    }

    // Generar URLs firmadas para las im√°genes de las actividades
    const favoritesWithSignedUrls = await Promise.all(favorites.map(async (favorite) => {
      const favoriteObj = favorite.toObject();
      
      // Si la actividad tiene im√°genes, generar URLs firmadas
      if (favoriteObj.activity && favoriteObj.activity.imagenes && Array.isArray(favoriteObj.activity.imagenes)) {
        try {
          const imagenesSignedUrls = await Promise.all(favoriteObj.activity.imagenes.map(async (imageKey) => {
            // Generar URL firmada usando la key directamente
            const signedUrl = await generateSignedUrl(imageKey);
            return signedUrl;
          }));
          favoriteObj.activity.imagenes = imagenesSignedUrls;
        } catch (error) {
          console.error('Error generando URLs firmadas para actividad favorita:', favoriteObj.activity._id, error);
          favoriteObj.activity.imagenes = []; // No devolver URLs si falla
        }
      }
      
      return favoriteObj;
    }));

    res.json({
      success: true,
      data: favoritesWithSignedUrls
    });

  } catch (error) {
    console.error('‚ùå [FAVORITES] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor',
      error: error.message
    });
  }
});

// Endpoint para verificar si una actividad es favorita
app.get('/activities/:activityId/favorite/:studentId', authenticateToken, async (req, res) => {
  try {
    const { activityId, studentId } = req.params;
    const { userId } = req.user;

    // Verificar que el usuario tiene acceso al estudiante
    const userAssociation = await Shared.findOne({
      user: userId,
      student: studentId,
      status: 'active'
    });

    if (!userAssociation) {
      return res.status(403).json({
        success: false,
        message: 'No tienes acceso a este estudiante'
      });
    }

    const favorite = await ActivityFavorite.findOne({
      user: userId,
      student: studentId,
      activity: activityId
    });

    res.json({
      success: true,
      isFavorite: !!favorite
    });

  } catch (error) {
    console.error('‚ùå [FAVORITE CHECK] Error:', error);
    res.status(500).json({
      success: false,
      message: 'Error interno del servidor',
      error: error.message
    });
  }
});

// Middleware para rutas no encontradas (debe ir al final)
app.use('/*', (req, res) => {
  console.log(`‚ùå [404] Ruta no encontrada: ${req.method} ${req.originalUrl}`);
  res.status(404).json({
    success: false,
    message: 'Endpoint no encontrado'
  });
});

app.listen(PORT, '0.0.0.0', () => {
  console.log(`üöÄ API de Kiki corriendo en puerto ${PORT}`);
  console.log(`üì° Health check disponible en http://localhost:${PORT}/health`);
  console.log(`üìñ Documentaci√≥n disponible en http://localhost:${PORT}/api`);
  console.log(`üåê API accesible desde la red local en http://0.0.0.0:${PORT}`);
});

module.exports = app;
